<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NIGHTFALL - A Noir Detective Mystery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&family=Bebas+Neue&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
        }

        #game-canvas {
            background: #0d0d0d;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Film grain overlay */
        #film-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.08;
            z-index: 100;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Vignette effect */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.7) 100%);
        }

        /* Scanlines */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 98;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #hud .stat {
            margin-bottom: 8px;
            font-size: 14px;
            letter-spacing: 1px;
        }

        #hud .label {
            color: #8b7355;
            text-transform: uppercase;
            font-size: 10px;
        }

        #hud .value {
            color: #e8d5b7;
            font-size: 16px;
        }

        /* Location indicator */
        #location-display {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 4px;
            color: #d4c5a9;
            text-shadow: 0 0 20px rgba(212, 197, 169, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #location-display.visible {
            opacity: 1;
        }

        /* Time display */
        #time-display {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            text-align: right;
        }

        #time-display .time {
            font-size: 28px;
            color: #e8d5b7;
            text-shadow: 0 0 10px rgba(232, 213, 183, 0.3);
        }

        #time-display .date {
            font-size: 12px;
            color: #8b7355;
            letter-spacing: 2px;
        }

        /* Controls */
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(30, 25, 20, 0.8);
            border: 1px solid #3d3428;
            color: #8b7355;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        .d-btn:hover, .d-btn:active {
            background: rgba(60, 50, 40, 0.9);
            color: #d4c5a9;
        }

        #d-up { top: 0; left: 40px; border-radius: 8px 8px 0 0; }
        #d-down { bottom: 0; left: 40px; border-radius: 0 0 8px 8px; }
        #d-left { top: 40px; left: 0; border-radius: 8px 0 0 8px; }
        #d-right { top: 40px; right: 0; border-radius: 0 8px 8px 0; }
        #d-center { top: 40px; left: 40px; background: rgba(20, 16, 12, 0.9); cursor: default; }

        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(139, 69, 19, 0.6);
            border: 2px solid #8b7355;
            color: #d4c5a9;
            font-family: 'Special Elite', monospace;
            font-size: 10px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .action-btn:hover, .action-btn:active {
            background: rgba(180, 100, 40, 0.7);
            transform: scale(1.05);
        }

        /* Title screen */
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        #title-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #title-screen h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 120px;
            letter-spacing: 20px;
            color: #d4c5a9;
            text-shadow:
                0 0 40px rgba(212, 197, 169, 0.3),
                0 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }

        #title-screen .subtitle {
            font-family: 'Special Elite', monospace;
            font-size: 16px;
            letter-spacing: 8px;
            color: #8b7355;
            margin-bottom: 60px;
        }

        #title-screen .year {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 48px;
            color: #3d3428;
            letter-spacing: 15px;
            margin-bottom: 80px;
        }

        #title-screen .start-prompt {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            letter-spacing: 4px;
            color: #8b7355;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Dialogue box */
        #dialogue-box {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
            background: rgba(15, 12, 10, 0.95);
            border: 1px solid #3d3428;
            padding: 20px 25px;
            z-index: 60;
            display: none;
        }

        #dialogue-box.visible {
            display: block;
        }

        #dialogue-speaker {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 3px;
            color: #c4a35a;
            margin-bottom: 10px;
        }

        #dialogue-text {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #d4c5a9;
        }

        /* Interaction prompt */
        #interact-prompt {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Special Elite', monospace;
            font-size: 12px;
            letter-spacing: 2px;
            color: #c4a35a;
            background: rgba(15, 12, 10, 0.8);
            padding: 8px 16px;
            border: 1px solid #3d3428;
            z-index: 55;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #interact-prompt.visible {
            opacity: 1;
        }

        /* Mini map */
        #minimap {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 150px;
            height: 120px;
            background: rgba(15, 12, 10, 0.8);
            border: 1px solid #3d3428;
            z-index: 50;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            #title-screen h1 {
                font-size: 60px;
                letter-spacing: 10px;
            }

            #title-screen .year {
                font-size: 32px;
            }

            #minimap {
                width: 100px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- Film effects -->
        <div id="film-grain"></div>
        <div id="vignette"></div>
        <div id="scanlines"></div>

        <!-- Title Screen -->
        <div id="title-screen">
            <h1>NIGHTFALL</h1>
            <div class="subtitle">A NOIR DETECTIVE MYSTERY</div>
            <div class="year">1 9 5 9</div>
            <div class="start-prompt">PRESS ANY KEY TO BEGIN</div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div class="stat">
                <div class="label">Cash</div>
                <div class="value" id="cash-display">$50.00</div>
            </div>
            <div class="stat">
                <div class="label">Reputation</div>
                <div class="value" id="rep-display">■■■□□</div>
            </div>
            <div class="stat">
                <div class="label">Case</div>
                <div class="value" id="case-display">None</div>
            </div>
        </div>

        <!-- Time -->
        <div id="time-display">
            <div class="date">OCTOBER 14, 1959</div>
            <div class="time" id="clock">8:47 PM</div>
        </div>

        <!-- Location -->
        <div id="location-display">DOWNTOWN</div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <!-- Interaction prompt -->
        <div id="interact-prompt">[E] ENTER</div>

        <!-- Dialogue -->
        <div id="dialogue-box">
            <div id="dialogue-speaker">STRANGER</div>
            <div id="dialogue-text">The night has a way of revealing what the day keeps hidden...</div>
        </div>

        <!-- Controls -->
        <div id="controls">
            <div id="d-pad">
                <div class="d-btn" id="d-up">▲</div>
                <div class="d-btn" id="d-down">▼</div>
                <div class="d-btn" id="d-left">◄</div>
                <div class="d-btn" id="d-right">►</div>
                <div class="d-btn" id="d-center"></div>
            </div>
            <button class="action-btn" id="btn-interact">Enter</button>
            <button class="action-btn" id="btn-action">Action</button>
        </div>
    </div>

    <script>
        // ============================================
        // NIGHTFALL - A Noir Detective Mystery
        // Set in 1959 small-town America
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Game configuration
        const CONFIG = {
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 700,
            TILE_SIZE: 60,
            PLAYER_SPEED: 3,
            CAR_SPEED: 8,
            GAME_SPEED: 1, // Time multiplier
            SHADOW_LENGTH: 2.5,
            AMBIENT_LIGHT: 0.15
        };

        // Set canvas size
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;
        minimapCanvas.width = 150;
        minimapCanvas.height = 120;

        // Color palette - 1959 Noir
        const COLORS = {
            // Sky and atmosphere
            nightSky: '#0a0a14',
            twilightSky: '#1a1a2e',
            duskSky: '#2d1f3d',

            // Buildings
            brick: '#3d2b1f',
            brickDark: '#2a1d15',
            brickLight: '#4a3828',
            concrete: '#4a4a4a',
            concreteDark: '#333333',
            wood: '#5c4033',
            woodDark: '#3d2a22',

            // Windows and lights
            windowLit: '#e8c36a',
            windowDim: '#8b7355',
            windowDark: '#1a1a1a',
            neonRed: '#ff3333',
            neonBlue: '#3366ff',
            neonGreen: '#33ff66',
            streetLight: '#ffedcc',

            // Ground
            asphalt: '#2a2a2a',
            asphaltLight: '#3a3a3a',
            sidewalk: '#5a5a5a',
            sidewalkLight: '#6a6a6a',

            // Characters
            skin: '#d4a574',
            skinShadow: '#a67c52',
            suit: '#1a1a1a',
            suitGray: '#3d3d3d',
            hat: '#2a2a2a',

            // UI
            gold: '#c4a35a',
            cream: '#d4c5a9',
            shadow: 'rgba(0,0,0,0.7)'
        };

        // Game state
        const game = {
            state: 'title', // title, playing, dialogue, inventory, paused
            currentLevel: 1, // 1: Downtown, 2: Residential, 3: Industrial
            time: { hours: 20, minutes: 47 }, // 8:47 PM
            day: 1,
            cash: 50.00,
            reputation: 3, // 1-5
            currentCase: null,
            killerSchedule: [],
            killerStrikeTime: null
        };

        // Player state
        const player = {
            x: 600,
            y: 450, // Start on sidewalk (GROUND_LEVEL + 40)
            width: 24,
            height: 64,
            speed: CONFIG.PLAYER_SPEED,
            direction: 'right', // up, down, left, right
            facing: 1, // 1 = right, -1 = left
            isMoving: false,
            walkCycle: 0,
            inCar: false,
            currentCar: null,
            carSpeed: 0,
            inventory: [],
            weapon: 'fists', // fists, pistol
            ammo: 6,
            cash: 50,
            flashlightOn: false,
            nearInteractable: null,
            actionCooldown: 0,
            // Jack Noir's appearance - hardboiled detective look
            appearance: {
                skin: '#c9a882',
                faceShape: 'angular',
                eyeStyle: 'narrow',
                hairStyle: 'none', // hidden by fedora
                hairColor: '#2a2a2a',
                gender: 'm',
                stubble: true
            }
        };

        // Action system state
        const actions = {
            currentAction: null, // null, 'bribe', 'slap', 'shoot'
            targetNPC: null,
            actionTimer: 0
        };

        // ============================================
        // OBJECT PERMANENCY SYSTEM
        // ============================================
        const worldState = {
            // Window states persist - seeded by building ID
            windowStates: {},
            // NPC positions and states persist
            npcStates: {},
            // Props placed in world
            props: [],
            // Items dropped/placed
            items: [],
            // Doors opened/closed
            doorStates: {},
            // Events that have occurred
            events: [],
            initialized: false
        };

        // Initialize persistent world state
        function initWorldState() {
            if (worldState.initialized) return;

            // Generate consistent window states for each building
            currentMap.buildings.forEach(building => {
                const windowCount = Math.floor((building.width - 40) / 50) * building.floors;
                worldState.windowStates[building.id] = [];

                // Use building position as seed for consistency
                let seed = building.x * 100 + building.y;
                for (let i = 0; i < windowCount; i++) {
                    seed = (seed * 9301 + 49297) % 233280;
                    worldState.windowStates[building.id].push({
                        lit: (seed / 233280) > 0.35,
                        blindsDown: (seed / 233280) > 0.6,
                        silhouette: (seed / 233280) > 0.85 ? 'person' : null
                    });
                }
            });

            // Initialize NPC states with persistent positions
            npcs.forEach(npc => {
                worldState.npcStates[npc.id] = {
                    x: npc.x,
                    y: npc.y,
                    activity: 'idle',
                    facingRight: true,
                    talked: false,
                    bribed: false,
                    lastInteraction: null
                };
            });

            // Add street props - positioned on sidewalk (GROUND_LEVEL area)
            const sidewalkY = GROUND_LEVEL + 20; // Props sit on sidewalk

            worldState.props = [
                // Phone booths (tall, near curb)
                { type: 'phonebooth', x: 440, y: sidewalkY - 60 },
                { type: 'phonebooth', x: 1100, y: sidewalkY - 60 },
                { type: 'phonebooth', x: 1750, y: sidewalkY - 60 },
                // Benches (facing street)
                { type: 'bench', x: 180, y: sidewalkY - 22 },
                { type: 'bench', x: 560, y: sidewalkY - 22 },
                { type: 'bench', x: 1020, y: sidewalkY - 22 },
                { type: 'bench', x: 1550, y: sidewalkY - 22 },
                { type: 'bench', x: 2000, y: sidewalkY - 22 },
                // Trash cans (near light poles)
                { type: 'trashcan', x: 170, y: sidewalkY - 24 },
                { type: 'trashcan', x: 420, y: sidewalkY - 24 },
                { type: 'trashcan', x: 670, y: sidewalkY - 24 },
                { type: 'trashcan', x: 920, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1170, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1420, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1720, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1970, y: sidewalkY - 24 },
                // Fire hydrants (on curb edge)
                { type: 'hydrant', x: 260, y: sidewalkY - 22 },
                { type: 'hydrant', x: 700, y: sidewalkY - 22 },
                { type: 'hydrant', x: 1250, y: sidewalkY - 22 },
                { type: 'hydrant', x: 1650, y: sidewalkY - 22 },
                { type: 'hydrant', x: 2050, y: sidewalkY - 22 },
                // Newspaper stands
                { type: 'newsstand', x: 350, y: sidewalkY - 32 },
                { type: 'newsstand', x: 850, y: sidewalkY - 32 },
                { type: 'newsstand', x: 1500, y: sidewalkY - 32 },
                // Mailboxes
                { type: 'mailbox', x: 500, y: sidewalkY - 35 },
                { type: 'mailbox', x: 980, y: sidewalkY - 35 },
                { type: 'mailbox', x: 1600, y: sidewalkY - 35 },
                { type: 'mailbox', x: 2100, y: sidewalkY - 35 },
                // Street signs (at intersections)
                { type: 'streetsign', x: 50, y: sidewalkY - 50, text: 'MAIN ST' },
                { type: 'streetsign', x: 1200, y: sidewalkY - 50, text: 'ELM AVE' },
                { type: 'streetsign', x: 2000, y: sidewalkY - 50, text: 'OAK ST' }
            ];

            worldState.initialized = true;
        }

        // Camera
        const camera = {
            x: 0,
            y: 0,
            width: CONFIG.CANVAS_WIDTH,
            height: CONFIG.CANVAS_HEIGHT
        };

        // Input state
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            interact: false,
            action: false
        };

        // Ground level constant - buildings sit on this
        const GROUND_LEVEL = 410;
        const STREET_TOP = GROUND_LEVEL + 58;
        const STREET_BOTTOM = STREET_TOP + 120;

        // Town map - Level 1: Downtown (expanded with alleys)
        const DOWNTOWN = {
            width: 3200,
            height: 800,
            name: 'DOWNTOWN',
            buildings: [
                // Office Building (with PI office, accountant, attorney)
                {
                    id: 'office_building',
                    x: 60, y: 160,
                    width: 380, height: 250,
                    type: 'office',
                    name: "PROFESSIONAL BUILDING",
                    floors: 2,
                    color: '#4a3828',
                    offices: [
                        { name: "MILLER & ASSOCIATES\nTAX ACCOUNTANT", x: 0, door: true },
                        { name: "JAMES CRAWFORD\nATTORNEY AT LAW", x: 1, door: true },
                        { name: "JACK NOIR\nPRIVATE INVESTIGATOR", x: 2, door: true, isPlayerOffice: true }
                    ],
                    enterable: true,
                    interiorId: 'pi_office'
                },

                // === ALLEY 1 (40px gap) ===

                // Cafe/Diner - Classic American diner look
                {
                    id: 'cafe',
                    x: 500, y: 200,
                    width: 240, height: 210,
                    type: 'cafe',
                    name: "ROSIE'S DINER",
                    floors: 1,
                    color: '#c41e3a', // Diner red
                    accentColor: '#f0f0e8', // Cream trim
                    hasNeon: true,
                    neonText: "EAT",
                    neonColor: '#ff6b6b',
                    enterable: true,
                    interiorId: 'cafe'
                },

                // === ALLEY 2 (50px gap) ===

                // Pharmacy/Drug Store - Distinctive medical look
                {
                    id: 'pharmacy',
                    x: 800, y: 180,
                    width: 220, height: 230,
                    type: 'pharmacy',
                    name: "COLEMAN'S DRUGS",
                    floors: 1,
                    color: '#e8e8e0', // White/cream storefront
                    accentColor: '#1a5c1a', // Pharmacy green
                    enterable: true,
                    interiorId: 'pharmacy'
                },

                // === ALLEY 3 (45px gap) ===

                // Bookstore - Warm, inviting wood storefront
                {
                    id: 'bookstore',
                    x: 1075, y: 210,
                    width: 190, height: 200,
                    type: 'bookstore',
                    name: "CHAPTER & VERSE",
                    subtitle: "BOOKS & STATIONERY",
                    floors: 1,
                    color: '#3d2817', // Dark wood
                    accentColor: '#c4a35a', // Gold trim
                    enterable: true,
                    interiorId: 'bookstore'
                },

                // === ALLEY 4 (55px gap) ===

                // Bar - Dark, moody speakeasy look
                {
                    id: 'bar',
                    x: 1330, y: 180,
                    width: 250, height: 230,
                    type: 'bar',
                    name: "THE BLUE MOON",
                    subtitle: "COCKTAIL LOUNGE",
                    floors: 1,
                    color: '#1a1520', // Near black
                    accentColor: '#3366cc', // Blue accent
                    hasNeon: true,
                    neonText: "COCKTAILS",
                    neonColor: '#4488ff',
                    enterable: true,
                    interiorId: 'bar'
                },

                // === ALLEY 5 (60px gap) ===

                // Movie Theater - Grand art deco facade
                {
                    id: 'theater',
                    x: 1650, y: 100,
                    width: 400, height: 310,
                    type: 'theater',
                    name: "PARAMOUNT",
                    floors: 2,
                    color: '#2a2a35', // Dark blue-gray
                    accentColor: '#c4a35a', // Gold trim
                    marquee: true,
                    nowPlaying: [
                        { title: "NORTH BY NORTHWEST", times: "7:00  9:30" },
                        { title: "THE NUN'S STORY", times: "6:45  9:15" }
                    ],
                    enterable: true,
                    interiorId: 'theater'
                },

                // === ALLEY 6 (50px gap) ===

                // Police Station - Imposing civic building
                {
                    id: 'police',
                    x: 2110, y: 140,
                    width: 300, height: 270,
                    type: 'police',
                    name: "POLICE",
                    subtitle: "CITY OF MILLBROOK",
                    floors: 2,
                    color: '#4a4a4a', // Gray stone
                    accentColor: '#1a1a3a', // Navy blue
                    enterable: true,
                    interiorId: 'police'
                },

                // === ALLEY 7 (55px gap) ===

                // Apartment Building - Tall residential
                {
                    id: 'apartments',
                    x: 2470, y: 60,
                    width: 200, height: 350,
                    type: 'apartment',
                    name: "LAKESIDE",
                    subtitle: "APARTMENTS",
                    floors: 3,
                    color: '#5a4030', // Brown brick
                    apartments: [
                        { floor: 1, resident: "Mrs. Henderson" },
                        { floor: 2, resident: "Frank Torres" },
                        { floor: 3, resident: "Empty" }
                    ],
                    enterable: true,
                    interiorId: 'apartments'
                }
            ],

            // Alleys between buildings (dark gaps with detail)
            alleys: [
                { x: 440, width: 50 },   // After office
                { x: 750, width: 40 },   // After cafe
                { x: 1030, width: 35 },  // After pharmacy
                { x: 1275, width: 45 },  // After bookstore
                { x: 1590, width: 50 },  // After bar
                { x: 2060, width: 40 },  // After theater
                { x: 2420, width: 40 }   // After police
            ],

            // Street lights - positioned on sidewalk
            streetLights: [
                { x: 150, y: 355 },
                { x: 470, y: 355 },
                { x: 780, y: 355 },
                { x: 1050, y: 355 },
                { x: 1310, y: 355 },
                { x: 1620, y: 355 },
                { x: 1900, y: 355 },
                { x: 2200, y: 355 },
                { x: 2500, y: 355 },
                { x: 2800, y: 355 }
            ],

            // Parked cars - on the street
            cars: [
                { x: 200, y: 490, color: '#2a3d2a', model: 'sedan', canEnter: false },
                { x: 400, y: 490, color: '#4a2a2a', model: 'coupe', canEnter: false },
                { x: 650, y: 490, color: '#1a1a2a', model: 'sedan', canEnter: true }, // Player's car
                { x: 950, y: 490, color: '#3d3d3d', model: 'sedan', canEnter: false },
                { x: 1200, y: 490, color: '#2a2a3d', model: 'coupe', canEnter: false },
                { x: 1500, y: 490, color: '#3d2a2a', model: 'sedan', canEnter: false },
                { x: 1850, y: 490, color: '#2a3a2a', model: 'sedan', canEnter: false },
                { x: 2150, y: 490, color: '#3a3a3a', model: 'truck', canEnter: false },
                { x: 2450, y: 490, color: '#2a2a2a', model: 'sedan', canEnter: false },
                { x: 2750, y: 490, color: '#3d3d2a', model: 'coupe', canEnter: false }
            ],

            // Collision rectangles for solid objects
            colliders: [
                { x: 60, y: 160, width: 380, height: 255 },
                { x: 500, y: 200, width: 240, height: 215 },
                { x: 800, y: 180, width: 220, height: 235 },
                { x: 1075, y: 210, width: 190, height: 205 },
                { x: 1330, y: 180, width: 250, height: 235 },
                { x: 1650, y: 100, width: 400, height: 315 },
                { x: 2110, y: 140, width: 300, height: 275 },
                { x: 2470, y: 60, width: 200, height: 355 }
            ],

            // NPCs on streets
            streetNPCs: []
        };

        // Current level reference
        let currentMap = DOWNTOWN;

        // NPCs
        const npcs = [
            // Cafe staff
            { id: 'waitress', name: 'Rosie', location: 'cafe', role: 'owner', x: 600, y: 280,
              dialogue: ["Coffee's hot, stranger.", "You look like you could use a cup."],
              appearance: { skin: '#d4a574', faceShape: 'round', eyeStyle: 'wide', hairStyle: 'updo', hairColor: '#8b4513', gender: 'f' } },
            { id: 'cook', name: 'Earl', location: 'cafe', role: 'cook', x: 650, y: 300,
              dialogue: ["Order up!", "Kitchen's closing in an hour."],
              appearance: { skin: '#8b5a3c', faceShape: 'wide', eyeStyle: 'narrow', hairStyle: 'bald', gender: 'm', heavyset: true } },

            // Pharmacy
            { id: 'pharmacist', name: 'Mr. Coleman', location: 'pharmacy', role: 'pharmacist', x: 900, y: 280,
              dialogue: ["Can I help you find something?", "Prescription ready in 10 minutes."],
              appearance: { skin: '#e8c4a0', faceShape: 'thin', eyeStyle: 'glasses', hairStyle: 'parted', hairColor: '#4a4a4a', gender: 'm', age: 'old' } },

            // Bookstore
            { id: 'bookstore_husband', name: 'Harold', location: 'bookstore', role: 'owner', x: 1150, y: 280,
              dialogue: ["Looking for anything in particular?", "New shipment of mysteries came in."],
              appearance: { skin: '#d4b896', faceShape: 'angular', eyeStyle: 'small', hairStyle: 'receding', hairColor: '#6b6b6b', gender: 'm', age: 'middle' } },
            { id: 'bookstore_wife', name: 'Margaret', location: 'bookstore', role: 'owner', x: 1200, y: 300,
              dialogue: ["The poetry section is in the back.", "Harold, we have a customer."],
              appearance: { skin: '#f0d5b8', faceShape: 'oval', eyeStyle: 'almond', hairStyle: 'bob', hairColor: '#8b7355', gender: 'f', age: 'middle' } },

            // Bar
            { id: 'bartender', name: 'Mickey', location: 'bar', role: 'bartender', x: 180, y: 620,
              dialogue: ["What'll it be?", "We don't want any trouble here."], canBeBribed: true,
              appearance: { skin: '#c49a6c', faceShape: 'square', eyeStyle: 'narrow', hairStyle: 'slicked', hairColor: '#1a1a1a', gender: 'm', scar: true } },
            { id: 'barfly1', name: 'Old Joe', location: 'bar', role: 'patron', x: 220, y: 650,
              dialogue: ["*mumbles*", "Buy me a drink and I'll tell you something."], canBeBribed: true,
              appearance: { skin: '#c9a882', faceShape: 'gaunt', eyeStyle: 'droopy', hairStyle: 'messy', hairColor: '#9a9a9a', gender: 'm', age: 'old', stubble: true } },

            // Theater
            { id: 'box_office', name: 'Betty', location: 'theater', role: 'employee', x: 550, y: 600,
              dialogue: ["Two screens tonight. Hitchcock or Hepburn?", "Show starts in fifteen."],
              appearance: { skin: '#f5deb3', faceShape: 'heart', eyeStyle: 'large', hairStyle: 'curled', hairColor: '#daa520', gender: 'f', lipstick: true } },

            // Police
            { id: 'desk_sergeant', name: 'Sgt. O\'Brien', location: 'police', role: 'police', x: 1000, y: 620,
              dialogue: ["State your business.", "This is a police station, not a social club."],
              appearance: { skin: '#e8b89a', faceShape: 'heavy', eyeStyle: 'stern', hairStyle: 'crew', hairColor: '#cd5c5c', gender: 'm', mustache: true } },

            // PI Office
            { id: 'secretary', name: 'Dolores', location: 'pi_office', role: 'secretary', x: 250, y: 280,
              dialogue: ["A client is waiting, Mr. Noir.", "The phone's been ringing all day."],
              appearance: { skin: '#d4a574', faceShape: 'elegant', eyeStyle: 'cat', hairStyle: 'waves', hairColor: '#2a1a0a', gender: 'f', lipstick: true } },

            // STREET NPCs (pedestrians walking around)
            { id: 'pedestrian1', name: 'Businessman', location: 'street', role: 'pedestrian', x: 300, y: 470,
              dialogue: ["Excuse me, I'm late for a meeting.", "Do I know you?"],
              appearance: { skin: '#d4b896', gender: 'm', hairStyle: 'parted', hairColor: '#3a3a3a' }, canBeBribed: false },
            { id: 'pedestrian2', name: 'Lady', location: 'street', role: 'pedestrian', x: 800, y: 475,
              dialogue: ["Good evening.", "Lovely night, isn't it?"],
              appearance: { skin: '#f0d5b8', gender: 'f', hairStyle: 'curled', hairColor: '#8b4513' }, canBeBribed: false },
            { id: 'pedestrian3', name: 'Dockworker', location: 'street', role: 'pedestrian', x: 1400, y: 465,
              dialogue: ["Just got off my shift.", "What're you looking at?"],
              appearance: { skin: '#c49a6c', gender: 'm', hairStyle: 'crew', hairColor: '#2a2a2a' }, canBeBribed: true },
            { id: 'pedestrian4', name: 'Newsboy', location: 'street', role: 'pedestrian', x: 1900, y: 480,
              dialogue: ["Extra! Extra! Read all about it!", "Paper's just a nickel, mister."],
              appearance: { skin: '#d4a574', gender: 'm', hairStyle: 'messy', hairColor: '#5a4030', age: 'young' }, canBeBribed: true },
            { id: 'suspicious_man', name: 'Stranger', location: 'street', role: 'pedestrian', x: 2200, y: 470,
              dialogue: ["...", "*glances nervously*", "I don't know nothing about nothing."],
              appearance: { skin: '#c9a882', gender: 'm', hairStyle: 'slicked', hairColor: '#1a1a1a', stubble: true }, canBeBribed: true }
        ];

        // Killer AI
        const killer = {
            id: 'the_stranger',
            currentLocation: 'bar',
            schedule: [
                { time: '19:00', location: 'cafe', action: 'eating' },
                { time: '20:30', location: 'bar', action: 'drinking' },
                { time: '22:00', location: 'street', action: 'stalking' },
                { time: '23:30', location: 'apartments', action: 'hunting' }
            ],
            urgeLevel: 0, // 0-100
            targetNPC: null,
            state: 'normal', // normal, agitated, hunting, attacking
            visible: true, // Blends in as normal NPC
            disguise: 'businessman'
        };

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);

            // Night sky gradient
            if (game.time.hours >= 21 || game.time.hours < 5) {
                gradient.addColorStop(0, '#050510');
                gradient.addColorStop(0.5, '#0a0a1a');
                gradient.addColorStop(1, '#0f0f20');
            } else if (game.time.hours >= 18) {
                // Dusk
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.3, '#2d1f3d');
                gradient.addColorStop(0.7, '#3d2a4a');
                gradient.addColorStop(1, '#1a1a2e');
            } else {
                // Day (we'll mostly be in evening/night)
                gradient.addColorStop(0, '#4a4a6e');
                gradient.addColorStop(1, '#2a2a4e');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Stars (at night)
            if (game.time.hours >= 20 || game.time.hours < 5) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 47 + camera.x * 0.1) % CONFIG.CANVAS_WIDTH;
                    const y = (i * 31) % (CONFIG.CANVAS_HEIGHT * 0.4);
                    const size = (i % 3) * 0.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawGround() {
            // World coordinates for ground elements
            const worldLeft = camera.x;
            const worldRight = camera.x + CONFIG.CANVAS_WIDTH;

            // Fixed Y positions in screen space (buildings sit on this)
            const sidewalkTopY = 410;  // Where buildings meet ground
            const curbTopY = sidewalkTopY + 50;  // Top curb
            const streetY = curbTopY + 8;  // Street surface
            const streetBottomY = streetY + 120;  // Bottom of street
            const curbBottomY = streetBottomY;  // Bottom curb
            const sidewalkBottomY = curbBottomY + 8;  // Bottom sidewalk start

            // === TOP SIDEWALK (where player walks in front of buildings) ===
            // Concrete base
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, sidewalkTopY, CONFIG.CANVAS_WIDTH, 50);

            // Concrete texture - expansion joints
            ctx.strokeStyle = '#4a4642';
            ctx.lineWidth = 2;
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                ctx.beginPath();
                ctx.moveTo(x, sidewalkTopY);
                ctx.lineTo(x, sidewalkTopY + 50);
                ctx.stroke();
            }

            // Sidewalk surface detail - slight color variation for slabs
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                const shade = ((x + camera.x) * 7) % 20 - 10;
                ctx.fillStyle = `rgb(${90 + shade}, ${86 + shade}, ${82 + shade})`;
                ctx.fillRect(x + 2, sidewalkTopY + 2, 76, 46);
            }

            // === TOP CURB ===
            // Curb face (vertical)
            ctx.fillStyle = '#6a6662';
            ctx.fillRect(0, curbTopY, CONFIG.CANVAS_WIDTH, 8);

            // Curb top edge highlight
            ctx.fillStyle = '#7a7672';
            ctx.fillRect(0, curbTopY, CONFIG.CANVAS_WIDTH, 2);

            // Curb shadow
            ctx.fillStyle = '#3a3632';
            ctx.fillRect(0, curbTopY + 6, CONFIG.CANVAS_WIDTH, 2);

            // === GUTTER ===
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, streetY - 3, CONFIG.CANVAS_WIDTH, 3);

            // === STREET SURFACE ===
            // Base asphalt - darker, solid
            ctx.fillStyle = '#1f1f1f';
            ctx.fillRect(0, streetY, CONFIG.CANVAS_WIDTH, 120);

            // Asphalt texture - aggregate spots (fixed world positions, scroll with camera)
            ctx.fillStyle = '#2a2a2a';
            for (let i = 0; i < 300; i++) {
                const seed = (i * 1337) % 10000;
                // World x position (fixed in world space)
                const worldX = (seed * 17) % currentMap.width;
                // Convert to screen position
                const screenX = worldX - camera.x;
                // Only draw if on screen
                if (screenX >= -5 && screenX <= CONFIG.CANVAS_WIDTH + 5) {
                    const y = streetY + (seed * 13) % 120;
                    const size = (seed % 3) + 1;
                    ctx.fillRect(screenX, y, size, size);
                }
            }

            // Darker patches (oil stains, wear) - fixed world positions
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            const oilStains = [
                { x: 150, y: 30, w: 25, h: 12 },
                { x: 380, y: 55, w: 18, h: 10 },
                { x: 620, y: 40, w: 30, h: 15 },
                { x: 890, y: 70, w: 22, h: 11 },
                { x: 1150, y: 35, w: 28, h: 14 },
                { x: 1420, y: 60, w: 20, h: 10 },
                { x: 1680, y: 45, w: 32, h: 16 },
                { x: 1950, y: 55, w: 24, h: 12 },
                { x: 2200, y: 38, w: 26, h: 13 },
                { x: 2480, y: 65, w: 22, h: 11 },
                { x: 2750, y: 42, w: 28, h: 14 },
                { x: 3000, y: 58, w: 20, h: 10 }
            ];
            for (const stain of oilStains) {
                const screenX = stain.x - camera.x;
                if (screenX >= -40 && screenX <= CONFIG.CANVAS_WIDTH + 40) {
                    ctx.beginPath();
                    ctx.ellipse(screenX, streetY + stain.y, stain.w, stain.h, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Center line - yellow dashed (scrolls with camera)
            ctx.strokeStyle = '#8a7a2a';
            ctx.lineWidth = 3;
            ctx.setLineDash([40, 30]);
            ctx.lineDashOffset = -camera.x; // Makes dashes scroll with world
            ctx.beginPath();
            ctx.moveTo(0, streetY + 60);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 60);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;

            // Edge lines - white solid (subtle lane markers)
            ctx.strokeStyle = '#4a4a4a';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 60]);
            ctx.lineDashOffset = -camera.x;
            ctx.beginPath();
            ctx.moveTo(0, streetY + 8);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 8);
            ctx.moveTo(0, streetY + 112);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 112);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;

            // === BOTTOM GUTTER ===
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, streetBottomY, CONFIG.CANVAS_WIDTH, 3);

            // === BOTTOM CURB ===
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(0, curbBottomY, CONFIG.CANVAS_WIDTH, 8);
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, curbBottomY, CONFIG.CANVAS_WIDTH, 2);

            // === BOTTOM SIDEWALK ===
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, sidewalkBottomY, CONFIG.CANVAS_WIDTH, 60);

            // Expansion joints
            ctx.strokeStyle = '#4a4642';
            ctx.lineWidth = 2;
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                ctx.beginPath();
                ctx.moveTo(x, sidewalkBottomY);
                ctx.lineTo(x, sidewalkBottomY + 60);
                ctx.stroke();
            }

            // Bottom sidewalk fades to edge of screen
            const bottomGradient = ctx.createLinearGradient(0, sidewalkBottomY + 40, 0, CONFIG.CANVAS_HEIGHT);
            bottomGradient.addColorStop(0, '#5a5652');
            bottomGradient.addColorStop(1, '#2a2622');
            ctx.fillStyle = bottomGradient;
            ctx.fillRect(0, sidewalkBottomY + 40, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT - sidewalkBottomY - 40);
        }

        function drawBuilding(building) {
            const bx = building.x - camera.x;
            // Buildings have fixed Y positions - no camera.y offset (side-scroller)
            const by = building.y;
            const groundLevel = 410; // Where buildings meet sidewalk

            // Skip if off screen
            if (bx + building.width < -50 || bx > CONFIG.CANVAS_WIDTH + 50) return;

            // === BUILDING SHADOW (cast on ground) ===
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.moveTo(bx + building.width, groundLevel);
            ctx.lineTo(bx + building.width + 30, groundLevel);
            ctx.lineTo(bx + building.width + 30, groundLevel + 15);
            ctx.lineTo(bx + building.width, groundLevel + 15);
            ctx.closePath();
            ctx.fill();

            // === FOUNDATION ===
            ctx.fillStyle = '#2a2622';
            ctx.fillRect(bx - 3, groundLevel - 15, building.width + 6, 18);
            // Foundation top edge
            ctx.fillStyle = '#3a3632';
            ctx.fillRect(bx - 3, groundLevel - 15, building.width + 6, 3);

            // === MAIN BUILDING STRUCTURE ===
            // Side depth (3D effect) - left side darker
            ctx.fillStyle = adjustBrightness(building.color, 0.6);
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(bx - 8, by + 8);
            ctx.lineTo(bx - 8, groundLevel - 12);
            ctx.lineTo(bx, groundLevel - 15);
            ctx.closePath();
            ctx.fill();

            // Main facade - solid opaque fill
            ctx.fillStyle = building.color;
            ctx.fillRect(bx, by, building.width, groundLevel - 15 - by);

            // === BRICK/MATERIAL TEXTURE ===
            if (building.type !== 'theater') {
                // Brick pattern with proper mortar lines
                const brickHeight = 12;
                const brickWidth = 28;
                const mortarColor = adjustBrightness(building.color, 0.7);

                // Horizontal mortar lines
                ctx.strokeStyle = mortarColor;
                ctx.lineWidth = 1;
                for (let row = by + brickHeight; row < groundLevel - 15; row += brickHeight) {
                    ctx.beginPath();
                    ctx.moveTo(bx, row);
                    ctx.lineTo(bx + building.width, row);
                    ctx.stroke();
                }

                // Vertical mortar lines (staggered)
                let rowNum = 0;
                for (let row = by; row < groundLevel - 15; row += brickHeight) {
                    const offset = (rowNum % 2) * (brickWidth / 2);
                    for (let col = offset; col < building.width; col += brickWidth) {
                        ctx.beginPath();
                        ctx.moveTo(bx + col, row);
                        ctx.lineTo(bx + col, row + brickHeight);
                        ctx.stroke();
                    }
                    rowNum++;
                }

                // Subtle brick color variation
                for (let row = by; row < groundLevel - 20; row += brickHeight) {
                    const offset = ((row - by) / brickHeight % 2) * (brickWidth / 2);
                    for (let col = offset; col < building.width - brickWidth; col += brickWidth) {
                        const variation = ((row * 7 + col * 13) % 30) - 15;
                        if (Math.abs(variation) > 8) {
                            ctx.fillStyle = `rgba(${variation > 0 ? 255 : 0}, ${variation > 0 ? 255 : 0}, ${variation > 0 ? 255 : 0}, 0.05)`;
                            ctx.fillRect(bx + col + 1, row + 1, brickWidth - 2, brickHeight - 2);
                        }
                    }
                }
            }

            // === AWNING (for shops) ===
            if (['cafe', 'pharmacy', 'bookstore', 'bar'].includes(building.type)) {
                const awningY = by + building.height * 0.65;
                const awningDepth = 25;

                // Awning frame shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(bx + 10, awningY + awningDepth, building.width - 20, 8);

                // Awning top
                ctx.fillStyle = building.type === 'cafe' ? '#8b2020' :
                               building.type === 'bar' ? '#20208b' :
                               building.type === 'pharmacy' ? '#208b20' : '#5a4030';
                ctx.beginPath();
                ctx.moveTo(bx + 10, awningY);
                ctx.lineTo(bx + building.width - 10, awningY);
                ctx.lineTo(bx + building.width - 10 + awningDepth * 0.3, awningY + awningDepth);
                ctx.lineTo(bx + 10 - awningDepth * 0.3, awningY + awningDepth);
                ctx.closePath();
                ctx.fill();

                // Awning stripes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 8;
                for (let i = 0; i < 6; i++) {
                    const x = bx + 30 + i * ((building.width - 40) / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, awningY + 2);
                    ctx.lineTo(x + awningDepth * 0.2, awningY + awningDepth - 2);
                    ctx.stroke();
                }

                // Awning edge
                ctx.fillStyle = adjustBrightness(building.type === 'cafe' ? '#8b2020' : '#5a4030', 0.7);
                ctx.fillRect(bx + 10 - awningDepth * 0.3, awningY + awningDepth - 3, building.width - 20 + awningDepth * 0.6, 5);
            }

            // === CORNICE (roof detail) ===
            // Decorative top edge
            ctx.fillStyle = adjustBrightness(building.color, 1.2);
            ctx.fillRect(bx - 2, by - 8, building.width + 4, 10);
            ctx.fillRect(bx - 4, by - 3, building.width + 8, 5);

            // Cornice shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by + 2, building.width, 4);

            // === PARAPET (roof wall) ===
            ctx.fillStyle = adjustBrightness(building.color, 0.9);
            ctx.fillRect(bx, by - 20, building.width, 15);

            // Windows
            drawBuildingWindows(building, bx, by);

            // Door
            drawBuildingDoor(building, bx, groundLevel);

            // Sign/Name
            drawBuildingSign(building, bx, by);

            // Neon sign if applicable
            if (building.hasNeon) {
                drawNeonSign(building, bx, by);
            }

            // Theater marquee
            if (building.marquee) {
                drawTheaterMarquee(building, bx, by);
            }

            // Building-specific details
            if (building.type === 'pharmacy') {
                drawPharmacyDetails(building, bx, by);
            } else if (building.type === 'cafe') {
                drawCafeDetails(building, bx, by);
            } else if (building.type === 'bar') {
                drawBarDetails(building, bx, by);
            } else if (building.type === 'bookstore') {
                drawBookstoreDetails(building, bx, by);
            } else if (building.type === 'police') {
                drawPoliceDetails(building, bx, by);
            } else if (building.type === 'apartment') {
                drawApartmentDetails(building, bx, by);
            }
        }

        function drawBuildingWindows(building, bx, by) {
            const windowWidth = 35;
            const windowHeight = 45;
            const windowSpacing = 50;
            const windowsPerFloor = Math.floor((building.width - 40) / windowSpacing);
            const floorHeight = building.height / building.floors;

            // Get persistent window states for this building
            const windowStates = worldState.windowStates[building.id] || [];

            let windowIndex = 0;
            for (let floor = 0; floor < building.floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    const wx = bx + 30 + w * windowSpacing;
                    const wy = by + 30 + floor * floorHeight;

                    // Get this window's persistent state
                    const state = windowStates[windowIndex] || { lit: false, blindsDown: false, silhouette: null };
                    windowIndex++;

                    // Window frame (deeper recess)
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(wx - 2, wy - 2, windowWidth + 4, windowHeight + 4);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(wx, wy, windowWidth, windowHeight);

                    if (state.lit) {
                        // Warm interior light gradient
                        const gradient = ctx.createLinearGradient(wx, wy, wx, wy + windowHeight);
                        gradient.addColorStop(0, '#f0d890');
                        gradient.addColorStop(0.5, COLORS.windowLit);
                        gradient.addColorStop(1, COLORS.windowDim);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Window glow (subtle)
                        ctx.shadowColor = COLORS.windowLit;
                        ctx.shadowBlur = 12;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);
                        ctx.shadowBlur = 0;

                        // Blinds (if down - persistent)
                        if (state.blindsDown) {
                            ctx.fillStyle = 'rgba(180, 160, 120, 0.7)';
                            ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 8);

                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                            ctx.lineWidth = 1;
                            for (let b = 0; b < 6; b++) {
                                ctx.beginPath();
                                ctx.moveTo(wx + 2, wy + 6 + b * 6);
                                ctx.lineTo(wx + windowWidth - 2, wy + 6 + b * 6);
                                ctx.stroke();
                            }
                        }

                        // Silhouette in window (persistent)
                        if (state.silhouette === 'person' && !state.blindsDown) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            // Head
                            ctx.beginPath();
                            ctx.arc(wx + windowWidth/2, wy + 15, 6, 0, Math.PI * 2);
                            ctx.fill();
                            // Shoulders
                            ctx.beginPath();
                            ctx.moveTo(wx + windowWidth/2 - 10, wy + 35);
                            ctx.lineTo(wx + windowWidth/2 - 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 10, wy + 35);
                            ctx.closePath();
                            ctx.fill();
                        }
                    } else {
                        // Dark window with subtle reflection
                        ctx.fillStyle = COLORS.windowDark;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Night sky reflection
                        ctx.fillStyle = 'rgba(30, 30, 50, 0.5)';
                        ctx.fillRect(wx + 3, wy + 3, windowWidth - 6, windowHeight / 3);
                    }

                    // Window cross frame
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(wx + windowWidth / 2, wy);
                    ctx.lineTo(wx + windowWidth / 2, wy + windowHeight);
                    ctx.moveTo(wx, wy + windowHeight / 2);
                    ctx.lineTo(wx + windowWidth, wy + windowHeight / 2);
                    ctx.stroke();

                    // Window sill
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(wx - 2, wy + windowHeight, windowWidth + 4, 3);
                }
            }
        }

        function drawBuildingDoor(building, bx, groundLevel) {
            const doorWidth = 45;
            const doorHeight = 75;
            const doorX = bx + building.width / 2 - doorWidth / 2;
            const doorY = groundLevel - 15 - doorHeight;

            // Check if player is near door for highlight
            const playerNearDoor = Math.abs(player.x - camera.x - doorX - doorWidth/2) < 40 &&
                                   Math.abs(player.y - camera.y - groundLevel + 30) < 50;

            // === DOOR RECESS (depth) ===
            ctx.fillStyle = '#0a0805';
            ctx.fillRect(doorX - 8, doorY - 5, doorWidth + 16, doorHeight + 8);

            // Recess sides (3D depth)
            ctx.fillStyle = '#1a1510';
            ctx.fillRect(doorX - 8, doorY - 5, 6, doorHeight + 8);
            ctx.fillRect(doorX + doorWidth + 2, doorY - 5, 6, doorHeight + 8);

            // === DOOR FRAME ===
            ctx.fillStyle = '#2a2015';
            ctx.fillRect(doorX - 3, doorY - 3, doorWidth + 6, doorHeight + 6);

            // === DOOR ===
            const doorColor = playerNearDoor ? '#3a3025' : '#251a10';
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);

            // Door panels (raised)
            ctx.strokeStyle = '#1a1008';
            ctx.lineWidth = 2;
            // Top panel
            ctx.strokeRect(doorX + 5, doorY + 8, doorWidth - 10, 25);
            // Bottom panel
            ctx.strokeRect(doorX + 5, doorY + 40, doorWidth - 10, 28);

            // Panel highlights
            ctx.strokeStyle = '#3a2a18';
            ctx.lineWidth = 1;
            ctx.strokeRect(doorX + 6, doorY + 9, doorWidth - 12, 23);
            ctx.strokeRect(doorX + 6, doorY + 41, doorWidth - 12, 26);

            // === DOOR WINDOW (for certain types) ===
            if (['office', 'cafe', 'bar'].includes(building.type)) {
                // Window frame
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(doorX + 8, doorY + 10, doorWidth - 16, 22);

                // Glass with interior glow
                const glassGradient = ctx.createLinearGradient(doorX + 8, doorY + 10, doorX + 8, doorY + 32);
                glassGradient.addColorStop(0, 'rgba(200, 180, 140, 0.4)');
                glassGradient.addColorStop(1, 'rgba(150, 130, 90, 0.3)');
                ctx.fillStyle = glassGradient;
                ctx.fillRect(doorX + 10, doorY + 12, doorWidth - 20, 18);

                // Frosted glass text (business name hint)
                if (building.type === 'office') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.font = '7px Special Elite';
                    ctx.textAlign = 'center';
                    ctx.fillText('PRIVATE', doorX + doorWidth / 2, doorY + 23);
                }

                // Glass reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.moveTo(doorX + 10, doorY + 12);
                ctx.lineTo(doorX + 20, doorY + 12);
                ctx.lineTo(doorX + 10, doorY + 22);
                ctx.closePath();
                ctx.fill();
            }

            // === DOOR HARDWARE ===
            // Handle plate
            ctx.fillStyle = '#b8860b';
            ctx.fillRect(doorX + doorWidth - 14, doorY + 35, 8, 18);

            // Door knob
            ctx.fillStyle = '#d4a835';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 10, doorY + 42, 4, 0, Math.PI * 2);
            ctx.fill();

            // Knob highlight
            ctx.fillStyle = '#f0d060';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 11, doorY + 41, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Keyhole
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 10, doorY + 48, 2, 0, Math.PI * 2);
            ctx.fill();

            // === TRANSOM WINDOW (above door) ===
            ctx.fillStyle = '#0a0805';
            ctx.fillRect(doorX - 3, doorY - 20, doorWidth + 6, 15);

            // Transom glass
            const transomGlow = ctx.createLinearGradient(doorX, doorY - 20, doorX, doorY - 5);
            transomGlow.addColorStop(0, 'rgba(180, 160, 120, 0.3)');
            transomGlow.addColorStop(1, 'rgba(220, 190, 140, 0.5)');
            ctx.fillStyle = transomGlow;
            ctx.fillRect(doorX, doorY - 18, doorWidth, 11);

            // Transom dividers
            ctx.strokeStyle = '#1a1510';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(doorX + doorWidth * 0.33, doorY - 18);
            ctx.lineTo(doorX + doorWidth * 0.33, doorY - 7);
            ctx.moveTo(doorX + doorWidth * 0.66, doorY - 18);
            ctx.lineTo(doorX + doorWidth * 0.66, doorY - 7);
            ctx.stroke();

            // === LIGHT FIXTURE ===
            // Bracket
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(doorX + doorWidth / 2 - 3, doorY - 35, 6, 12);

            // Light fixture body
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.moveTo(doorX + doorWidth / 2 - 10, doorY - 35);
            ctx.lineTo(doorX + doorWidth / 2 + 10, doorY - 35);
            ctx.lineTo(doorX + doorWidth / 2 + 6, doorY - 45);
            ctx.lineTo(doorX + doorWidth / 2 - 6, doorY - 45);
            ctx.closePath();
            ctx.fill();

            // Light glow
            ctx.fillStyle = COLORS.windowLit;
            ctx.shadowColor = COLORS.windowLit;
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(doorX + doorWidth / 2, doorY - 38, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Light cone on ground
            const lightCone = ctx.createRadialGradient(
                doorX + doorWidth / 2, groundLevel - 5, 0,
                doorX + doorWidth / 2, groundLevel - 5, 60
            );
            lightCone.addColorStop(0, 'rgba(255, 237, 200, 0.25)');
            lightCone.addColorStop(1, 'rgba(255, 237, 200, 0)');
            ctx.fillStyle = lightCone;
            ctx.fillRect(doorX - 30, groundLevel - 20, doorWidth + 60, 25);

            // === INTERACTION HIGHLIGHT ===
            if (playerNearDoor) {
                ctx.strokeStyle = 'rgba(196, 163, 90, 0.6)';
                ctx.lineWidth = 2;
                ctx.strokeRect(doorX - 5, doorY - 22, doorWidth + 10, doorHeight + 27);
            }

            // === STEP ===
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(doorX - 10, groundLevel - 18, doorWidth + 20, 5);
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(doorX - 10, groundLevel - 18, doorWidth + 20, 2);
        }

        function drawBuildingSign(building, bx, by) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(bx + 10, by - 35, building.width - 20, 30);

            ctx.fillStyle = COLORS.cream;
            ctx.font = 'bold 12px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lines = building.name.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, bx + building.width / 2, by - 25 + i * 12);
            });
        }

        function drawNeonSign(building, bx, by) {
            const signX = bx + building.width - 80;
            const signY = by + 20;

            // Neon glow
            ctx.shadowColor = building.neonColor;
            ctx.shadowBlur = 20;

            ctx.strokeStyle = building.neonColor;
            ctx.lineWidth = 3;
            ctx.font = 'bold 16px Bebas Neue';
            ctx.textAlign = 'center';

            // Flicker effect
            const flicker = Math.random() > 0.95 ? 0.5 : 1;
            ctx.globalAlpha = flicker;

            ctx.fillStyle = building.neonColor;
            ctx.fillText(building.neonText, signX + 30, signY + 15);

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawTheaterMarquee(building, bx, by) {
            const marqueeWidth = building.width - 40;
            const marqueeHeight = 100;
            const marqueeX = bx + 20;
            const marqueeY = by - 75;

            // Marquee frame (art deco style)
            ctx.fillStyle = '#c4a35a'; // Gold frame
            ctx.fillRect(marqueeX - 5, marqueeY - 5, marqueeWidth + 10, marqueeHeight + 10);

            // Inner marquee (black letterboard)
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(marqueeX, marqueeY, marqueeWidth, marqueeHeight);

            // Letterboard grooves (horizontal lines)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let row = 0; row < 6; row++) {
                const y = marqueeY + 12 + row * 15;
                ctx.beginPath();
                ctx.moveTo(marqueeX + 5, y);
                ctx.lineTo(marqueeX + marqueeWidth - 5, y);
                ctx.stroke();
            }

            // Border lights (chase lights effect)
            const time = Date.now() / 200;
            ctx.fillStyle = COLORS.windowLit;
            const bulbSpacing = 12;
            // Top row
            for (let i = 0; i < marqueeWidth / bulbSpacing; i++) {
                const flicker = ((i + Math.floor(time)) % 3 === 0) ? 1 : 0.3;
                ctx.globalAlpha = flicker;
                ctx.shadowColor = COLORS.windowLit;
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(marqueeX + 6 + i * bulbSpacing, marqueeY - 2, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            // Bottom row
            for (let i = 0; i < marqueeWidth / bulbSpacing; i++) {
                const flicker = ((i + Math.floor(time) + 1) % 3 === 0) ? 1 : 0.3;
                ctx.globalAlpha = flicker;
                ctx.beginPath();
                ctx.arc(marqueeX + 6 + i * bulbSpacing, marqueeY + marqueeHeight + 2, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            // Left side
            for (let i = 0; i < marqueeHeight / bulbSpacing; i++) {
                const flicker = ((i + Math.floor(time) + 2) % 3 === 0) ? 1 : 0.3;
                ctx.globalAlpha = flicker;
                ctx.beginPath();
                ctx.arc(marqueeX - 2, marqueeY + 6 + i * bulbSpacing, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            // Right side
            for (let i = 0; i < marqueeHeight / bulbSpacing; i++) {
                const flicker = ((i + Math.floor(time)) % 3 === 0) ? 1 : 0.3;
                ctx.globalAlpha = flicker;
                ctx.beginPath();
                ctx.arc(marqueeX + marqueeWidth + 2, marqueeY + 6 + i * bulbSpacing, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Theater name at top - individual plastic letters
            ctx.fillStyle = '#ff2222';
            ctx.font = 'bold 16px Bebas Neue';
            ctx.textAlign = 'center';
            const theaterName = 'PARAMOUNT';
            const letterSpacing = 18;
            const nameStartX = marqueeX + marqueeWidth / 2 - (theaterName.length * letterSpacing) / 2;
            for (let i = 0; i < theaterName.length; i++) {
                // Letter shadow (3D effect)
                ctx.fillStyle = '#550000';
                ctx.fillText(theaterName[i], nameStartX + i * letterSpacing + 2, marqueeY + 18);
                // Letter
                ctx.fillStyle = '#ff3333';
                ctx.fillText(theaterName[i], nameStartX + i * letterSpacing, marqueeY + 16);
            }

            // "NOW SHOWING" - smaller letters
            ctx.font = 'bold 9px Bebas Neue';
            ctx.fillStyle = '#ffcc00';
            ctx.fillText('NOW SHOWING', marqueeX + marqueeWidth / 2, marqueeY + 30);

            // Movie titles with times - individual letter style
            ctx.font = 'bold 11px Bebas Neue';
            if (building.nowPlaying && building.nowPlaying.length > 0) {
                building.nowPlaying.forEach((movie, i) => {
                    const movieY = marqueeY + 48 + i * 24;

                    // Movie title in white
                    ctx.fillStyle = '#ffffff';
                    const title = movie.title || movie;
                    ctx.fillText(title, marqueeX + marqueeWidth / 2, movieY);

                    // Show times in yellow below
                    if (movie.times) {
                        ctx.fillStyle = '#ffcc00';
                        ctx.font = 'bold 9px Bebas Neue';
                        ctx.fillText(movie.times, marqueeX + marqueeWidth / 2, movieY + 11);
                        ctx.font = 'bold 11px Bebas Neue';
                    }
                });
            }

            // Box office window below marquee
            const boxOfficeX = bx + building.width / 2 - 30;
            const boxOfficeY = by + 30;

            // Box office booth
            ctx.fillStyle = '#c4a35a';
            ctx.fillRect(boxOfficeX - 5, boxOfficeY - 5, 70, 55);
            ctx.fillStyle = '#2a2a35';
            ctx.fillRect(boxOfficeX, boxOfficeY, 60, 45);

            // Glass window
            ctx.fillStyle = 'rgba(200, 220, 255, 0.3)';
            ctx.fillRect(boxOfficeX + 5, boxOfficeY + 5, 50, 25);

            // "TICKETS" sign
            ctx.fillStyle = '#ff3333';
            ctx.font = 'bold 8px Bebas Neue';
            ctx.fillText('TICKETS', boxOfficeX + 30, boxOfficeY + 42);

            // Ticket booth attendant silhouette
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(boxOfficeX + 30, boxOfficeY + 18, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw alleys between buildings
        function drawAlleys() {
            if (!currentMap.alleys) return;

            const groundLevel = 410;

            for (const alley of currentMap.alleys) {
                const ax = alley.x - camera.x;

                // Skip if off screen
                if (ax + alley.width < -10 || ax > CONFIG.CANVAS_WIDTH + 10) continue;

                // Dark alley background
                ctx.fillStyle = '#0a0808';
                ctx.fillRect(ax, groundLevel - 300, alley.width, 320);

                // Depth gradient (darker in center)
                const alleyGradient = ctx.createLinearGradient(ax, 0, ax + alley.width, 0);
                alleyGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
                alleyGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.7)');
                alleyGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = alleyGradient;
                ctx.fillRect(ax, groundLevel - 300, alley.width, 320);

                // Pipes on alley walls
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(ax + 3, groundLevel - 200, 4, 180);
                ctx.fillRect(ax + alley.width - 7, groundLevel - 250, 4, 230);

                // Dumpster in some alleys
                if (alley.width > 40) {
                    ctx.fillStyle = '#1a2a1a';
                    ctx.fillRect(ax + alley.width / 2 - 12, groundLevel - 35, 24, 30);
                    ctx.fillStyle = '#0a1a0a';
                    ctx.fillRect(ax + alley.width / 2 - 10, groundLevel - 32, 20, 5);
                }

                // Ground debris/shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(ax, groundLevel - 20, alley.width, 25);
            }
        }

        // Pharmacy-specific rendering
        function drawPharmacyDetails(building, bx, by) {
            const groundLevel = 410;

            // Large RX Sign on facade
            const rxX = bx + building.width / 2;
            const rxY = by + 35;

            // RX sign background (pharmacy green)
            ctx.fillStyle = '#1a5c1a';
            ctx.beginPath();
            ctx.ellipse(rxX, rxY, 35, 35, 0, 0, Math.PI * 2);
            ctx.fill();

            // RX sign border
            ctx.strokeStyle = '#e8e8e0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(rxX, rxY, 35, 35, 0, 0, Math.PI * 2);
            ctx.stroke();

            // RX text
            ctx.fillStyle = '#e8e8e0';
            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Rx', rxX, rxY + 2);

            // Mortar and pestle icon below RX
            const mortarX = rxX;
            const mortarY = rxY + 55;

            // Mortar bowl
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.moveTo(mortarX - 15, mortarY);
            ctx.quadraticCurveTo(mortarX - 18, mortarY + 15, mortarX - 10, mortarY + 18);
            ctx.lineTo(mortarX + 10, mortarY + 18);
            ctx.quadraticCurveTo(mortarX + 18, mortarY + 15, mortarX + 15, mortarY);
            ctx.closePath();
            ctx.fill();

            // Pestle
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.moveTo(mortarX - 3, mortarY - 5);
            ctx.lineTo(mortarX + 12, mortarY - 20);
            ctx.lineTo(mortarX + 15, mortarY - 17);
            ctx.lineTo(mortarX + 3, mortarY);
            ctx.closePath();
            ctx.fill();

            // Store window display with pill bottles
            const windowY = by + building.height * 0.45;
            const windowHeight = 50;

            // Display window background
            ctx.fillStyle = 'rgba(255, 250, 240, 0.9)';
            ctx.fillRect(bx + 20, windowY, building.width - 40, windowHeight);

            // Pill bottles in window
            const bottleColors = ['#ff6b6b', '#4dabf7', '#69db7c', '#ffd43b', '#cc5de8'];
            const bottleWidth = 16;
            const bottleSpacing = 30;
            const numBottles = Math.floor((building.width - 60) / bottleSpacing);

            for (let i = 0; i < numBottles; i++) {
                const bottleX = bx + 35 + i * bottleSpacing;
                const bottleY = windowY + windowHeight - 35;
                const color = bottleColors[i % bottleColors.length];

                // Bottle body
                ctx.fillStyle = color;
                ctx.fillRect(bottleX, bottleY, bottleWidth, 28);

                // Bottle cap
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(bottleX + 2, bottleY - 5, bottleWidth - 4, 7);

                // Label
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(bottleX + 2, bottleY + 8, bottleWidth - 4, 12);
            }

            // "PRESCRIPTIONS" text on window
            ctx.fillStyle = '#1a5c1a';
            ctx.font = 'bold 10px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('PRESCRIPTIONS', bx + building.width / 2, windowY + 12);

            // Additional signage - "DRUGS • SUNDRIES"
            ctx.fillStyle = '#1a5c1a';
            ctx.font = 'bold 8px Bebas Neue';
            ctx.fillText('DRUGS • SUNDRIES • FOUNTAIN', bx + building.width / 2, by + building.height * 0.35);
        }

        // Cafe/Diner specific rendering
        function drawCafeDetails(building, bx, by) {
            const groundLevel = 410;

            // Chrome diner trim
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(bx + 5, by + building.height * 0.5, building.width - 10, 4);
            ctx.fillRect(bx + 5, by + building.height * 0.7, building.width - 10, 4);

            // Large window with counter visible
            const windowY = by + building.height * 0.52;
            const windowHeight = 45;

            // Window
            ctx.fillStyle = 'rgba(255, 240, 220, 0.8)';
            ctx.fillRect(bx + 15, windowY, building.width - 30, windowHeight);

            // Counter inside
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(bx + 18, windowY + windowHeight - 12, building.width - 36, 10);

            // Stools (silhouettes)
            ctx.fillStyle = '#c41e3a';
            for (let i = 0; i < 4; i++) {
                const stoolX = bx + 35 + i * 45;
                // Stool seat
                ctx.beginPath();
                ctx.ellipse(stoolX, windowY + windowHeight - 8, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                // Stool pole
                ctx.fillRect(stoolX - 2, windowY + windowHeight - 5, 4, 8);
            }

            // "OPEN 24 HOURS" sign
            ctx.fillStyle = '#ffcc00';
            ctx.font = 'bold 9px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('OPEN 24 HOURS', bx + building.width / 2, by + 25);

            // Coffee cup icon
            const cupX = bx + building.width - 40;
            const cupY = by + 35;
            ctx.fillStyle = '#f0f0e8';
            ctx.beginPath();
            ctx.moveTo(cupX, cupY);
            ctx.lineTo(cupX + 20, cupY);
            ctx.lineTo(cupX + 17, cupY + 18);
            ctx.lineTo(cupX + 3, cupY + 18);
            ctx.closePath();
            ctx.fill();
            // Steam
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(cupX + 5 + i * 5, cupY - 2);
                ctx.quadraticCurveTo(cupX + 7 + i * 5, cupY - 8, cupX + 5 + i * 5, cupY - 12);
                ctx.stroke();
            }
        }

        // Bar specific rendering
        function drawBarDetails(building, bx, by) {
            // Neon blue accent lines
            ctx.shadowColor = '#4488ff';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2;

            // Art deco lines
            ctx.beginPath();
            ctx.moveTo(bx + 20, by + 30);
            ctx.lineTo(bx + building.width - 20, by + 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(bx + 20, by + 40);
            ctx.lineTo(bx + building.width - 20, by + 40);
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Frosted windows (you can't see inside)
            const windowY = by + building.height * 0.5;
            ctx.fillStyle = 'rgba(50, 50, 80, 0.7)';
            ctx.fillRect(bx + 15, windowY, building.width - 30, 40);

            // Window frost pattern
            ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
            for (let i = 0; i < 8; i++) {
                ctx.fillRect(bx + 20 + i * 24, windowY + 5, 18, 30);
            }

            // Martini glass icon
            const glassX = bx + 30;
            const glassY = by + 55;
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(glassX, glassY);
            ctx.lineTo(glassX + 20, glassY);
            ctx.lineTo(glassX + 10, glassY + 15);
            ctx.lineTo(glassX + 10, glassY + 25);
            ctx.moveTo(glassX + 5, glassY + 25);
            ctx.lineTo(glassX + 15, glassY + 25);
            ctx.stroke();

            // Olive
            ctx.fillStyle = '#69db7c';
            ctx.beginPath();
            ctx.ellipse(glassX + 10, glassY + 5, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Bookstore specific rendering
        function drawBookstoreDetails(building, bx, by) {
            // Warm light from window
            const windowY = by + building.height * 0.45;
            const windowHeight = 50;

            // Bay window effect
            ctx.fillStyle = 'rgba(255, 240, 200, 0.9)';
            ctx.fillRect(bx + 15, windowY, building.width - 30, windowHeight);

            // Books in window display
            const bookColors = ['#8b0000', '#00008b', '#006400', '#4a0080', '#8b4513'];
            for (let row = 0; row < 2; row++) {
                for (let i = 0; i < 7; i++) {
                    const bookX = bx + 22 + i * 22;
                    const bookY = windowY + 10 + row * 22;
                    const bookHeight = 15 + (i % 3) * 3;
                    const color = bookColors[(i + row) % bookColors.length];

                    ctx.fillStyle = color;
                    ctx.fillRect(bookX, bookY + (18 - bookHeight), 18, bookHeight);

                    // Book spine detail
                    ctx.fillStyle = adjustBrightness(color, 0.7);
                    ctx.fillRect(bookX, bookY + (18 - bookHeight), 3, bookHeight);
                }
            }

            // "BOOKS" painted on window
            ctx.fillStyle = '#c4a35a';
            ctx.font = 'bold 14px serif';
            ctx.textAlign = 'center';
            ctx.fillText('BOOKS', bx + building.width / 2, windowY + windowHeight - 8);

            // Open book icon above door
            const bookIconX = bx + building.width / 2;
            const bookIconY = by + 30;
            ctx.fillStyle = '#c4a35a';
            // Left page
            ctx.beginPath();
            ctx.moveTo(bookIconX, bookIconY);
            ctx.lineTo(bookIconX - 15, bookIconY + 3);
            ctx.lineTo(bookIconX - 15, bookIconY + 18);
            ctx.lineTo(bookIconX, bookIconY + 15);
            ctx.closePath();
            ctx.fill();
            // Right page
            ctx.beginPath();
            ctx.moveTo(bookIconX, bookIconY);
            ctx.lineTo(bookIconX + 15, bookIconY + 3);
            ctx.lineTo(bookIconX + 15, bookIconY + 18);
            ctx.lineTo(bookIconX, bookIconY + 15);
            ctx.closePath();
            ctx.fill();
        }

        // Police station specific rendering
        function drawPoliceDetails(building, bx, by) {
            // American flag
            const flagX = bx + building.width - 30;
            const flagY = by - 30;

            // Flag pole
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(flagX + 18, flagY, 3, 60);

            // Flag
            ctx.fillStyle = '#b22234'; // Red
            ctx.fillRect(flagX, flagY + 5, 20, 12);
            // Stripes
            for (let i = 0; i < 6; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#b22234';
                ctx.fillRect(flagX, flagY + 5 + i * 2, 20, 2);
            }
            // Blue canton
            ctx.fillStyle = '#3c3b6e';
            ctx.fillRect(flagX, flagY + 5, 8, 6);

            // Police badge emblem
            const badgeX = bx + building.width / 2;
            const badgeY = by + 50;

            // Shield shape
            ctx.fillStyle = '#c4a35a';
            ctx.beginPath();
            ctx.moveTo(badgeX, badgeY - 20);
            ctx.lineTo(badgeX + 20, badgeY - 10);
            ctx.lineTo(badgeX + 20, badgeY + 10);
            ctx.lineTo(badgeX, badgeY + 25);
            ctx.lineTo(badgeX - 20, badgeY + 10);
            ctx.lineTo(badgeX - 20, badgeY - 10);
            ctx.closePath();
            ctx.fill();

            // Inner shield
            ctx.fillStyle = '#1a1a3a';
            ctx.beginPath();
            ctx.moveTo(badgeX, badgeY - 15);
            ctx.lineTo(badgeX + 15, badgeY - 7);
            ctx.lineTo(badgeX + 15, badgeY + 7);
            ctx.lineTo(badgeX, badgeY + 18);
            ctx.lineTo(badgeX - 15, badgeY + 7);
            ctx.lineTo(badgeX - 15, badgeY - 7);
            ctx.closePath();
            ctx.fill();

            // Star
            ctx.fillStyle = '#c4a35a';
            ctx.font = 'bold 16px serif';
            ctx.textAlign = 'center';
            ctx.fillText('★', badgeX, badgeY + 5);

            // "POLICE DEPT" text
            ctx.fillStyle = '#c4a35a';
            ctx.font = 'bold 10px Bebas Neue';
            ctx.fillText('POLICE DEPT', badgeX, badgeY + 40);
        }

        // Apartment building specific rendering
        function drawApartmentDetails(building, bx, by) {
            // Fire escape
            const escapeX = bx + building.width - 25;
            ctx.fillStyle = '#1a1a1a';

            // Vertical rails
            ctx.fillRect(escapeX, by + 30, 3, building.height - 50);
            ctx.fillRect(escapeX + 20, by + 30, 3, building.height - 50);

            // Horizontal platforms
            const floorHeight = building.height / building.floors;
            for (let floor = 0; floor < building.floors; floor++) {
                const platformY = by + 50 + floor * floorHeight;
                ctx.fillRect(escapeX - 5, platformY, 30, 3);
                // Railings
                ctx.fillRect(escapeX - 5, platformY - 15, 2, 15);
                ctx.fillRect(escapeX + 23, platformY - 15, 2, 15);
            }

            // Ladder sections
            for (let floor = 0; floor < building.floors - 1; floor++) {
                const ladderY = by + 55 + floor * floorHeight;
                for (let rung = 0; rung < 4; rung++) {
                    ctx.fillRect(escapeX + 3, ladderY + rung * 15, 14, 2);
                }
            }

            // Building number
            ctx.fillStyle = '#c4a35a';
            ctx.font = 'bold 24px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('247', bx + 40, by + 50);

            // Mailboxes near entrance
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(bx + 15, by + building.height - 80, 30, 40);
            // Individual mailbox slots
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(bx + 18, by + building.height - 75 + i * 12, 24, 8);
            }
        }

        function drawStreetLight(light) {
            const lx = light.x - camera.x;
            const baseY = GROUND_LEVEL + 50; // Street lights sit on sidewalk
            const poleHeight = 180; // Tall realistic street lamp

            if (lx < -50 || lx > CONFIG.CANVAS_WIDTH + 50) return;

            // Pole base (concrete pedestal)
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(lx - 10, baseY - 12, 20, 14);
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(lx - 8, baseY - 20, 16, 10);

            // Main pole (cast iron style - tapered)
            ctx.fillStyle = '#1a1a1a';
            // Lower section (thicker)
            ctx.beginPath();
            ctx.moveTo(lx - 5, baseY - 20);
            ctx.lineTo(lx + 5, baseY - 20);
            ctx.lineTo(lx + 4, baseY - 80);
            ctx.lineTo(lx - 4, baseY - 80);
            ctx.closePath();
            ctx.fill();
            // Upper section (thinner)
            ctx.beginPath();
            ctx.moveTo(lx - 4, baseY - 80);
            ctx.lineTo(lx + 4, baseY - 80);
            ctx.lineTo(lx + 3, baseY - poleHeight);
            ctx.lineTo(lx - 3, baseY - poleHeight);
            ctx.closePath();
            ctx.fill();

            // Decorative rings on pole
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(lx - 6, baseY - 40, 12, 5);
            ctx.fillRect(lx - 5, baseY - 80, 10, 5);
            ctx.fillRect(lx - 5, baseY - 120, 10, 4);

            // Ornate lamp arm (curved bracket with scrollwork)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(lx, baseY - poleHeight);
            ctx.quadraticCurveTo(lx + 35, baseY - poleHeight - 15, lx + 45, baseY - poleHeight + 10);
            ctx.stroke();
            // Decorative curl
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(lx + 15, baseY - poleHeight - 5);
            ctx.quadraticCurveTo(lx + 20, baseY - poleHeight + 10, lx + 10, baseY - poleHeight + 5);
            ctx.stroke();

            // Lamp housing (ornate lantern style)
            const lampX = lx + 45;
            const lampY = baseY - poleHeight + 15;

            // Lantern top cap
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(lampX - 12, lampY - 5);
            ctx.lineTo(lampX, lampY - 15);
            ctx.lineTo(lampX + 12, lampY - 5);
            ctx.closePath();
            ctx.fill();

            // Lantern body frame
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(lampX - 14, lampY - 5, 28, 30);

            // Glass panels (glowing)
            ctx.fillStyle = COLORS.streetLight;
            ctx.shadowColor = COLORS.streetLight;
            ctx.shadowBlur = 15;
            ctx.fillRect(lampX - 11, lampY - 2, 22, 24);
            ctx.shadowBlur = 0;

            // Lantern frame bars
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(lampX - 1, lampY - 5, 2, 30);
            ctx.fillRect(lampX - 14, lampY + 8, 28, 2);

            // Bottom finial
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(lampX - 8, lampY + 25);
            ctx.lineTo(lampX + 8, lampY + 25);
            ctx.lineTo(lampX, lampY + 35);
            ctx.closePath();
            ctx.fill();

            // Light glow on ground
            const gradient = ctx.createRadialGradient(lampX, baseY + 30, 0, lampX, baseY + 30, 120);
            gradient.addColorStop(0, 'rgba(255, 237, 200, 0.4)');
            gradient.addColorStop(0.4, 'rgba(255, 237, 200, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 237, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(lampX, baseY + 30, 120, 60, 0, 0, Math.PI * 2);
            ctx.fill();

            // Light cone effect
            ctx.fillStyle = 'rgba(255, 237, 200, 0.06)';
            ctx.beginPath();
            ctx.moveTo(lampX - 14, lampY + 25);
            ctx.lineTo(lampX - 80, baseY + 60);
            ctx.lineTo(lampX + 80, baseY + 60);
            ctx.lineTo(lampX + 14, lampY + 25);
            ctx.closePath();
            ctx.fill();
        }

        function drawCar(car) {
            const cx = car.x - camera.x;
            const streetSurface = GROUND_LEVEL + 58 + 85; // Middle of street

            if (cx < -100 || cx > CONFIG.CANVAS_WIDTH + 100) return;

            // Car shadow on street
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(cx + 55, streetSurface + 18, 58, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Car body (1950s style - larger, more detailed)
            const carY = streetSurface - 15;

            // Darker undercarriage
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(cx + 8, carY + 25, 94, 8);

            // Main body color
            ctx.fillStyle = car.color;

            // Lower body (fenders, doors)
            ctx.beginPath();
            ctx.moveTo(cx, carY + 18);
            ctx.lineTo(cx + 8, carY + 28);
            ctx.lineTo(cx + 102, carY + 28);
            ctx.lineTo(cx + 110, carY + 18);
            ctx.lineTo(cx + 108, carY + 8);
            ctx.lineTo(cx + 2, carY + 8);
            ctx.closePath();
            ctx.fill();

            // Body highlight
            ctx.fillStyle = adjustBrightness(car.color, 1.2);
            ctx.fillRect(cx + 5, carY + 10, 100, 3);

            // Roof
            ctx.fillStyle = car.color;
            ctx.beginPath();
            ctx.moveTo(cx + 22, carY + 8);
            ctx.lineTo(cx + 28, carY - 12);
            ctx.lineTo(cx + 82, carY - 12);
            ctx.lineTo(cx + 88, carY + 8);
            ctx.closePath();
            ctx.fill();

            // Roof highlight
            ctx.fillStyle = adjustBrightness(car.color, 1.3);
            ctx.beginPath();
            ctx.moveTo(cx + 30, carY - 10);
            ctx.lineTo(cx + 80, carY - 10);
            ctx.lineTo(cx + 78, carY - 8);
            ctx.lineTo(cx + 32, carY - 8);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = 'rgba(80, 100, 120, 0.8)';
            // Front window
            ctx.beginPath();
            ctx.moveTo(cx + 30, carY + 6);
            ctx.lineTo(cx + 34, carY - 8);
            ctx.lineTo(cx + 52, carY - 8);
            ctx.lineTo(cx + 52, carY + 6);
            ctx.closePath();
            ctx.fill();
            // Rear window
            ctx.beginPath();
            ctx.moveTo(cx + 58, carY + 6);
            ctx.lineTo(cx + 58, carY - 8);
            ctx.lineTo(cx + 76, carY - 8);
            ctx.lineTo(cx + 80, carY + 6);
            ctx.closePath();
            ctx.fill();

            // Window frames
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 55, carY + 6);
            ctx.lineTo(cx + 55, carY - 8);
            ctx.stroke();

            // Chrome trim
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 3, carY + 18);
            ctx.lineTo(cx + 107, carY + 18);
            ctx.stroke();

            // Chrome bumpers
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(cx - 2, carY + 20, 8, 6);
            ctx.fillRect(cx + 104, carY + 20, 8, 6);

            // Wheels with whitewalls
            // Front wheel
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e8e8e0';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 7, 0, Math.PI * 2);
            ctx.fill();
            // Hubcap
            ctx.fillStyle = '#909090';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 5, 0, Math.PI * 2);
            ctx.fill();

            // Rear wheel
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e8e8e0';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#909090';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 5, 0, Math.PI * 2);
            ctx.fill();

            // Headlights
            ctx.fillStyle = '#ffffee';
            ctx.shadowColor = '#ffffcc';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(cx + 105, carY + 12, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 105, carY + 20, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Taillights
            ctx.fillStyle = '#cc2020';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(cx + 5, carY + 14, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // License plate
            ctx.fillStyle = '#f0f0e0';
            ctx.fillRect(cx + 48, carY + 24, 14, 6);
            ctx.fillStyle = '#1a1a1a';
            ctx.font = '4px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('1959', cx + 55, carY + 29);
        }

        // ============================================
        // MANNEQUIN-STYLE CHARACTER RENDERING
        // Angular, art deco influenced, elongated proportions
        // ============================================

        function drawMannequin(x, y, options = {}) {
            const {
                facing = 1,
                isMoving = false,
                walkCycle = 0,
                hatType = 'fedora',
                lightFactor = 1,
                isPlayer = false,
                appearance = null,
                outfit = 'detective'
            } = options;

            const app = appearance || { skin: '#d4a87a', gender: 'm' };

            // Human proportions - proper figure (about 70px tall)
            const totalHeight = 70;
            const headHeight = 12;
            const neckHeight = 4;
            const torsoHeight = 22;
            const legHeight = 32;
            const shoulderWidth = 18;
            const hipWidth = 14;
            const headWidth = 10;

            // Calculate body part positions from feet up
            const feetY = y;
            const kneeY = feetY - legHeight * 0.45;
            const hipY = feetY - legHeight;
            const waistY = hipY - torsoHeight * 0.4;
            const chestY = hipY - torsoHeight * 0.7;
            const shoulderY = hipY - torsoHeight;
            const neckY = shoulderY - neckHeight;
            const chinY = neckY - 2;
            const headTopY = chinY - headHeight;

            // Walking animation
            const walkPhase = walkCycle * 0.15;
            const legSwing = isMoving ? Math.sin(walkPhase) * 8 : 0;
            const armSwing = isMoving ? Math.sin(walkPhase) * 6 : 0;
            const bodyBob = isMoving ? Math.abs(Math.sin(walkPhase * 2)) * 2 : 0;

            // Outfit colors
            let coatColor, pantsColor, shirtColor, tieColor;
            if (isPlayer) {
                coatColor = '#5a4a38'; // Brown trench coat
                pantsColor = '#2a2a35'; // Dark pants
                shirtColor = '#d8d0c0'; // Light shirt
                tieColor = '#4a2a2a';
            } else if (outfit === 'dress') {
                coatColor = '#8b3a4a'; // Burgundy dress
                pantsColor = '#8b3a4a';
                shirtColor = app.skin;
                tieColor = null;
            } else if (outfit === 'suit') {
                coatColor = '#3a3a45'; // Dark suit
                pantsColor = '#2a2a35';
                shirtColor = '#c8c8d0';
                tieColor = '#3a2a4a';
            } else {
                coatColor = '#4a4a55'; // Gray coat
                pantsColor = '#3a3a45';
                shirtColor = '#b8b8c0';
                tieColor = '#2a3a4a';
            }

            ctx.save();
            ctx.translate(x, -bodyBob);
            if (facing === -1) {
                ctx.scale(-1, 1);
                ctx.translate(-x * 2, 0);
            }

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x, feetY + 2, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // === LEGS ===
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';

            // Left leg
            ctx.strokeStyle = adjustBrightness(pantsColor, lightFactor);
            ctx.beginPath();
            ctx.moveTo(x - 5, hipY);
            ctx.quadraticCurveTo(x - 5 - legSwing * 0.3, kneeY, x - 4 + legSwing, feetY - 3);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(x + 5, hipY);
            ctx.quadraticCurveTo(x + 5 + legSwing * 0.3, kneeY, x + 4 - legSwing, feetY - 3);
            ctx.stroke();

            // Shoes
            ctx.fillStyle = adjustBrightness('#1a1a1a', lightFactor);
            ctx.beginPath();
            ctx.ellipse(x - 4 + legSwing, feetY - 2, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 4 - legSwing, feetY - 2, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // === TORSO ===
            // Main body shape
            ctx.fillStyle = adjustBrightness(coatColor, lightFactor);
            ctx.beginPath();
            ctx.moveTo(x - shoulderWidth/2, shoulderY);
            ctx.lineTo(x + shoulderWidth/2, shoulderY);
            ctx.lineTo(x + hipWidth/2 + 2, hipY);
            ctx.lineTo(x - hipWidth/2 - 2, hipY);
            ctx.closePath();
            ctx.fill();

            // Jacket lapels / dress neckline
            if (outfit !== 'dress') {
                ctx.fillStyle = adjustBrightness(shirtColor, lightFactor);
                ctx.beginPath();
                ctx.moveTo(x - 6, shoulderY + 2);
                ctx.lineTo(x, chestY + 5);
                ctx.lineTo(x + 6, shoulderY + 2);
                ctx.lineTo(x + 4, shoulderY + 4);
                ctx.lineTo(x, chestY + 8);
                ctx.lineTo(x - 4, shoulderY + 4);
                ctx.closePath();
                ctx.fill();

                // Tie
                if (tieColor) {
                    ctx.fillStyle = adjustBrightness(tieColor, lightFactor);
                    ctx.beginPath();
                    ctx.moveTo(x - 2, shoulderY + 5);
                    ctx.lineTo(x + 2, shoulderY + 5);
                    ctx.lineTo(x + 3, hipY - 5);
                    ctx.lineTo(x, hipY);
                    ctx.lineTo(x - 3, hipY - 5);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Coat buttons
            ctx.fillStyle = adjustBrightness('#2a2520', lightFactor);
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x + 5, shoulderY + 10 + i * 8, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // === ARMS ===
            ctx.lineWidth = 5;
            ctx.strokeStyle = adjustBrightness(coatColor, lightFactor);

            // Left arm
            ctx.beginPath();
            ctx.moveTo(x - shoulderWidth/2, shoulderY + 2);
            ctx.quadraticCurveTo(x - shoulderWidth/2 - 3 + armSwing, waistY, x - shoulderWidth/2 - 2 + armSwing * 1.5, hipY + 5);
            ctx.stroke();

            // Right arm
            ctx.beginPath();
            ctx.moveTo(x + shoulderWidth/2, shoulderY + 2);
            ctx.quadraticCurveTo(x + shoulderWidth/2 + 3 - armSwing, waistY, x + shoulderWidth/2 + 2 - armSwing * 1.5, hipY + 5);
            ctx.stroke();

            // Hands
            ctx.fillStyle = adjustBrightness(app.skin, lightFactor);
            ctx.beginPath();
            ctx.arc(x - shoulderWidth/2 - 2 + armSwing * 1.5, hipY + 7, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + shoulderWidth/2 + 2 - armSwing * 1.5, hipY + 7, 3, 0, Math.PI * 2);
            ctx.fill();

            // === NECK ===
            ctx.fillStyle = adjustBrightness(app.skin, lightFactor);
            ctx.fillRect(x - 3, neckY, 6, neckHeight + 2);

            // === HEAD ===
            // Face shape - more rectangular/angular for noir style
            ctx.fillStyle = adjustBrightness(app.skin, lightFactor);
            ctx.beginPath();
            ctx.moveTo(x - headWidth/2, chinY);
            ctx.lineTo(x - headWidth/2 - 1, chinY - headHeight * 0.4);
            ctx.quadraticCurveTo(x - headWidth/2 - 1, headTopY + 2, x, headTopY);
            ctx.quadraticCurveTo(x + headWidth/2 + 1, headTopY + 2, x + headWidth/2 + 1, chinY - headHeight * 0.4);
            ctx.lineTo(x + headWidth/2, chinY);
            ctx.quadraticCurveTo(x, chinY + 2, x - headWidth/2, chinY);
            ctx.fill();

            // Face details
            if (lightFactor > 0.3) {
                // Eyes
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(x - 4, chinY - headHeight * 0.55, 2, 2);
                ctx.fillRect(x + 2, chinY - headHeight * 0.55, 2, 2);

                // Eyebrows
                ctx.strokeStyle = adjustBrightness('#3a3020', lightFactor);
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x - 5, chinY - headHeight * 0.65);
                ctx.lineTo(x - 1, chinY - headHeight * 0.68);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + 1, chinY - headHeight * 0.68);
                ctx.lineTo(x + 5, chinY - headHeight * 0.65);
                ctx.stroke();

                // Nose - angular line
                ctx.strokeStyle = adjustBrightness('#8a7060', lightFactor * 0.6);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, chinY - headHeight * 0.5);
                ctx.lineTo(x + 1, chinY - headHeight * 0.3);
                ctx.lineTo(x - 1, chinY - headHeight * 0.25);
                ctx.stroke();

                // Mouth
                ctx.strokeStyle = adjustBrightness('#6a4a3a', lightFactor);
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x - 3, chinY - headHeight * 0.12);
                ctx.lineTo(x + 3, chinY - headHeight * 0.12);
                ctx.stroke();

                // Jaw shadow for definition
                ctx.strokeStyle = adjustBrightness('#8a7a6a', lightFactor * 0.4);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - headWidth/2 + 1, chinY - 2);
                ctx.lineTo(x + headWidth/2 - 1, chinY - 2);
                ctx.stroke();
            }

            // === HAIR ===
            const hairColor = app.hairColor || '#2a2018';
            if (hatType === 'none') {
                ctx.fillStyle = adjustBrightness(hairColor, lightFactor);
                if (app.gender === 'f') {
                    // Women's hair - wavy sides
                    ctx.beginPath();
                    ctx.moveTo(x - headWidth/2 - 2, headTopY + 3);
                    ctx.quadraticCurveTo(x, headTopY - 2, x + headWidth/2 + 2, headTopY + 3);
                    ctx.lineTo(x + headWidth/2 + 3, chinY - 5);
                    ctx.lineTo(x + headWidth/2 + 4, chinY + 10);
                    ctx.lineTo(x + headWidth/2, chinY + 5);
                    ctx.lineTo(x - headWidth/2, chinY + 5);
                    ctx.lineTo(x - headWidth/2 - 4, chinY + 10);
                    ctx.lineTo(x - headWidth/2 - 3, chinY - 5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Men's hair - short on top
                    ctx.beginPath();
                    ctx.moveTo(x - headWidth/2, headTopY + 4);
                    ctx.quadraticCurveTo(x, headTopY - 1, x + headWidth/2, headTopY + 4);
                    ctx.lineTo(x + headWidth/2 - 1, chinY - headHeight * 0.7);
                    ctx.lineTo(x - headWidth/2 + 1, chinY - headHeight * 0.7);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // === FEDORA HAT ===
            if (hatType === 'fedora') {
                const hatColor = '#2a2520';
                ctx.fillStyle = adjustBrightness(hatColor, lightFactor);

                // Hat brim - flat rectangular shape
                ctx.beginPath();
                ctx.moveTo(x - headWidth - 6, headTopY + 4);
                ctx.lineTo(x + headWidth + 6, headTopY + 4);
                ctx.lineTo(x + headWidth + 4, headTopY + 7);
                ctx.lineTo(x - headWidth - 4, headTopY + 7);
                ctx.closePath();
                ctx.fill();

                // Hat crown - trapezoidal shape
                ctx.beginPath();
                ctx.moveTo(x - headWidth/2 - 2, headTopY + 4);
                ctx.lineTo(x - headWidth/2, headTopY - 8);
                ctx.lineTo(x - 2, headTopY - 12);
                ctx.lineTo(x + 2, headTopY - 12);
                ctx.lineTo(x + headWidth/2, headTopY - 8);
                ctx.lineTo(x + headWidth/2 + 2, headTopY + 4);
                ctx.closePath();
                ctx.fill();

                // Crease in crown
                ctx.strokeStyle = adjustBrightness('#1a1a1a', lightFactor * 0.5);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 2, headTopY - 11);
                ctx.lineTo(x, headTopY - 6);
                ctx.lineTo(x + 2, headTopY - 11);
                ctx.stroke();

                // Hat band
                ctx.fillStyle = adjustBrightness('#4a4540', lightFactor);
                ctx.fillRect(x - headWidth/2, headTopY - 2, headWidth, 4);
            }

            ctx.restore();
        }

        function drawPlayer() {
            // Don't draw player when in car
            if (player.inCar) return;

            const px = player.x - camera.x + player.width / 2;
            const py = player.y - camera.y + player.height;

            const inLight = isInLight(player.x, player.y);
            const lightFactor = inLight ? 1 : 0.35;

            drawMannequin(px, py, {
                facing: player.facing,
                isMoving: player.isMoving,
                walkCycle: player.walkCycle,
                outfit: 'detective',
                hatType: 'fedora',
                lightFactor: lightFactor,
                isPlayer: true,
                appearance: player.appearance
            });
        }

        function isInLight(x, y) {
            // Check street lights (light falls slightly to the right due to arm)
            for (const light of currentMap.streetLights) {
                const lightX = light.x + 30; // Offset for lamp arm
                const lightY = GROUND_LEVEL + 30;
                const dist = Math.sqrt(Math.pow(x - lightX, 2) + Math.pow(y - lightY, 2));
                if (dist < 90) return true;
            }

            // Check building doors (have lights above them)
            for (const building of currentMap.buildings) {
                const doorX = building.x + building.width / 2;
                const doorY = GROUND_LEVEL - 40;
                const dist = Math.sqrt(Math.pow(x - doorX, 2) + Math.pow(y - doorY, 2));
                if (dist < 50) return true;
            }

            return false;
        }

        function adjustBrightness(color, factor) {
            // Simple brightness adjustment
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);

                const nr = Math.floor(r * factor);
                const ng = Math.floor(g * factor);
                const nb = Math.floor(b * factor);

                return `rgb(${nr}, ${ng}, ${nb})`;
            }
            return color;
        }

        function drawNPC(npc) {
            const state = worldState.npcStates[npc.id] || { x: npc.x, y: npc.y, facingRight: true };
            const nx = state.x - camera.x + 12;
            const ny = state.y - camera.y + 64;

            const inLight = isInLight(state.x, state.y);
            const lightFactor = inLight ? 1 : 0.3;

            // Determine outfit based on role
            let outfit = 'suit';
            let hatType = 'none';

            if (npc.role === 'bartender') { outfit = 'worker'; }
            else if (npc.role === 'cook') { outfit = 'worker'; }
            else if ((npc.role === 'owner' || npc.role === 'secretary' || npc.role === 'employee') &&
                     npc.appearance && npc.appearance.gender === 'f') {
                outfit = 'dress';
            }
            else if (npc.role === 'owner' || npc.role === 'pharmacist') { outfit = 'suit'; }
            else if (npc.role === 'patron') { outfit = 'casual'; hatType = 'fedora'; }
            else if (npc.role === 'police') { outfit = 'suit'; hatType = 'none'; }
            else if (npc.role === 'secretary') { outfit = 'dress'; }
            else if (npc.role === 'pedestrian') {
                // Pedestrians vary
                if (npc.appearance && npc.appearance.gender === 'f') {
                    outfit = 'dress';
                } else {
                    outfit = Math.random() > 0.5 ? 'suit' : 'casual';
                    hatType = Math.random() > 0.7 ? 'fedora' : 'none';
                }
            }

            drawMannequin(nx, ny, {
                facing: state.facingRight ? 1 : -1,
                isMoving: false,
                walkCycle: 0,
                outfit: outfit,
                hatType: hatType,
                lightFactor: lightFactor,
                isPlayer: false,
                appearance: npc.appearance
            });
        }

        // ============================================
        // STREET PROPS RENDERING
        // ============================================

        function drawStreetProps() {
            for (const prop of worldState.props) {
                const px = prop.x - camera.x;
                // Props have fixed Y positions (side-scroller - no camera.y offset)
                const py = prop.y;

                if (px < -50 || px > CONFIG.CANVAS_WIDTH + 50) continue;

                switch (prop.type) {
                    case 'phonebooth':
                        drawPhoneBooth(px, py);
                        break;
                    case 'bench':
                        drawBench(px, py);
                        break;
                    case 'trashcan':
                        drawTrashCan(px, py);
                        break;
                    case 'hydrant':
                        drawFireHydrant(px, py);
                        break;
                    case 'newsstand':
                        drawNewsstand(px, py);
                        break;
                    case 'mailbox':
                        drawMailbox(px, py);
                        break;
                    case 'streetsign':
                        drawStreetSign(px, py, prop.text);
                        break;
                }
            }
        }

        function drawPhoneBooth(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 58, 24, 6);

            // Booth frame
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x, y, 30, 60);

            // Glass panels
            ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
            ctx.fillRect(x + 3, y + 8, 24, 35);

            // Door frame
            ctx.strokeStyle = '#5a0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 3, y + 8, 24, 48);

            // Phone inside (silhouette)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 10, y + 18, 10, 15);

            // Light on top
            ctx.fillStyle = '#ffeecc';
            ctx.shadowColor = '#ffeecc';
            ctx.shadowBlur = 10;
            ctx.fillRect(x + 8, y - 5, 14, 5);
            ctx.shadowBlur = 0;
        }

        function drawBench(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 25, y + 22, 28, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x + 5, y + 8, 4, 14);
            ctx.fillRect(x + 41, y + 8, 4, 14);

            // Seat
            ctx.fillStyle = '#4a3a2a';
            ctx.fillRect(x, y, 50, 8);

            // Back rest
            ctx.fillRect(x, y - 15, 50, 6);
            ctx.fillRect(x + 2, y - 15, 3, 18);
            ctx.fillRect(x + 45, y - 15, 3, 18);
        }

        function drawTrashCan(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 25, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Can body
            ctx.fillStyle = '#3d3d3d';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 16, y);
            ctx.lineTo(x + 14, y + 24);
            ctx.lineTo(x + 2, y + 24);
            ctx.closePath();
            ctx.fill();

            // Rim
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(x - 1, y - 2, 18, 3);

            // Lines
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 5, y + 2);
            ctx.lineTo(x + 4, y + 22);
            ctx.moveTo(x + 11, y + 2);
            ctx.lineTo(x + 12, y + 22);
            ctx.stroke();
        }

        function drawFireHydrant(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 7, y + 22, 9, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Base
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x + 2, y + 15, 10, 7);

            // Body
            ctx.beginPath();
            ctx.moveTo(x + 1, y + 15);
            ctx.lineTo(x + 3, y + 4);
            ctx.lineTo(x + 11, y + 4);
            ctx.lineTo(x + 13, y + 15);
            ctx.closePath();
            ctx.fill();

            // Top
            ctx.fillRect(x + 4, y, 6, 4);
            ctx.fillRect(x + 5, y - 3, 4, 4);

            // Side nozzle
            ctx.fillRect(x + 12, y + 6, 5, 4);

            // Highlight
            ctx.fillStyle = '#aa2020';
            ctx.fillRect(x + 5, y + 5, 2, 8);
        }

        function drawNewsstand(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 32, 34, 6);

            // Stand body
            ctx.fillStyle = '#2a4a2a';
            ctx.fillRect(x, y, 40, 32);

            // Papers display
            ctx.fillStyle = '#e8e0d0';
            ctx.fillRect(x + 3, y + 3, 34, 20);

            // Headlines (abstract lines)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 5, y + 5, 20, 3);
            ctx.fillRect(x + 5, y + 10, 28, 2);
            ctx.fillRect(x + 5, y + 14, 25, 2);
            ctx.fillRect(x + 5, y + 18, 22, 2);

            // Coin slot area
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 15, y + 25, 10, 5);
        }

        function drawMailbox(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 35, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Post
            ctx.fillStyle = '#1a3a6a';
            ctx.fillRect(x + 5, y + 15, 6, 20);

            // Box body
            ctx.fillRect(x - 2, y, 20, 16);

            // Rounded top
            ctx.beginPath();
            ctx.arc(x + 8, y, 10, Math.PI, 0, false);
            ctx.fill();

            // Slot
            ctx.fillStyle = '#0a1a3a';
            ctx.fillRect(x + 2, y + 5, 12, 3);

            // USPS eagle (simplified)
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(x + 8, y - 4);
            ctx.lineTo(x + 12, y - 1);
            ctx.lineTo(x + 4, y - 1);
            ctx.closePath();
            ctx.fill();
        }

        function drawStreetSign(x, y, text) {
            // Pole
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(x + 12, y, 4, 50);

            // Sign
            ctx.fillStyle = '#1a5a1a';
            ctx.fillRect(x, y - 10, 60, 16);

            // Border
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y - 9, 58, 14);

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 9px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText(text, x + 30, y);
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        // ============================================
        // INTERIOR SYSTEM
        // ============================================

        const INTERIORS = {
            pi_office: {
                name: "JACK NOIR - PRIVATE INVESTIGATOR",
                width: 800,
                height: 500,
                backgroundColor: '#1a1612',
                floorColor: '#2a2218',
                wallColor: '#2d261f',
                // Furniture and props
                elements: [
                    // Waiting area (left side)
                    { type: 'couch', x: 80, y: 280, width: 120, height: 50 },
                    { type: 'table', x: 100, y: 350, width: 60, height: 40 },
                    { type: 'plant', x: 50, y: 250 },
                    { type: 'lamp', x: 210, y: 240, on: true },
                    // Secretary desk (center)
                    { type: 'desk', x: 300, y: 200, width: 150, height: 60, label: 'SECRETARY' },
                    { type: 'chair', x: 350, y: 270, facing: 'up' },
                    { type: 'filing_cabinet', x: 280, y: 120, width: 40, height: 80 },
                    { type: 'filing_cabinet', x: 460, y: 120, width: 40, height: 80 },
                    // Divider/wall to private office
                    { type: 'wall', x: 520, y: 100, width: 15, height: 300 },
                    { type: 'door_interior', x: 520, y: 180, width: 15, height: 70, label: 'PRIVATE', leadsTo: 'pi_private' },
                    // Private office (right side) - visible through door
                    { type: 'desk', x: 620, y: 200, width: 140, height: 70, label: 'YOUR DESK' },
                    { type: 'chair', x: 680, y: 280, facing: 'up' },
                    { type: 'window', x: 700, y: 80, width: 80, height: 100 },
                    { type: 'filing_cabinet', x: 580, y: 120, width: 35, height: 70 },
                    { type: 'chaise', x: 600, y: 330, width: 100, height: 45 }, // Client sits here
                    { type: 'lamp', x: 760, y: 180, on: true },
                    // Exit door
                    { type: 'exit_door', x: 380, y: 420, width: 60, height: 80 }
                ],
                // NPCs in this interior
                npcs: ['secretary'],
                // Ambient details
                details: [
                    { type: 'clock', x: 400, y: 90 },
                    { type: 'sign', x: 380, y: 60, text: 'NOIR INVESTIGATIONS' },
                    { type: 'blinds', x: 700, y: 80 }
                ]
            },

            cafe: {
                name: "ROSIE'S DINER",
                width: 700,
                height: 500,
                backgroundColor: '#1f1a15',
                floorColor: '#2a2520',
                wallColor: '#352a22',
                elements: [
                    // Counter
                    { type: 'counter', x: 50, y: 150, width: 300, height: 40 },
                    { type: 'stool', x: 80, y: 200 },
                    { type: 'stool', x: 130, y: 200 },
                    { type: 'stool', x: 180, y: 200 },
                    { type: 'stool', x: 230, y: 200 },
                    { type: 'stool', x: 280, y: 200 },
                    // Booths
                    { type: 'booth', x: 450, y: 120, width: 100, height: 70 },
                    { type: 'booth', x: 450, y: 220, width: 100, height: 70 },
                    { type: 'booth', x: 450, y: 320, width: 100, height: 70 },
                    // Tables
                    { type: 'table', x: 200, y: 300, width: 80, height: 60 },
                    { type: 'table', x: 320, y: 300, width: 80, height: 60 },
                    // Kitchen door
                    { type: 'door_interior', x: 50, y: 80, width: 60, height: 70, label: 'KITCHEN' },
                    // Pie display
                    { type: 'display_case', x: 360, y: 150, width: 60, height: 40 },
                    // Coffee machine
                    { type: 'coffee_machine', x: 100, y: 100 },
                    // Jukebox
                    { type: 'jukebox', x: 580, y: 350 },
                    // Exit
                    { type: 'exit_door', x: 320, y: 420, width: 60, height: 80 }
                ],
                npcs: ['waitress', 'cook'],
                details: [
                    { type: 'neon_sign', x: 300, y: 50, text: 'ROSIE\'S' },
                    { type: 'menu_board', x: 150, y: 70 },
                    { type: 'clock', x: 500, y: 60 }
                ]
            },

            bar: {
                name: "THE BLUE MOON",
                width: 750,
                height: 500,
                backgroundColor: '#0f0d10',
                floorColor: '#1a1618',
                wallColor: '#1f1a1d',
                elements: [
                    // Bar counter
                    { type: 'bar_counter', x: 50, y: 180, width: 350, height: 50 },
                    { type: 'stool', x: 80, y: 240 },
                    { type: 'stool', x: 130, y: 240 },
                    { type: 'stool', x: 180, y: 240 },
                    { type: 'stool', x: 230, y: 240 },
                    { type: 'stool', x: 280, y: 240 },
                    { type: 'stool', x: 330, y: 240 },
                    // Back bar with bottles
                    { type: 'back_bar', x: 50, y: 80, width: 350, height: 80 },
                    // Tables
                    { type: 'table', x: 480, y: 150, width: 70, height: 50 },
                    { type: 'table', x: 480, y: 250, width: 70, height: 50 },
                    { type: 'table', x: 600, y: 200, width: 70, height: 50 },
                    // Pool table
                    { type: 'pool_table', x: 550, y: 350, width: 120, height: 70 },
                    // Phone booth in back
                    { type: 'phone_booth', x: 680, y: 80 },
                    // Restroom doors
                    { type: 'door_interior', x: 680, y: 180, width: 50, height: 60, label: 'MEN' },
                    { type: 'door_interior', x: 680, y: 260, width: 50, height: 60, label: 'WOMEN' },
                    // Exit
                    { type: 'exit_door', x: 350, y: 420, width: 60, height: 80 }
                ],
                npcs: ['bartender', 'barfly1'],
                details: [
                    { type: 'neon_sign', x: 180, y: 50, text: 'BLUE MOON', color: '#3366ff' },
                    { type: 'dartboard', x: 620, y: 100 },
                    { type: 'mirror', x: 200, y: 90 }
                ]
            }
        };

        // Current interior state
        let currentInterior = null;
        let interiorPlayerPos = { x: 400, y: 380 };

        // Enter a building interior
        function enterBuilding(buildingId) {
            const interior = INTERIORS[buildingId];
            if (!interior) return;

            currentInterior = buildingId;
            game.state = 'interior';

            // Position player at entrance
            interiorPlayerPos = { x: interior.width / 2, y: interior.height - 100 };

            // Update location display
            document.getElementById('location-display').textContent = interior.name;
            document.getElementById('location-display').classList.add('visible');
            setTimeout(() => {
                document.getElementById('location-display').classList.remove('visible');
            }, 2000);
        }

        // Exit to street
        function exitBuilding() {
            // Find which building we were in and position player outside its door
            for (const building of currentMap.buildings) {
                if (building.interiorId === currentInterior) {
                    player.x = building.x + building.width / 2 - player.width / 2;
                    player.y = GROUND_LEVEL + 40; // On sidewalk in front of door
                    break;
                }
            }

            currentInterior = null;
            game.state = 'playing';
        }

        // Draw interior scene
        function drawInterior() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            // Background
            ctx.fillStyle = interior.backgroundColor;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Floor
            const floorY = 250;
            ctx.fillStyle = interior.floorColor;
            ctx.fillRect(0, floorY, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT - floorY);

            // Floor boards
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1;
            for (let x = 0; x < CONFIG.CANVAS_WIDTH; x += 60) {
                ctx.beginPath();
                ctx.moveTo(x, floorY);
                ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }

            // Walls
            ctx.fillStyle = interior.wallColor;
            ctx.fillRect(0, 50, CONFIG.CANVAS_WIDTH, floorY - 50);

            // Wainscoting
            ctx.fillStyle = adjustBrightness(interior.wallColor, 0.7);
            ctx.fillRect(0, floorY - 60, CONFIG.CANVAS_WIDTH, 60);
            ctx.strokeStyle = adjustBrightness(interior.wallColor, 0.5);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, floorY - 60);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, floorY - 60);
            ctx.stroke();

            // Ceiling
            ctx.fillStyle = '#1a1815';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, 50);

            // Ceiling light
            ctx.fillStyle = '#0a0a08';
            ctx.beginPath();
            ctx.moveTo(CONFIG.CANVAS_WIDTH/2 - 40, 50);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 + 40, 50);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 + 30, 80);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 - 30, 80);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#f0d890';
            ctx.shadowColor = '#f0d890';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(CONFIG.CANVAS_WIDTH/2, 75, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw elements
            for (const el of interior.elements) {
                drawInteriorElement(el);
            }

            // Draw details
            for (const detail of interior.details || []) {
                drawInteriorDetail(detail);
            }

            // Draw interior NPCs
            for (const npcId of interior.npcs || []) {
                const npc = npcs.find(n => n.id === npcId);
                if (npc) {
                    drawInteriorNPC(npc);
                }
            }

            // Draw player in interior
            drawMannequin(interiorPlayerPos.x, interiorPlayerPos.y, {
                facing: player.facing,
                isMoving: player.isMoving,
                walkCycle: player.walkCycle,
                outfit: 'detective',
                hatType: 'fedora',
                lightFactor: 0.95,
                isPlayer: true,
                appearance: player.appearance
            });
        }

        function drawInteriorElement(el) {
            const x = el.x + (CONFIG.CANVAS_WIDTH - INTERIORS[currentInterior].width) / 2;
            const y = el.y + 100;

            switch (el.type) {
                case 'desk':
                    // Desk shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 5, el.width, 10);
                    // Desk body
                    ctx.fillStyle = '#3d2a1a';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Desk top
                    ctx.fillStyle = '#4a3520';
                    ctx.fillRect(x - 5, y - 5, el.width + 10, 10);
                    // Drawers
                    ctx.strokeStyle = '#2a1a10';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 10, y + 15, el.width/3 - 15, el.height - 25);
                    ctx.strokeRect(x + el.width/3 + 5, y + 15, el.width/3 - 10, el.height - 25);
                    // Drawer handles
                    ctx.fillStyle = '#b08030';
                    ctx.fillRect(x + 25, y + 35, 15, 4);
                    ctx.fillRect(x + el.width/3 + 20, y + 35, 15, 4);
                    // Items on desk
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x + el.width - 40, y - 15, 30, 20); // Phone
                    ctx.fillStyle = '#f0e8d8';
                    ctx.fillRect(x + 20, y - 12, 50, 35); // Papers
                    break;

                case 'chair':
                    ctx.fillStyle = '#2a2015';
                    // Seat
                    ctx.fillRect(x - 15, y, 30, 25);
                    // Back
                    ctx.fillRect(x - 12, y - 30, 24, 35);
                    // Legs
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x - 12, y + 25, 4, 15);
                    ctx.fillRect(x + 8, y + 25, 4, 15);
                    break;

                case 'couch':
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 3, el.width, 8);
                    // Base
                    ctx.fillStyle = '#3a2820';
                    ctx.fillRect(x, y + 20, el.width, el.height - 20);
                    // Cushions
                    ctx.fillStyle = '#4a3830';
                    ctx.fillRect(x + 5, y + 10, el.width/2 - 8, el.height - 15);
                    ctx.fillRect(x + el.width/2 + 3, y + 10, el.width/2 - 8, el.height - 15);
                    // Back
                    ctx.fillStyle = '#3a2820';
                    ctx.fillRect(x, y, el.width, 25);
                    // Arms
                    ctx.fillRect(x - 10, y, 15, el.height);
                    ctx.fillRect(x + el.width - 5, y, 15, el.height);
                    break;

                case 'chaise':
                    // Chaise lounge for clients
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 3, y + el.height + 2, el.width, 6);
                    ctx.fillStyle = '#4a3028';
                    ctx.fillRect(x, y + 10, el.width, el.height - 10);
                    ctx.fillStyle = '#5a4038';
                    ctx.fillRect(x + 5, y + 5, el.width - 30, el.height - 10);
                    // Raised end
                    ctx.fillStyle = '#4a3028';
                    ctx.fillRect(x + el.width - 25, y - 10, 25, el.height + 10);
                    break;

                case 'filing_cabinet':
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.strokeRect(x + 3, y + 5 + i * (el.height/3), el.width - 6, el.height/3 - 8);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(x + el.width/2 - 8, y + 15 + i * (el.height/3), 16, 4);
                    }
                    break;

                case 'table':
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(x + 3, y + el.height + 2, el.width, 5);
                    ctx.fillStyle = '#3d2a1a';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#4a3520';
                    ctx.fillRect(x - 3, y - 3, el.width + 6, 6);
                    break;

                case 'lamp':
                    // Stand
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x - 3, y, 6, 50);
                    // Base
                    ctx.fillRect(x - 12, y + 50, 24, 6);
                    // Shade
                    ctx.fillStyle = el.on ? '#e8d090' : '#4a4030';
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y);
                    ctx.lineTo(x + 20, y);
                    ctx.lineTo(x + 15, y - 25);
                    ctx.lineTo(x - 15, y - 25);
                    ctx.closePath();
                    ctx.fill();
                    if (el.on) {
                        ctx.fillStyle = 'rgba(255, 230, 150, 0.15)';
                        ctx.beginPath();
                        ctx.moveTo(x - 20, y);
                        ctx.lineTo(x - 60, y + 100);
                        ctx.lineTo(x + 60, y + 100);
                        ctx.lineTo(x + 20, y);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'exit_door':
                    // Door frame
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x - 5, y - 5, el.width + 10, el.height + 5);
                    // Door
                    ctx.fillStyle = '#2a2015';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Window
                    ctx.fillStyle = 'rgba(100, 120, 140, 0.3)';
                    ctx.fillRect(x + 10, y + 10, el.width - 20, 30);
                    // Handle
                    ctx.fillStyle = '#b08030';
                    ctx.beginPath();
                    ctx.arc(x + el.width - 12, y + el.height/2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // EXIT sign
                    ctx.fillStyle = '#ff3030';
                    ctx.shadowColor = '#ff3030';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 12px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXIT', x + el.width/2, y - 15);
                    ctx.shadowBlur = 0;
                    break;

                case 'window':
                    ctx.fillStyle = '#0a0a15';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Night sky through window
                    ctx.fillStyle = '#0f0f1a';
                    ctx.fillRect(x + 4, y + 4, el.width - 8, el.height - 8);
                    // Window frame
                    ctx.strokeStyle = '#2a2520';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, y, el.width, el.height);
                    ctx.beginPath();
                    ctx.moveTo(x + el.width/2, y);
                    ctx.lineTo(x + el.width/2, y + el.height);
                    ctx.moveTo(x, y + el.height/2);
                    ctx.lineTo(x + el.width, y + el.height/2);
                    ctx.stroke();
                    // City lights outside
                    ctx.fillStyle = '#f0d060';
                    ctx.fillRect(x + 15, y + 60, 3, 5);
                    ctx.fillRect(x + 45, y + 50, 2, 4);
                    ctx.fillRect(x + 60, y + 65, 3, 4);
                    break;

                case 'wall':
                    ctx.fillStyle = '#2a2520';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(x, y + el.height - 40, el.width, 40);
                    break;

                case 'door_interior':
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x, y, el.width + 40, el.height);
                    ctx.fillStyle = '#2a2015';
                    ctx.fillRect(x + 3, y + 3, el.width + 34, el.height - 6);
                    // Frosted glass
                    ctx.fillStyle = 'rgba(200, 180, 140, 0.2)';
                    ctx.fillRect(x + 8, y + 10, el.width + 24, el.height/2);
                    // Label
                    if (el.label) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.font = '10px Special Elite';
                        ctx.textAlign = 'center';
                        ctx.fillText(el.label, x + el.width/2 + 20, y + 30);
                    }
                    break;

                case 'stool':
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x - 2, y, 4, 30);
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#6b0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'counter':
                case 'bar_counter':
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 3, el.width, 8);
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#3a2515';
                    ctx.fillRect(x - 5, y - 8, el.width + 10, 12);
                    // Bar rail
                    ctx.fillStyle = '#b08030';
                    ctx.fillRect(x, y + el.height - 8, el.width, 4);
                    break;
            }
        }

        function drawInteriorDetail(detail) {
            const x = detail.x + (CONFIG.CANVAS_WIDTH - INTERIORS[currentInterior].width) / 2;
            const y = detail.y + 100;

            switch (detail.type) {
                case 'clock':
                    ctx.fillStyle = '#2a2520';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#f0e8d8';
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, Math.PI * 2);
                    ctx.fill();
                    // Hands
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 8, y - 5);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 3, y + 10);
                    ctx.stroke();
                    break;

                case 'neon_sign':
                    ctx.fillStyle = detail.color || '#ff3333';
                    ctx.shadowColor = detail.color || '#ff3333';
                    ctx.shadowBlur = 20;
                    ctx.font = 'bold 24px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText(detail.text, x, y);
                    ctx.shadowBlur = 0;
                    break;

                case 'sign':
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(x - 60, y - 15, 120, 30);
                    ctx.fillStyle = '#c4a35a';
                    ctx.font = '12px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText(detail.text, x, y + 5);
                    break;
            }
        }

        function drawInteriorNPC(npc) {
            const interior = INTERIORS[currentInterior];
            const baseX = (CONFIG.CANVAS_WIDTH - interior.width) / 2;

            // Position based on role
            let npcX = baseX + 375;
            let npcY = 360;

            if (npc.role === 'secretary') {
                npcX = baseX + 375;
                npcY = 360;
            } else if (npc.role === 'bartender') {
                npcX = baseX + 200;
                npcY = 320;
            } else if (npc.role === 'owner') {
                npcX = baseX + 150;
                npcY = 360;
            } else if (npc.role === 'pharmacist') {
                npcX = baseX + 300;
                npcY = 360;
            }

            // Determine outfit based on role and gender
            let outfit = 'suit';
            if (npc.appearance && npc.appearance.gender === 'f') {
                outfit = 'dress';
            }

            drawMannequin(npcX, npcY, {
                facing: -1, // Face toward player entering
                isMoving: false,
                walkCycle: 0,
                outfit: outfit,
                hatType: 'none',
                lightFactor: 0.9,
                isPlayer: false,
                appearance: npc.appearance // Pass NPC's appearance for proper skin/face
            });

            // Draw NPC name label above them
            ctx.fillStyle = '#d4c5a9';
            ctx.font = '12px "Special Elite", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(npc.name.toUpperCase(), npcX, npcY - 85);
        }

        // ============================================
        // DIALOGUE SYSTEM
        // ============================================

        let currentDialogue = null;
        let dialogueIndex = 0;

        function startDialogue(npcId) {
            const npc = npcs.find(n => n.id === npcId);
            if (!npc || !npc.dialogue) return;

            currentDialogue = npc;
            dialogueIndex = 0;
            game.state = 'dialogue';

            showDialogueBox(npc.name, npc.dialogue[0]);
        }

        function advanceDialogue() {
            if (!currentDialogue) return;

            dialogueIndex++;
            if (dialogueIndex >= currentDialogue.dialogue.length) {
                endDialogue();
                return;
            }

            showDialogueBox(currentDialogue.name, currentDialogue.dialogue[dialogueIndex]);
        }

        function endDialogue() {
            currentDialogue = null;
            dialogueIndex = 0;
            game.state = currentInterior ? 'interior' : 'playing';
            hideDialogueBox();
        }

        function showDialogueBox(speaker, text) {
            document.getElementById('dialogue-speaker').textContent = speaker.toUpperCase();
            document.getElementById('dialogue-text').textContent = text;
            document.getElementById('dialogue-box').classList.add('visible');
        }

        function hideDialogueBox() {
            document.getElementById('dialogue-box').classList.remove('visible');
        }

        // ============================================
        // DRIVING SYSTEM
        // ============================================

        function enterCar(car) {
            player.inCar = true;
            player.currentCar = car;
            player.carSpeed = 0;
            game.state = 'driving';

            // Hide interaction prompt
            document.getElementById('interact-prompt').classList.remove('visible');

            // Show driving HUD
            document.getElementById('location-display').textContent = 'DRIVING';
            document.getElementById('location-display').classList.add('visible');
        }

        function exitCar() {
            if (!player.currentCar) return;

            // Position player next to car
            player.x = player.currentCar.x + 120;
            player.y = GROUND_LEVEL + 100;

            player.inCar = false;
            player.currentCar = null;
            player.carSpeed = 0;
            game.state = 'playing';

            document.getElementById('location-display').classList.remove('visible');
        }

        function updateDriving() {
            if (!player.currentCar) return;

            const car = player.currentCar;
            const maxSpeed = CONFIG.CAR_SPEED;
            const acceleration = 0.3;
            const friction = 0.1;
            const carWidth = 120; // Width of car collision box

            // Store previous position for collision rollback
            const prevX = car.x;

            // Accelerate/brake
            if (keys.up || keys.right) {
                player.carSpeed = Math.min(maxSpeed, player.carSpeed + acceleration);
            } else if (keys.down || keys.left) {
                player.carSpeed = Math.max(-maxSpeed * 0.5, player.carSpeed - acceleration);
            } else {
                // Apply friction
                if (player.carSpeed > 0) {
                    player.carSpeed = Math.max(0, player.carSpeed - friction);
                } else if (player.carSpeed < 0) {
                    player.carSpeed = Math.min(0, player.carSpeed + friction);
                }
            }

            // Move car
            car.x += player.carSpeed;

            // Keep car on road
            car.x = Math.max(50, Math.min(currentMap.width - 150, car.x));

            // Check collision with other parked cars
            for (const otherCar of currentMap.cars) {
                if (otherCar === car) continue; // Skip self

                // Simple box collision check
                const carLeft = car.x;
                const carRight = car.x + carWidth;
                const otherLeft = otherCar.x;
                const otherRight = otherCar.x + carWidth;

                if (carRight > otherLeft && carLeft < otherRight) {
                    // Collision! Stop and push back
                    car.x = prevX;
                    player.carSpeed = 0;
                    break;
                }
            }

            // Update player position to match car
            player.x = car.x + 50;
            player.y = GROUND_LEVEL + 100;

            // Update camera
            camera.x = player.x - CONFIG.CANVAS_WIDTH / 2;
            camera.x = Math.max(0, Math.min(currentMap.width - CONFIG.CANVAS_WIDTH, camera.x));

            // Check for exit (when stopped)
            if (Math.abs(player.carSpeed) < 0.1) {
                document.getElementById('interact-prompt').textContent = '[E] EXIT CAR';
                document.getElementById('interact-prompt').classList.add('visible');
            } else {
                document.getElementById('interact-prompt').classList.remove('visible');
            }
        }

        function drawDrivingHUD() {
            // Speedometer
            const speed = Math.abs(player.carSpeed);
            const speedPercent = speed / CONFIG.CAR_SPEED;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(CONFIG.CANVAS_WIDTH - 150, CONFIG.CANVAS_HEIGHT - 80, 130, 60);

            ctx.fillStyle = '#c4a35a';
            ctx.font = '12px Bebas Neue';
            ctx.textAlign = 'left';
            ctx.fillText('SPEED', CONFIG.CANVAS_WIDTH - 140, CONFIG.CANVAS_HEIGHT - 60);

            // Speed bar
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(CONFIG.CANVAS_WIDTH - 140, CONFIG.CANVAS_HEIGHT - 50, 110, 15);

            ctx.fillStyle = speed > CONFIG.CAR_SPEED * 0.7 ? '#c44' : '#4a4';
            ctx.fillRect(CONFIG.CANVAS_WIDTH - 140, CONFIG.CANVAS_HEIGHT - 50, 110 * speedPercent, 15);

            // MPH display
            const mph = Math.round(speed * 10);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Bebas Neue';
            ctx.textAlign = 'right';
            ctx.fillText(mph + ' MPH', CONFIG.CANVAS_WIDTH - 30, CONFIG.CANVAS_HEIGHT - 25);
        }

        // ============================================
        // ACTION SYSTEM (Interview, Smack, Gun)
        // ============================================

        function performAction(actionType, targetNPC) {
            if (player.actionCooldown > 0) return;

            actions.currentAction = actionType;
            actions.targetNPC = targetNPC;

            switch (actionType) {
                case 'interview':
                    performInterview(targetNPC);
                    break;
                case 'smack':
                    performSmack(targetNPC);
                    break;
                case 'gun':
                    performGun(targetNPC);
                    break;
            }

            player.actionCooldown = 30; // Cooldown frames
        }

        function performInterview(npc) {
            const npcState = worldState.npcStates[npc.id];

            // Different responses based on relationship
            let dialogues;
            if (npcState && npcState.intimidated) {
                dialogues = [
                    "Okay, okay! I'll tell you everything!",
                    "Please, don't hurt me. Here's what I know...",
                    "There's a man... comes around late at night...",
                    "I saw him near the apartments last week.",
                    "He wears a dark coat, always looking around nervous-like."
                ];
            } else if (npc.canBeBribed && player.cash >= 10) {
                dialogues = [
                    "Maybe if you made it worth my while...",
                    "Information ain't free, pal.",
                    "I might know something. What's in it for me?"
                ];
            } else {
                dialogues = npc.dialogue || [
                    "I don't know anything.",
                    "Can't help you, stranger.",
                    "Mind your own business."
                ];
            }

            const randomDialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
            showDialogueBox(npc.name, randomDialogue);
            game.state = 'dialogue';

            if (npcState) {
                npcState.talked = true;
            }
        }

        function performSmack(npc) {
            // Screen shake effect
            actions.actionTimer = 10;

            // NPC reaction - intimidation
            const smackReactions = [
                "Hey! What's the big idea?!",
                "You'll regret that!",
                "*stumbles back*",
                "Is that all you got?",
                "Okay okay! I'll talk!"
            ];

            // Decrease reputation
            game.reputation = Math.max(1, game.reputation - 1);
            updateRepDisplay();

            const reaction = smackReactions[Math.floor(Math.random() * smackReactions.length)];
            showDialogueBox(npc.name, reaction);
            game.state = 'dialogue';

            // NPCs reveal info when intimidated
            const npcState = worldState.npcStates[npc.id];
            if (npcState) {
                npcState.intimidated = true;
            }
        }

        function performGun(npc) {
            // Draw gun to threaten - doesn't need to shoot
            if (player.weapon !== 'pistol') {
                showDialogueBox('SYSTEM', "You reach for your piece... but you don't have one.");
                game.state = 'dialogue';
                return;
            }

            // Screen effect - tense moment
            actions.actionTimer = 8;

            // Major intimidation
            const npcState = worldState.npcStates[npc.id];
            if (npcState) {
                npcState.intimidated = true;
                npcState.terrified = true;
            }

            // Major reputation hit
            game.reputation = Math.max(1, game.reputation - 2);
            updateRepDisplay();

            const gunReactions = [
                "Whoa! Easy there! I'll tell you everything!",
                "Please don't shoot! I have a family!",
                "*hands up* Okay, okay! Whatever you want!",
                "You're crazy! Here, take my wallet!",
                "The killer... he hangs around the apartments! That's all I know!"
            ];

            const reaction = gunReactions[Math.floor(Math.random() * gunReactions.length)];
            showDialogueBox(npc.name, reaction);
            game.state = 'dialogue';

            // This would trigger police response in full game
            worldState.events.push({
                type: 'gun_threat',
                location: currentInterior || 'street',
                time: { ...game.time },
                witnessed: true
            });
        }

        function updateCashDisplay() {
            document.getElementById('cash-display').textContent = '$' + player.cash.toFixed(2);
        }

        function updateRepDisplay() {
            const filled = '■'.repeat(game.reputation);
            const empty = '□'.repeat(5 - game.reputation);
            document.getElementById('rep-display').textContent = filled + empty;
        }

        function drawActionMenu() {
            if (!player.nearInteractable || player.nearInteractable.type !== 'npc') return;
            if (game.state === 'dialogue') return;

            const npc = player.nearInteractable.npc;
            if (!npc) return;

            // Draw action hints at bottom of screen
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(CONFIG.CANVAS_WIDTH / 2 - 200, CONFIG.CANVAS_HEIGHT - 45, 400, 35);

            ctx.fillStyle = '#c4a35a';
            ctx.font = '12px Special Elite';
            ctx.textAlign = 'center';

            let actionText = '[I] INTERVIEW';
            actionText += '  [S] SMACK';
            if (player.weapon === 'pistol') actionText += '  [G] GUN';

            ctx.fillText(actionText, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 22);
        }

        // ============================================
        // PLAYER UPDATE
        // ============================================

        function updatePlayer() {
            // Handle dialogue state
            if (game.state === 'dialogue') {
                return; // No movement during dialogue
            }

            // Handle interior movement
            if (game.state === 'interior') {
                updateInteriorPlayer();
                return;
            }

            if (game.state !== 'playing') return;

            player.isMoving = false;

            if (keys.up) {
                player.y -= player.speed;
                player.direction = 'up';
                player.isMoving = true;
            }
            if (keys.down) {
                player.y += player.speed;
                player.direction = 'down';
                player.isMoving = true;
            }
            if (keys.left) {
                player.x -= player.speed;
                player.direction = 'left';
                player.facing = -1;
                player.isMoving = true;
            }
            if (keys.right) {
                player.x += player.speed;
                player.direction = 'right';
                player.facing = 1;
                player.isMoving = true;
            }

            if (player.isMoving) {
                player.walkCycle++;
            }

            // Boundary checks - player stays on sidewalk/street area
            player.x = Math.max(20, Math.min(currentMap.width - player.width - 20, player.x));
            // Y boundaries: sidewalk to far sidewalk
            // GROUND_LEVEL = 410, sidewalk starts there, street is further down
            player.y = Math.max(GROUND_LEVEL + 30, Math.min(GROUND_LEVEL + 180, player.y));

            // Collision with buildings
            for (const collider of currentMap.colliders || []) {
                const playerRight = player.x + player.width;
                const playerBottom = player.y + player.height;

                if (player.x < collider.x + collider.width &&
                    playerRight > collider.x &&
                    player.y < collider.y + collider.height &&
                    playerBottom > collider.y) {
                    // Push player out of collision
                    const overlapLeft = playerRight - collider.x;
                    const overlapRight = collider.x + collider.width - player.x;
                    const overlapTop = playerBottom - collider.y;
                    const overlapBottom = collider.y + collider.height - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop) player.y = collider.y - player.height;
                    else if (minOverlap === overlapBottom) player.y = collider.y + collider.height;
                    else if (minOverlap === overlapLeft) player.x = collider.x - player.width;
                    else if (minOverlap === overlapRight) player.x = collider.x + collider.width;
                }
            }

            // Update camera to follow player (horizontal only - side scroller)
            camera.x = player.x - CONFIG.CANVAS_WIDTH / 2 + player.width / 2;
            camera.y = 0; // Fixed vertical - no Y scrolling in side scroller

            // Camera bounds (horizontal only)
            camera.x = Math.max(0, Math.min(currentMap.width - CONFIG.CANVAS_WIDTH, camera.x));

            // Check for interactions
            checkInteractions();
        }

        function updateInteriorPlayer() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            player.isMoving = false;

            if (keys.up) {
                interiorPlayerPos.y -= player.speed;
                player.isMoving = true;
            }
            if (keys.down) {
                interiorPlayerPos.y += player.speed;
                player.isMoving = true;
            }
            if (keys.left) {
                interiorPlayerPos.x -= player.speed;
                player.facing = -1;
                player.isMoving = true;
            }
            if (keys.right) {
                interiorPlayerPos.x += player.speed;
                player.facing = 1;
                player.isMoving = true;
            }

            if (player.isMoving) {
                player.walkCycle++;
            }

            // Boundary checks
            interiorPlayerPos.x = Math.max(50, Math.min(interior.width - 50, interiorPlayerPos.x));
            interiorPlayerPos.y = Math.max(180, Math.min(interior.height - 50, interiorPlayerPos.y));

            // Check for exit door
            checkInteriorInteractions();
        }

        function checkInteriorInteractions() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            const baseX = (CONFIG.CANVAS_WIDTH - interior.width) / 2;
            let nearInteractable = false;

            // Check for exit door
            for (const el of interior.elements) {
                if (el.type === 'exit_door') {
                    const doorX = el.x + baseX + el.width / 2;
                    const doorY = el.y + 100;
                    const dist = Math.sqrt(
                        Math.pow(interiorPlayerPos.x + baseX - doorX, 2) +
                        Math.pow(interiorPlayerPos.y - doorY + 40, 2)
                    );

                    if (dist < 60) {
                        nearInteractable = true;
                        document.getElementById('interact-prompt').textContent = '[E] EXIT';
                        nearInteractable = { type: 'exit' };
                        break;
                    }
                }
            }

            // Check for NPCs to talk to
            if (!nearInteractable) {
                for (const npcId of interior.npcs || []) {
                    const npc = npcs.find(n => n.id === npcId);
                    if (npc) {
                        // Calculate NPC position based on role (must match drawInteriorNPC)
                        let npcX = 375;
                        let npcY = 360;
                        if (npc.role === 'secretary') { npcX = 375; npcY = 360; }
                        else if (npc.role === 'bartender') { npcX = 200; npcY = 320; }
                        else if (npc.role === 'owner') { npcX = 150; npcY = 360; }
                        else if (npc.role === 'cook') { npcX = 100; npcY = 360; }
                        else if (npc.role === 'patron') { npcX = 280; npcY = 360; }
                        else if (npc.role === 'pharmacist') { npcX = 300; npcY = 360; }
                        else if (npc.role === 'employee') { npcX = 350; npcY = 360; }

                        const dist = Math.sqrt(
                            Math.pow(interiorPlayerPos.x - npcX, 2) +
                            Math.pow(interiorPlayerPos.y - npcY, 2)
                        );

                        if (dist < 80) {
                            nearInteractable = { type: 'npc', npc: npc };
                            let prompt = `[I] INTERVIEW ${npc.name.toUpperCase()}  [S] SMACK`;
                            if (player.weapon === 'pistol') prompt += '  [G] GUN';
                            document.getElementById('interact-prompt').textContent = prompt;
                            break;
                        }
                    }
                }
            }

            const promptEl = document.getElementById('interact-prompt');
            if (nearInteractable) {
                promptEl.classList.add('visible');
                player.nearInteractable = nearInteractable;
            } else {
                promptEl.classList.remove('visible');
                player.nearInteractable = null;
            }
        }

        function checkInteractions() {
            let nearInteractable = null;

            // Check building entrances
            for (const building of currentMap.buildings) {
                if (building.enterable) {
                    const doorX = building.x + building.width / 2;

                    // Use primarily horizontal distance - player just needs to be in front of door
                    const xDist = Math.abs(player.x + player.width / 2 - doorX);
                    // Player should be on sidewalk near building (GROUND_LEVEL + 20 to +60)
                    const nearBuilding = player.y >= GROUND_LEVEL + 15 && player.y <= GROUND_LEVEL + 70;

                    if (xDist < 50 && nearBuilding) {
                        nearInteractable = { type: 'building', building: building };
                        document.getElementById('interact-prompt').textContent = `[E] ENTER ${building.name.split('\n')[0]}`;
                        break;
                    }
                }
            }

            // Check street NPCs
            if (!nearInteractable) {
                for (const npc of npcs.filter(n => n.location === 'street')) {
                    const state = worldState.npcStates[npc.id];
                    if (!state) continue;

                    const dist = Math.sqrt(
                        Math.pow(player.x + player.width/2 - state.x, 2) +
                        Math.pow(player.y - state.y, 2)
                    );

                    if (dist < 60) {
                        nearInteractable = { type: 'npc', npc: npc };
                        let prompt = `[I] INTERVIEW ${npc.name.toUpperCase()}  [S] SMACK`;
                        if (player.weapon === 'pistol') prompt += '  [G] GUN';
                        document.getElementById('interact-prompt').textContent = prompt;
                        break;
                    }
                }
            }

            // Check cars
            if (!nearInteractable) {
                for (const car of currentMap.cars) {
                    if (car.canEnter) {
                        const dist = Math.sqrt(
                            Math.pow(player.x - car.x - 50, 2) +
                            Math.pow(player.y - (GROUND_LEVEL + 120), 2)
                        );

                        if (dist < 70) {
                            nearInteractable = { type: 'car', car: car };
                            document.getElementById('interact-prompt').textContent = '[E] ENTER CAR';
                            break;
                        }
                    }
                }
            }

            const promptEl = document.getElementById('interact-prompt');
            if (nearInteractable) {
                promptEl.classList.add('visible');
                player.nearInteractable = nearInteractable;
            } else {
                promptEl.classList.remove('visible');
                player.nearInteractable = null;
            }
        }

        function handleInteraction() {
            if (game.state === 'dialogue') {
                advanceDialogue();
                return;
            }

            if (game.state === 'interior') {
                if (player.nearInteractable) {
                    if (player.nearInteractable.type === 'exit') {
                        exitBuilding();
                    } else if (player.nearInteractable.type === 'npc') {
                        startDialogue(player.nearInteractable.npc.id);
                    }
                }
                return;
            }

            if (game.state === 'driving') {
                if (Math.abs(player.carSpeed) < 0.1) {
                    exitCar();
                }
                return;
            }

            if (game.state === 'playing' && player.nearInteractable) {
                if (player.nearInteractable.type === 'building') {
                    const building = player.nearInteractable.building;
                    if (INTERIORS[building.interiorId]) {
                        enterBuilding(building.interiorId);
                    }
                } else if (player.nearInteractable.type === 'car') {
                    enterCar(player.nearInteractable.car);
                } else if (player.nearInteractable.type === 'npc') {
                    startDialogue(player.nearInteractable.npc.id);
                }
            }
        }

        // Handle action keys (B, F, G)
        function handleActionKey(action) {
            if (game.state !== 'playing' && game.state !== 'interior') return;
            if (!player.nearInteractable || player.nearInteractable.type !== 'npc') return;

            const npc = player.nearInteractable.npc;
            if (!npc) return;

            performAction(action, npc);
        }

        function updateGameTime() {
            // Advance game time (1 real second = 1 game minute)
            game.time.minutes += CONFIG.GAME_SPEED;

            if (game.time.minutes >= 60) {
                game.time.minutes = 0;
                game.time.hours++;

                if (game.time.hours >= 24) {
                    game.time.hours = 0;
                    game.day++;
                }
            }

            // Update clock display
            const hours = game.time.hours % 12 || 12;
            const minutes = String(game.time.minutes).padStart(2, '0');
            const ampm = game.time.hours >= 12 ? 'PM' : 'AM';
            document.getElementById('clock').textContent = `${hours}:${minutes} ${ampm}`;
        }

        function updateLocationDisplay() {
            const locDisplay = document.getElementById('location-display');

            // Determine current area based on player position
            let currentLocation = currentMap.name;

            for (const building of currentMap.buildings) {
                const nearDoor = Math.abs(player.x - (building.x + building.width / 2)) < 100 &&
                                 Math.abs(player.y - (building.y + building.height)) < 80;

                if (nearDoor) {
                    currentLocation = building.name.split('\n')[0];
                    break;
                }
            }

            if (locDisplay.textContent !== currentLocation) {
                locDisplay.textContent = currentLocation;
                locDisplay.classList.add('visible');

                setTimeout(() => {
                    locDisplay.classList.remove('visible');
                }, 3000);
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, 150, 120);

            const scale = 150 / currentMap.width;

            // Draw buildings
            minimapCtx.fillStyle = '#3d3d3d';
            for (const building of currentMap.buildings) {
                minimapCtx.fillRect(
                    building.x * scale,
                    building.y * scale * 0.8,
                    building.width * scale,
                    building.height * scale * 0.8
                );
            }

            // Draw player
            minimapCtx.fillStyle = '#c4a35a';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale * 0.8, 3, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw viewport rectangle
            minimapCtx.strokeStyle = '#8b7355';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale * 0.8,
                CONFIG.CANVAS_WIDTH * scale,
                CONFIG.CANVAS_HEIGHT * scale * 0.8
            );
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================

        let lastTime = 0;
        let timeAccumulator = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Update game time every second
            timeAccumulator += deltaTime;
            if (timeAccumulator >= 1000) {
                updateGameTime();
                timeAccumulator = 0;
            }

            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Initialize world state on first frame
            if (!worldState.initialized) {
                initWorldState();
            }

            if (game.state === 'playing') {
                updatePlayer();
                updateLocationDisplay();

                // Draw scene
                drawSky();
                drawGround();

                // Draw street lights (back layer glow)
                for (const light of currentMap.streetLights) {
                    drawStreetLight(light);
                }

                // Draw alleys (dark gaps between buildings)
                drawAlleys();

                // Draw buildings
                for (const building of currentMap.buildings) {
                    drawBuilding(building);
                }

                // Draw street props (behind characters)
                drawStreetProps();

                // Draw cars
                for (const car of currentMap.cars) {
                    drawCar(car);
                }

                // Collect all drawable entities and sort by Y for proper depth
                const entities = [];

                // Add STREET NPCs only (pedestrians) - building NPCs stay inside
                for (const npc of npcs.filter(n => n.location === 'street')) {
                    const state = worldState.npcStates[npc.id];
                    if (state) {
                        entities.push({ type: 'npc', data: npc, y: state.y });
                    }
                }

                // Add player
                entities.push({ type: 'player', data: player, y: player.y });

                // Sort by Y position (painter's algorithm)
                entities.sort((a, b) => a.y - b.y);

                // Draw sorted entities
                for (const entity of entities) {
                    if (entity.type === 'player') {
                        drawPlayer();
                    } else if (entity.type === 'npc') {
                        drawNPC(entity.data);
                    }
                }

                // Draw minimap
                drawMinimap();
            } else if (game.state === 'interior' || game.state === 'dialogue') {
                updatePlayer();
                drawInterior();
                drawActionMenu();
            } else if (game.state === 'driving') {
                updateDriving();

                // Draw scene
                drawSky();
                drawGround();

                for (const light of currentMap.streetLights) {
                    drawStreetLight(light);
                }

                // Draw alleys (dark gaps between buildings)
                drawAlleys();

                for (const building of currentMap.buildings) {
                    drawBuilding(building);
                }

                drawStreetProps();

                for (const car of currentMap.cars) {
                    drawCar(car);
                }

                drawMinimap();
                drawDrivingHUD();
            } else if (game.state === 'title') {
                drawTitleScreen();
            }

            // Update cooldowns
            if (player.actionCooldown > 0) player.actionCooldown--;

            // Screen shake effect
            if (actions.actionTimer > 0) {
                actions.actionTimer--;
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * actions.actionTimer,
                    (Math.random() - 0.5) * actions.actionTimer
                );
                ctx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // Shattered glass shards - generated once
        let glassShards = null;
        let titleAnimTime = 0;

        function generateGlassShards() {
            const shards = [];
            const impactX = CONFIG.CANVAS_WIDTH * 0.55;
            const impactY = CONFIG.CANVAS_HEIGHT * 0.35;

            // Generate radial cracks from impact point
            const numCracks = 12;
            for (let i = 0; i < numCracks; i++) {
                const angle = (i / numCracks) * Math.PI * 2 + Math.random() * 0.3;
                const length = 150 + Math.random() * 350;
                shards.push({
                    type: 'crack',
                    x1: impactX,
                    y1: impactY,
                    x2: impactX + Math.cos(angle) * length,
                    y2: impactY + Math.sin(angle) * length,
                    branches: []
                });

                // Add branches to main cracks
                const numBranches = Math.floor(Math.random() * 4) + 2;
                for (let j = 0; j < numBranches; j++) {
                    const t = 0.2 + Math.random() * 0.6;
                    const bx = impactX + Math.cos(angle) * length * t;
                    const by = impactY + Math.sin(angle) * length * t;
                    const bAngle = angle + (Math.random() - 0.5) * 1.2;
                    const bLength = 30 + Math.random() * 80;
                    shards[shards.length - 1].branches.push({
                        x1: bx, y1: by,
                        x2: bx + Math.cos(bAngle) * bLength,
                        y2: by + Math.sin(bAngle) * bLength
                    });
                }
            }

            // Generate glass fragments around impact
            const numFragments = 25;
            for (let i = 0; i < numFragments; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 120;
                const fx = impactX + Math.cos(angle) * dist;
                const fy = impactY + Math.sin(angle) * dist;
                const size = 15 + Math.random() * 40;
                const points = [];
                const numPoints = 4 + Math.floor(Math.random() * 3);
                for (let p = 0; p < numPoints; p++) {
                    const pa = (p / numPoints) * Math.PI * 2;
                    const pr = size * (0.6 + Math.random() * 0.4);
                    points.push({
                        x: fx + Math.cos(pa) * pr,
                        y: fy + Math.sin(pa) * pr
                    });
                }
                shards.push({
                    type: 'fragment',
                    points: points,
                    fallen: dist < 60, // Fragments near impact have fallen out
                    reflection: Math.random()
                });
            }

            // Blood drops on glass
            const numDrops = 8;
            for (let i = 0; i < numDrops; i++) {
                shards.push({
                    type: 'blood',
                    x: impactX - 50 + Math.random() * 150,
                    y: impactY - 30 + Math.random() * 200,
                    size: 3 + Math.random() * 8,
                    drip: Math.random() > 0.5 ? 20 + Math.random() * 60 : 0
                });
            }

            return shards;
        }

        function drawTitleScreen() {
            titleAnimTime += 0.016;

            // Generate shards once
            if (!glassShards) {
                glassShards = generateGlassShards();
            }

            const impactX = CONFIG.CANVAS_WIDTH * 0.55;
            const impactY = CONFIG.CANVAS_HEIGHT * 0.35;

            // === SCENE THROUGH THE WINDOW (the street below) ===
            // Night sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
            skyGrad.addColorStop(0, '#02020a');
            skyGrad.addColorStop(0.4, '#0a0815');
            skyGrad.addColorStop(1, '#151020');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 80; i++) {
                const sx = (i * 137 + 50) % CONFIG.CANVAS_WIDTH;
                const sy = (i * 73) % (CONFIG.CANVAS_HEIGHT * 0.5);
                const twinkle = Math.sin(titleAnimTime * 3 + i) * 0.5 + 0.5;
                ctx.globalAlpha = twinkle * 0.6;
                ctx.fillRect(sx, sy, 1 + (i % 2), 1 + (i % 2));
            }
            ctx.globalAlpha = 1;

            // Moon
            ctx.fillStyle = 'rgba(200, 195, 180, 0.1)';
            ctx.beginPath();
            ctx.arc(900, 80, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(230, 225, 210, 0.3)';
            ctx.beginPath();
            ctx.arc(900, 80, 25, 0, Math.PI * 2);
            ctx.fill();

            // Distant city skyline
            ctx.fillStyle = '#0a0a12';
            const farBuildings = [
                { x: 0, w: 80, h: 200 }, { x: 70, w: 60, h: 280 }, { x: 120, w: 100, h: 220 },
                { x: 210, w: 70, h: 320 }, { x: 270, w: 90, h: 250 }, { x: 350, w: 50, h: 350 },
                { x: 390, w: 110, h: 280 }, { x: 490, w: 80, h: 380 }, { x: 560, w: 100, h: 300 },
                { x: 650, w: 70, h: 260 }, { x: 710, w: 90, h: 340 }, { x: 790, w: 60, h: 290 },
                { x: 840, w: 100, h: 360 }, { x: 930, w: 80, h: 270 }, { x: 1000, w: 70, h: 310 },
                { x: 1060, w: 100, h: 240 }
            ];
            for (const b of farBuildings) {
                ctx.fillRect(b.x, CONFIG.CANVAS_HEIGHT - 80 - b.h, b.w, b.h + 80);
            }

            // Lit windows in buildings
            for (const b of farBuildings) {
                for (let row = 0; row < b.h / 25; row++) {
                    for (let col = 0; col < b.w / 15; col++) {
                        if (((row * 7 + col * 11 + b.x) % 6) < 2) {
                            const flicker = Math.sin(titleAnimTime * 2 + row + col + b.x) * 0.2 + 0.8;
                            ctx.fillStyle = `rgba(255, 220, 150, ${0.5 * flicker})`;
                            ctx.fillRect(b.x + 4 + col * 14, CONFIG.CANVAS_HEIGHT - 75 - b.h + row * 24, 6, 10);
                        }
                    }
                }
            }

            // Street far below
            ctx.fillStyle = '#0a0a0c';
            ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - 80, CONFIG.CANVAS_WIDTH, 80);

            // Street lights below (tiny from this height)
            for (let i = 0; i < 6; i++) {
                const lx = 100 + i * 180;
                ctx.fillStyle = 'rgba(255, 200, 100, 0.6)';
                ctx.beginPath();
                ctx.arc(lx, CONFIG.CANVAS_HEIGHT - 70, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(255, 200, 100, 0.15)';
                ctx.beginPath();
                ctx.arc(lx, CONFIG.CANVAS_HEIGHT - 60, 20, 0, Math.PI * 2);
                ctx.fill();
            }

            // Tiny car headlights moving
            const carX = (titleAnimTime * 60) % (CONFIG.CANVAS_WIDTH + 100) - 50;
            ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
            ctx.beginPath();
            ctx.arc(carX, CONFIG.CANVAS_HEIGHT - 55, 2, 0, Math.PI * 2);
            ctx.arc(carX + 8, CONFIG.CANVAS_HEIGHT - 55, 2, 0, Math.PI * 2);
            ctx.fill();

            // === WINDOW FRAME (dark apartment interior) ===
            // Darkness of the room we're in
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Window frame - thick dark wood
            const frameWidth = 35;
            ctx.fillStyle = '#1a1512';
            // Top frame
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, frameWidth);
            // Bottom frame
            ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - frameWidth, CONFIG.CANVAS_WIDTH, frameWidth);
            // Left frame
            ctx.fillRect(0, 0, frameWidth, CONFIG.CANVAS_HEIGHT);
            // Right frame
            ctx.fillRect(CONFIG.CANVAS_WIDTH - frameWidth, 0, frameWidth, CONFIG.CANVAS_HEIGHT);
            // Center vertical bar
            ctx.fillRect(CONFIG.CANVAS_WIDTH / 2 - 8, 0, 16, CONFIG.CANVAS_HEIGHT);
            // Center horizontal bar
            ctx.fillRect(0, CONFIG.CANVAS_HEIGHT / 2 - 8, CONFIG.CANVAS_WIDTH, 16);

            // Frame edge highlights
            ctx.strokeStyle = '#2a2520';
            ctx.lineWidth = 2;
            ctx.strokeRect(frameWidth, frameWidth, CONFIG.CANVAS_WIDTH - frameWidth * 2, CONFIG.CANVAS_HEIGHT - frameWidth * 2);

            // === SHATTERED GLASS ===
            // Draw cracks
            ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
            ctx.lineWidth = 2;
            for (const shard of glassShards) {
                if (shard.type === 'crack') {
                    ctx.beginPath();
                    ctx.moveTo(shard.x1, shard.y1);
                    ctx.lineTo(shard.x2, shard.y2);
                    ctx.stroke();

                    // Draw branches
                    ctx.lineWidth = 1;
                    for (const branch of shard.branches) {
                        ctx.beginPath();
                        ctx.moveTo(branch.x1, branch.y1);
                        ctx.lineTo(branch.x2, branch.y2);
                        ctx.stroke();
                    }
                    ctx.lineWidth = 2;
                }
            }

            // Draw glass fragments
            for (const shard of glassShards) {
                if (shard.type === 'fragment') {
                    if (shard.fallen) {
                        // Hole in glass - show dark void
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    } else {
                        // Glass with reflection
                        const reflectAlpha = 0.1 + shard.reflection * 0.15;
                        ctx.fillStyle = `rgba(180, 200, 220, ${reflectAlpha})`;
                    }
                    ctx.beginPath();
                    ctx.moveTo(shard.points[0].x, shard.points[0].y);
                    for (let i = 1; i < shard.points.length; i++) {
                        ctx.lineTo(shard.points[i].x, shard.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    if (!shard.fallen) {
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }

            // Impact point - spider web center
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(impactX, impactY, 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(impactX, impactY, 8, 0, Math.PI * 2);
            ctx.stroke();

            // Blood on the glass
            for (const shard of glassShards) {
                if (shard.type === 'blood') {
                    ctx.fillStyle = '#4a0a0a';
                    ctx.beginPath();
                    ctx.arc(shard.x, shard.y, shard.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Blood drip
                    if (shard.drip > 0) {
                        ctx.fillStyle = '#3a0808';
                        ctx.beginPath();
                        ctx.moveTo(shard.x - shard.size * 0.3, shard.y + shard.size * 0.5);
                        ctx.quadraticCurveTo(shard.x, shard.y + shard.drip * 0.5, shard.x - 1, shard.y + shard.drip);
                        ctx.quadraticCurveTo(shard.x, shard.y + shard.drip * 0.5, shard.x + shard.size * 0.3, shard.y + shard.size * 0.5);
                        ctx.fill();
                    }
                }
            }

            // Glass reflection overlay
            const glassGrad = ctx.createLinearGradient(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            glassGrad.addColorStop(0, 'rgba(150, 170, 200, 0.08)');
            glassGrad.addColorStop(0.5, 'rgba(150, 170, 200, 0.02)');
            glassGrad.addColorStop(1, 'rgba(150, 170, 200, 0.1)');
            ctx.fillStyle = glassGrad;
            ctx.fillRect(frameWidth, frameWidth, CONFIG.CANVAS_WIDTH - frameWidth * 2, CONFIG.CANVAS_HEIGHT - frameWidth * 2);

            // === TITLE ===
            // Title shadow (blood red undertone)
            ctx.save();
            ctx.shadowColor = 'rgba(80, 0, 0, 0.8)';
            ctx.shadowBlur = 30;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = '#1a0505';
            ctx.font = 'bold 130px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('NIGHTFALL', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 180);
            ctx.restore();

            // Main title - stark white against dark
            ctx.fillStyle = '#e8e0d0';
            ctx.font = 'bold 130px Bebas Neue';
            ctx.fillText('NIGHTFALL', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 180);

            // Subtitle
            ctx.fillStyle = '#8a7a6a';
            ctx.font = '18px Special Elite';
            ctx.fillText('A  NOIR  DETECTIVE  MYSTERY', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 130);

            // Year
            ctx.fillStyle = '#5a4a3a';
            ctx.font = '14px Special Elite';
            ctx.fillText('— 1959 —', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 100);

            // Prompt (pulsing, at bottom)
            const pulse = Math.sin(titleAnimTime * 2.5) * 0.4 + 0.6;
            ctx.globalAlpha = pulse;
            ctx.fillStyle = '#a09080';
            ctx.font = '16px Special Elite';
            ctx.fillText('PRESS  ANY  KEY  TO  BEGIN', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT - 55);
            ctx.globalAlpha = 1;

            // Atmospheric text at top
            ctx.fillStyle = 'rgba(100, 80, 60, 0.6)';
            ctx.font = '11px Special Elite';
            ctx.fillText('SOME WINDOWS ARE BETTER LEFT CLOSED', CONFIG.CANVAS_WIDTH / 2, 55);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        document.addEventListener('keydown', (e) => {
            if (game.state === 'title') {
                game.state = 'playing';
                document.getElementById('title-screen').classList.add('hidden');
                return;
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    if (!keys.interact) {
                        handleInteraction();
                    }
                    keys.interact = true;
                    break;
                case ' ':
                    keys.action = true;
                    break;
                case 'i':
                case 'I':
                    handleActionKey('interview');
                    break;
                case 's':
                case 'S':
                    if (!keys.down) { // S is also used for movement
                        handleActionKey('smack');
                    }
                    break;
                case 'g':
                case 'G':
                    handleActionKey('gun');
                    break;
                case 'Escape':
                    if (game.state === 'dialogue') {
                        endDialogue();
                    } else if (game.state === 'driving' && Math.abs(player.carSpeed) < 0.1) {
                        exitCar();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    keys.interact = false;
                    break;
                case ' ':
                    keys.action = false;
                    break;
            }
        });

        // Touch controls
        function setupTouchControl(id, key) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
            btn.addEventListener('mousedown', () => keys[key] = true);
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }

        setupTouchControl('d-up', 'up');
        setupTouchControl('d-down', 'down');
        setupTouchControl('d-left', 'left');
        setupTouchControl('d-right', 'right');

        document.getElementById('btn-interact').addEventListener('click', () => {
            handleInteraction();
            keys.interact = true;
            setTimeout(() => keys.interact = false, 100);
        });

        document.getElementById('btn-action').addEventListener('click', () => {
            keys.action = true;
            setTimeout(() => keys.action = false, 100);
        });

        // Click/tap to start
        document.getElementById('title-screen').addEventListener('click', () => {
            game.state = 'playing';
            document.getElementById('title-screen').classList.add('hidden');
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            // Position player on sidewalk in front of PI office
            player.x = 250;
            player.y = GROUND_LEVEL + 40; // On the sidewalk in front of buildings

            // Initialize world state
            initWorldState();

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>

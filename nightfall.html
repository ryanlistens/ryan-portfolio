<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NIGHTFALL - A Noir Detective Mystery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&family=Bebas+Neue&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
        }

        #game-canvas {
            background: #0d0d0d;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Film grain overlay */
        #film-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.08;
            z-index: 100;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Vignette effect */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.7) 100%);
        }

        /* Scanlines */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 98;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #hud .stat {
            margin-bottom: 8px;
            font-size: 14px;
            letter-spacing: 1px;
        }

        #hud .label {
            color: #8b7355;
            text-transform: uppercase;
            font-size: 10px;
        }

        #hud .value {
            color: #e8d5b7;
            font-size: 16px;
        }

        /* Location indicator */
        #location-display {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 4px;
            color: #d4c5a9;
            text-shadow: 0 0 20px rgba(212, 197, 169, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #location-display.visible {
            opacity: 1;
        }

        /* Time display */
        #time-display {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            text-align: right;
        }

        #time-display .time {
            font-size: 28px;
            color: #e8d5b7;
            text-shadow: 0 0 10px rgba(232, 213, 183, 0.3);
        }

        #time-display .date {
            font-size: 12px;
            color: #8b7355;
            letter-spacing: 2px;
        }

        /* Controls */
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(30, 25, 20, 0.8);
            border: 1px solid #3d3428;
            color: #8b7355;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        .d-btn:hover, .d-btn:active {
            background: rgba(60, 50, 40, 0.9);
            color: #d4c5a9;
        }

        #d-up { top: 0; left: 40px; border-radius: 8px 8px 0 0; }
        #d-down { bottom: 0; left: 40px; border-radius: 0 0 8px 8px; }
        #d-left { top: 40px; left: 0; border-radius: 8px 0 0 8px; }
        #d-right { top: 40px; right: 0; border-radius: 0 8px 8px 0; }
        #d-center { top: 40px; left: 40px; background: rgba(20, 16, 12, 0.9); cursor: default; }

        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(139, 69, 19, 0.6);
            border: 2px solid #8b7355;
            color: #d4c5a9;
            font-family: 'Special Elite', monospace;
            font-size: 10px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .action-btn:hover, .action-btn:active {
            background: rgba(180, 100, 40, 0.7);
            transform: scale(1.05);
        }

        /* Title screen */
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        #title-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #title-screen h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 120px;
            letter-spacing: 20px;
            color: #d4c5a9;
            text-shadow:
                0 0 40px rgba(212, 197, 169, 0.3),
                0 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }

        #title-screen .subtitle {
            font-family: 'Special Elite', monospace;
            font-size: 16px;
            letter-spacing: 8px;
            color: #8b7355;
            margin-bottom: 60px;
        }

        #title-screen .year {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 48px;
            color: #3d3428;
            letter-spacing: 15px;
            margin-bottom: 80px;
        }

        #title-screen .start-prompt {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            letter-spacing: 4px;
            color: #8b7355;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Dialogue box */
        #dialogue-box {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
            background: rgba(15, 12, 10, 0.95);
            border: 1px solid #3d3428;
            padding: 20px 25px;
            z-index: 60;
            display: none;
        }

        #dialogue-box.visible {
            display: block;
        }

        #dialogue-speaker {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 3px;
            color: #c4a35a;
            margin-bottom: 10px;
        }

        #dialogue-text {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #d4c5a9;
        }

        /* Interaction prompt */
        #interact-prompt {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Special Elite', monospace;
            font-size: 12px;
            letter-spacing: 2px;
            color: #c4a35a;
            background: rgba(15, 12, 10, 0.8);
            padding: 8px 16px;
            border: 1px solid #3d3428;
            z-index: 55;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #interact-prompt.visible {
            opacity: 1;
        }

        /* Mini map */
        #minimap {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 150px;
            height: 120px;
            background: rgba(15, 12, 10, 0.8);
            border: 1px solid #3d3428;
            z-index: 50;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            #title-screen h1 {
                font-size: 60px;
                letter-spacing: 10px;
            }

            #title-screen .year {
                font-size: 32px;
            }

            #minimap {
                width: 100px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- Film effects -->
        <div id="film-grain"></div>
        <div id="vignette"></div>
        <div id="scanlines"></div>

        <!-- Title Screen -->
        <div id="title-screen">
            <h1>NIGHTFALL</h1>
            <div class="subtitle">A NOIR DETECTIVE MYSTERY</div>
            <div class="year">1 9 5 9</div>
            <div class="start-prompt">PRESS ANY KEY TO BEGIN</div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div class="stat">
                <div class="label">Cash</div>
                <div class="value" id="cash-display">$50.00</div>
            </div>
            <div class="stat">
                <div class="label">Reputation</div>
                <div class="value" id="rep-display">■■■□□</div>
            </div>
            <div class="stat">
                <div class="label">Case</div>
                <div class="value" id="case-display">None</div>
            </div>
        </div>

        <!-- Time -->
        <div id="time-display">
            <div class="date">OCTOBER 14, 1959</div>
            <div class="time" id="clock">8:47 PM</div>
        </div>

        <!-- Location -->
        <div id="location-display">DOWNTOWN</div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <!-- Interaction prompt -->
        <div id="interact-prompt">[E] ENTER</div>

        <!-- Dialogue -->
        <div id="dialogue-box">
            <div id="dialogue-speaker">STRANGER</div>
            <div id="dialogue-text">The night has a way of revealing what the day keeps hidden...</div>
        </div>

        <!-- Controls -->
        <div id="controls">
            <div id="d-pad">
                <div class="d-btn" id="d-up">▲</div>
                <div class="d-btn" id="d-down">▼</div>
                <div class="d-btn" id="d-left">◄</div>
                <div class="d-btn" id="d-right">►</div>
                <div class="d-btn" id="d-center"></div>
            </div>
            <button class="action-btn" id="btn-interact">Enter</button>
            <button class="action-btn" id="btn-action">Action</button>
        </div>
    </div>

    <script>
        // ============================================
        // NIGHTFALL - A Noir Detective Mystery
        // Set in 1959 small-town America
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Game configuration
        const CONFIG = {
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 700,
            TILE_SIZE: 60,
            PLAYER_SPEED: 3,
            CAR_SPEED: 8,
            GAME_SPEED: 1, // Time multiplier
            SHADOW_LENGTH: 2.5,
            AMBIENT_LIGHT: 0.15
        };

        // Set canvas size
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;
        minimapCanvas.width = 150;
        minimapCanvas.height = 120;

        // Color palette - 1959 Noir
        const COLORS = {
            // Sky and atmosphere
            nightSky: '#0a0a14',
            twilightSky: '#1a1a2e',
            duskSky: '#2d1f3d',

            // Buildings
            brick: '#3d2b1f',
            brickDark: '#2a1d15',
            brickLight: '#4a3828',
            concrete: '#4a4a4a',
            concreteDark: '#333333',
            wood: '#5c4033',
            woodDark: '#3d2a22',

            // Windows and lights
            windowLit: '#e8c36a',
            windowDim: '#8b7355',
            windowDark: '#1a1a1a',
            neonRed: '#ff3333',
            neonBlue: '#3366ff',
            neonGreen: '#33ff66',
            streetLight: '#ffedcc',

            // Ground
            asphalt: '#2a2a2a',
            asphaltLight: '#3a3a3a',
            sidewalk: '#5a5a5a',
            sidewalkLight: '#6a6a6a',

            // Characters
            skin: '#d4a574',
            skinShadow: '#a67c52',
            suit: '#1a1a1a',
            suitGray: '#3d3d3d',
            hat: '#2a2a2a',

            // UI
            gold: '#c4a35a',
            cream: '#d4c5a9',
            shadow: 'rgba(0,0,0,0.7)'
        };

        // Game state
        const game = {
            state: 'title', // title, playing, dialogue, inventory, paused
            currentLevel: 1, // 1: Downtown, 2: Residential, 3: Industrial
            time: { hours: 20, minutes: 47 }, // 8:47 PM
            day: 1,
            cash: 50.00,
            reputation: 3, // 1-5
            currentCase: null,
            killerSchedule: [],
            killerStrikeTime: null
        };

        // Player state
        const player = {
            x: 600,
            y: 400,
            width: 24,
            height: 64,
            speed: CONFIG.PLAYER_SPEED,
            direction: 'right', // up, down, left, right
            facing: 1, // 1 = right, -1 = left
            isMoving: false,
            walkCycle: 0,
            inCar: false,
            car: null,
            inventory: [],
            weapon: 'fists', // fists, pistol
            flashlightOn: false
        };

        // ============================================
        // OBJECT PERMANENCY SYSTEM
        // ============================================
        const worldState = {
            // Window states persist - seeded by building ID
            windowStates: {},
            // NPC positions and states persist
            npcStates: {},
            // Props placed in world
            props: [],
            // Items dropped/placed
            items: [],
            // Doors opened/closed
            doorStates: {},
            // Events that have occurred
            events: [],
            initialized: false
        };

        // Initialize persistent world state
        function initWorldState() {
            if (worldState.initialized) return;

            // Generate consistent window states for each building
            currentMap.buildings.forEach(building => {
                const windowCount = Math.floor((building.width - 40) / 50) * building.floors;
                worldState.windowStates[building.id] = [];

                // Use building position as seed for consistency
                let seed = building.x * 100 + building.y;
                for (let i = 0; i < windowCount; i++) {
                    seed = (seed * 9301 + 49297) % 233280;
                    worldState.windowStates[building.id].push({
                        lit: (seed / 233280) > 0.35,
                        blindsDown: (seed / 233280) > 0.6,
                        silhouette: (seed / 233280) > 0.85 ? 'person' : null
                    });
                }
            });

            // Initialize NPC states with persistent positions
            npcs.forEach(npc => {
                worldState.npcStates[npc.id] = {
                    x: npc.x,
                    y: npc.y,
                    activity: 'idle',
                    facingRight: true,
                    talked: false,
                    bribed: false,
                    lastInteraction: null
                };
            });

            // Add street props - positioned on sidewalk (GROUND_LEVEL area)
            const sidewalkY = GROUND_LEVEL + 20; // Props sit on sidewalk

            worldState.props = [
                // Phone booths (tall, near curb)
                { type: 'phonebooth', x: 440, y: sidewalkY - 60 },
                { type: 'phonebooth', x: 1100, y: sidewalkY - 60 },
                { type: 'phonebooth', x: 1750, y: sidewalkY - 60 },
                // Benches (facing street)
                { type: 'bench', x: 180, y: sidewalkY - 22 },
                { type: 'bench', x: 560, y: sidewalkY - 22 },
                { type: 'bench', x: 1020, y: sidewalkY - 22 },
                { type: 'bench', x: 1550, y: sidewalkY - 22 },
                { type: 'bench', x: 2000, y: sidewalkY - 22 },
                // Trash cans (near light poles)
                { type: 'trashcan', x: 170, y: sidewalkY - 24 },
                { type: 'trashcan', x: 420, y: sidewalkY - 24 },
                { type: 'trashcan', x: 670, y: sidewalkY - 24 },
                { type: 'trashcan', x: 920, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1170, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1420, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1720, y: sidewalkY - 24 },
                { type: 'trashcan', x: 1970, y: sidewalkY - 24 },
                // Fire hydrants (on curb edge)
                { type: 'hydrant', x: 260, y: sidewalkY - 22 },
                { type: 'hydrant', x: 700, y: sidewalkY - 22 },
                { type: 'hydrant', x: 1250, y: sidewalkY - 22 },
                { type: 'hydrant', x: 1650, y: sidewalkY - 22 },
                { type: 'hydrant', x: 2050, y: sidewalkY - 22 },
                // Newspaper stands
                { type: 'newsstand', x: 350, y: sidewalkY - 32 },
                { type: 'newsstand', x: 850, y: sidewalkY - 32 },
                { type: 'newsstand', x: 1500, y: sidewalkY - 32 },
                // Mailboxes
                { type: 'mailbox', x: 500, y: sidewalkY - 35 },
                { type: 'mailbox', x: 980, y: sidewalkY - 35 },
                { type: 'mailbox', x: 1600, y: sidewalkY - 35 },
                { type: 'mailbox', x: 2100, y: sidewalkY - 35 },
                // Street signs (at intersections)
                { type: 'streetsign', x: 50, y: sidewalkY - 50, text: 'MAIN ST' },
                { type: 'streetsign', x: 1200, y: sidewalkY - 50, text: 'ELM AVE' },
                { type: 'streetsign', x: 2000, y: sidewalkY - 50, text: 'OAK ST' }
            ];

            worldState.initialized = true;
        }

        // Camera
        const camera = {
            x: 0,
            y: 0,
            width: CONFIG.CANVAS_WIDTH,
            height: CONFIG.CANVAS_HEIGHT
        };

        // Input state
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            interact: false,
            action: false
        };

        // Ground level constant - buildings sit on this
        const GROUND_LEVEL = 410;
        const STREET_TOP = GROUND_LEVEL + 58;
        const STREET_BOTTOM = STREET_TOP + 120;

        // Town map - Level 1: Downtown
        const DOWNTOWN = {
            width: 2400,
            height: 800,
            name: 'DOWNTOWN',
            buildings: [
                // Office Building (with PI office, accountant, attorney)
                {
                    id: 'office_building',
                    x: 80, y: 180,
                    width: 350, height: 230,
                    type: 'office',
                    name: "PROFESSIONAL BUILDING",
                    floors: 2,
                    color: '#4a3828',
                    offices: [
                        { name: "MILLER & ASSOCIATES\nTAX ACCOUNTANT", x: 0, door: true },
                        { name: "JAMES CRAWFORD\nATTORNEY AT LAW", x: 1, door: true },
                        { name: "JACK NOIR\nPRIVATE INVESTIGATOR", x: 2, door: true, isPlayerOffice: true }
                    ],
                    enterable: true,
                    interiorId: 'pi_office'
                },

                // Cafe
                {
                    id: 'cafe',
                    x: 480, y: 210,
                    width: 200, height: 200,
                    type: 'cafe',
                    name: "ROSIE'S DINER",
                    floors: 1,
                    color: '#5a4838',
                    hasNeon: true,
                    neonText: "OPEN 24 HRS",
                    neonColor: COLORS.neonRed,
                    enterable: true,
                    interiorId: 'cafe'
                },

                // Pharmacy
                {
                    id: 'pharmacy',
                    x: 730, y: 200,
                    width: 180, height: 210,
                    type: 'pharmacy',
                    name: "COLEMAN'S PHARMACY",
                    floors: 1,
                    color: '#4a4a4a',
                    hasNeon: true,
                    neonText: "Rx",
                    neonColor: COLORS.neonGreen,
                    enterable: true,
                    interiorId: 'pharmacy'
                },

                // Bookstore
                {
                    id: 'bookstore',
                    x: 960, y: 220,
                    width: 170, height: 190,
                    type: 'bookstore',
                    name: "CHAPTER & VERSE",
                    floors: 1,
                    color: '#5c4033',
                    enterable: true,
                    interiorId: 'bookstore'
                },

                // Bar
                {
                    id: 'bar',
                    x: 1180, y: 190,
                    width: 220, height: 220,
                    type: 'bar',
                    name: "THE BLUE MOON",
                    floors: 1,
                    color: '#2a1d15',
                    hasNeon: true,
                    neonText: "COCKTAILS",
                    neonColor: COLORS.neonBlue,
                    enterable: true,
                    interiorId: 'bar'
                },

                // Movie Theater
                {
                    id: 'theater',
                    x: 1450, y: 130,
                    width: 320, height: 280,
                    type: 'theater',
                    name: "PARAMOUNT THEATER",
                    floors: 2,
                    color: '#3a3a3a',
                    marquee: true,
                    nowPlaying: ["NORTH BY NORTHWEST", "THE NUN'S STORY"],
                    enterable: true,
                    interiorId: 'theater'
                },

                // Police Station
                {
                    id: 'police',
                    x: 1820, y: 160,
                    width: 260, height: 250,
                    type: 'police',
                    name: "POLICE DEPT",
                    floors: 2,
                    color: '#3d3d3d',
                    enterable: true,
                    interiorId: 'police'
                },

                // Apartment Building
                {
                    id: 'apartments',
                    x: 2130, y: 80,
                    width: 180, height: 330,
                    type: 'apartment',
                    name: "LAKESIDE APTS",
                    floors: 3,
                    color: '#4a3020',
                    apartments: [
                        { floor: 1, resident: "Mrs. Henderson" },
                        { floor: 2, resident: "Frank Torres" },
                        { floor: 3, resident: "Empty" }
                    ],
                    enterable: true,
                    interiorId: 'apartments'
                }
            ],

            // Street lights - positioned on sidewalk
            streetLights: [
                { x: 150, y: 355 },
                { x: 400, y: 355 },
                { x: 650, y: 355 },
                { x: 900, y: 355 },
                { x: 1150, y: 355 },
                { x: 1400, y: 355 },
                { x: 1700, y: 355 },
                { x: 1950, y: 355 },
                { x: 2200, y: 355 }
            ],

            // Parked cars - on the street
            cars: [
                { x: 200, y: 490, color: '#2a3d2a', model: 'sedan', canEnter: false },
                { x: 380, y: 490, color: '#4a2a2a', model: 'coupe', canEnter: false },
                { x: 600, y: 490, color: '#1a1a2a', model: 'sedan', canEnter: true }, // Player's car
                { x: 850, y: 490, color: '#3d3d3d', model: 'sedan', canEnter: false },
                { x: 1100, y: 490, color: '#2a2a3d', model: 'coupe', canEnter: false },
                { x: 1350, y: 490, color: '#3d2a2a', model: 'sedan', canEnter: false },
                { x: 1650, y: 490, color: '#2a3a2a', model: 'sedan', canEnter: false },
                { x: 1900, y: 490, color: '#3a3a3a', model: 'truck', canEnter: false },
                { x: 2150, y: 490, color: '#2a2a2a', model: 'sedan', canEnter: false }
            ],

            // Collision rectangles for solid objects
            colliders: [
                // Buildings block movement
                { x: 80, y: 180, width: 350, height: 235 },
                { x: 480, y: 210, width: 200, height: 205 },
                { x: 730, y: 200, width: 180, height: 215 },
                { x: 960, y: 220, width: 170, height: 195 },
                { x: 1180, y: 190, width: 220, height: 225 },
                { x: 1450, y: 130, width: 320, height: 285 },
                { x: 1820, y: 160, width: 260, height: 255 },
                { x: 2130, y: 80, width: 180, height: 335 }
            ],

            // NPCs on streets
            streetNPCs: []
        };

        // Current level reference
        let currentMap = DOWNTOWN;

        // NPCs
        const npcs = [
            // Cafe staff
            { id: 'waitress', name: 'Rosie', location: 'cafe', role: 'owner', x: 600, y: 280,
              dialogue: ["Coffee's hot, stranger.", "You look like you could use a cup."] },
            { id: 'cook', name: 'Earl', location: 'cafe', role: 'cook', x: 650, y: 300,
              dialogue: ["Order up!", "Kitchen's closing in an hour."] },

            // Pharmacy
            { id: 'pharmacist', name: 'Mr. Coleman', location: 'pharmacy', role: 'pharmacist', x: 900, y: 280,
              dialogue: ["Can I help you find something?", "Prescription ready in 10 minutes."] },

            // Bookstore
            { id: 'bookstore_husband', name: 'Harold', location: 'bookstore', role: 'owner', x: 1150, y: 280,
              dialogue: ["Looking for anything in particular?", "New shipment of mysteries came in."] },
            { id: 'bookstore_wife', name: 'Margaret', location: 'bookstore', role: 'owner', x: 1200, y: 300,
              dialogue: ["The poetry section is in the back.", "Harold, we have a customer."] },

            // Bar
            { id: 'bartender', name: 'Mickey', location: 'bar', role: 'bartender', x: 180, y: 620,
              dialogue: ["What'll it be?", "We don't want any trouble here."], canBeBribed: true },
            { id: 'barfly1', name: 'Old Joe', location: 'bar', role: 'patron', x: 220, y: 650,
              dialogue: ["*mumbles*", "Buy me a drink and I'll tell you something."], canBeBribed: true },

            // Theater
            { id: 'box_office', name: 'Betty', location: 'theater', role: 'employee', x: 550, y: 600,
              dialogue: ["Two screens tonight. Hitchcock or Hepburn?", "Show starts in fifteen."] },

            // Police
            { id: 'desk_sergeant', name: 'Sgt. O\'Brien', location: 'police', role: 'police', x: 1000, y: 620,
              dialogue: ["State your business.", "This is a police station, not a social club."] },

            // PI Office
            { id: 'secretary', name: 'Dolores', location: 'pi_office', role: 'secretary', x: 250, y: 280,
              dialogue: ["A client is waiting, Mr. Noir.", "The phone's been ringing all day."] }
        ];

        // Killer AI
        const killer = {
            id: 'the_stranger',
            currentLocation: 'bar',
            schedule: [
                { time: '19:00', location: 'cafe', action: 'eating' },
                { time: '20:30', location: 'bar', action: 'drinking' },
                { time: '22:00', location: 'street', action: 'stalking' },
                { time: '23:30', location: 'apartments', action: 'hunting' }
            ],
            urgeLevel: 0, // 0-100
            targetNPC: null,
            state: 'normal', // normal, agitated, hunting, attacking
            visible: true, // Blends in as normal NPC
            disguise: 'businessman'
        };

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);

            // Night sky gradient
            if (game.time.hours >= 21 || game.time.hours < 5) {
                gradient.addColorStop(0, '#050510');
                gradient.addColorStop(0.5, '#0a0a1a');
                gradient.addColorStop(1, '#0f0f20');
            } else if (game.time.hours >= 18) {
                // Dusk
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.3, '#2d1f3d');
                gradient.addColorStop(0.7, '#3d2a4a');
                gradient.addColorStop(1, '#1a1a2e');
            } else {
                // Day (we'll mostly be in evening/night)
                gradient.addColorStop(0, '#4a4a6e');
                gradient.addColorStop(1, '#2a2a4e');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Stars (at night)
            if (game.time.hours >= 20 || game.time.hours < 5) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 47 + camera.x * 0.1) % CONFIG.CANVAS_WIDTH;
                    const y = (i * 31) % (CONFIG.CANVAS_HEIGHT * 0.4);
                    const size = (i % 3) * 0.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawGround() {
            // World coordinates for ground elements
            const worldLeft = camera.x;
            const worldRight = camera.x + CONFIG.CANVAS_WIDTH;

            // Fixed Y positions in screen space (buildings sit on this)
            const sidewalkTopY = 410;  // Where buildings meet ground
            const curbTopY = sidewalkTopY + 50;  // Top curb
            const streetY = curbTopY + 8;  // Street surface
            const streetBottomY = streetY + 120;  // Bottom of street
            const curbBottomY = streetBottomY;  // Bottom curb
            const sidewalkBottomY = curbBottomY + 8;  // Bottom sidewalk start

            // === TOP SIDEWALK (where player walks in front of buildings) ===
            // Concrete base
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, sidewalkTopY, CONFIG.CANVAS_WIDTH, 50);

            // Concrete texture - expansion joints
            ctx.strokeStyle = '#4a4642';
            ctx.lineWidth = 2;
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                ctx.beginPath();
                ctx.moveTo(x, sidewalkTopY);
                ctx.lineTo(x, sidewalkTopY + 50);
                ctx.stroke();
            }

            // Sidewalk surface detail - slight color variation for slabs
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                const shade = ((x + camera.x) * 7) % 20 - 10;
                ctx.fillStyle = `rgb(${90 + shade}, ${86 + shade}, ${82 + shade})`;
                ctx.fillRect(x + 2, sidewalkTopY + 2, 76, 46);
            }

            // === TOP CURB ===
            // Curb face (vertical)
            ctx.fillStyle = '#6a6662';
            ctx.fillRect(0, curbTopY, CONFIG.CANVAS_WIDTH, 8);

            // Curb top edge highlight
            ctx.fillStyle = '#7a7672';
            ctx.fillRect(0, curbTopY, CONFIG.CANVAS_WIDTH, 2);

            // Curb shadow
            ctx.fillStyle = '#3a3632';
            ctx.fillRect(0, curbTopY + 6, CONFIG.CANVAS_WIDTH, 2);

            // === GUTTER ===
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, streetY - 3, CONFIG.CANVAS_WIDTH, 3);

            // === STREET SURFACE ===
            // Base asphalt - darker, solid
            ctx.fillStyle = '#1f1f1f';
            ctx.fillRect(0, streetY, CONFIG.CANVAS_WIDTH, 120);

            // Asphalt texture - aggregate spots
            ctx.fillStyle = '#2a2a2a';
            for (let i = 0; i < 200; i++) {
                const seed = (i * 1337 + Math.floor(camera.x / 10)) % 10000;
                const x = (seed * 7) % CONFIG.CANVAS_WIDTH;
                const y = streetY + (seed * 13) % 120;
                const size = (seed % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }

            // Darker patches (oil stains, wear)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            for (let i = 0; i < 8; i++) {
                const seed = (i * 2341 + Math.floor(camera.x / 50)) % 10000;
                const x = (seed * 17) % CONFIG.CANVAS_WIDTH;
                const y = streetY + 20 + (seed * 7) % 80;
                ctx.beginPath();
                ctx.ellipse(x, y, 15 + (seed % 20), 8 + (seed % 10), 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Center line - yellow dashed
            ctx.strokeStyle = '#8a7a2a';
            ctx.lineWidth = 3;
            ctx.setLineDash([40, 30]);
            ctx.beginPath();
            ctx.moveTo(0, streetY + 60);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 60);
            ctx.stroke();
            ctx.setLineDash([]);

            // Edge lines - white solid
            ctx.strokeStyle = '#4a4a4a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, streetY + 8);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 8);
            ctx.moveTo(0, streetY + 112);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, streetY + 112);
            ctx.stroke();

            // === BOTTOM GUTTER ===
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, streetBottomY, CONFIG.CANVAS_WIDTH, 3);

            // === BOTTOM CURB ===
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(0, curbBottomY, CONFIG.CANVAS_WIDTH, 8);
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, curbBottomY, CONFIG.CANVAS_WIDTH, 2);

            // === BOTTOM SIDEWALK ===
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(0, sidewalkBottomY, CONFIG.CANVAS_WIDTH, 60);

            // Expansion joints
            ctx.strokeStyle = '#4a4642';
            ctx.lineWidth = 2;
            for (let x = -camera.x % 80; x < CONFIG.CANVAS_WIDTH; x += 80) {
                ctx.beginPath();
                ctx.moveTo(x, sidewalkBottomY);
                ctx.lineTo(x, sidewalkBottomY + 60);
                ctx.stroke();
            }

            // Bottom sidewalk fades to edge of screen
            const bottomGradient = ctx.createLinearGradient(0, sidewalkBottomY + 40, 0, CONFIG.CANVAS_HEIGHT);
            bottomGradient.addColorStop(0, '#5a5652');
            bottomGradient.addColorStop(1, '#2a2622');
            ctx.fillStyle = bottomGradient;
            ctx.fillRect(0, sidewalkBottomY + 40, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT - sidewalkBottomY - 40);
        }

        function drawBuilding(building) {
            const bx = building.x - camera.x;
            const by = building.y - camera.y;
            const groundLevel = 410; // Where buildings meet sidewalk

            // Skip if off screen
            if (bx + building.width < -50 || bx > CONFIG.CANVAS_WIDTH + 50) return;

            // === BUILDING SHADOW (cast on ground) ===
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.moveTo(bx + building.width, groundLevel);
            ctx.lineTo(bx + building.width + 30, groundLevel);
            ctx.lineTo(bx + building.width + 30, groundLevel + 15);
            ctx.lineTo(bx + building.width, groundLevel + 15);
            ctx.closePath();
            ctx.fill();

            // === FOUNDATION ===
            ctx.fillStyle = '#2a2622';
            ctx.fillRect(bx - 3, groundLevel - 15, building.width + 6, 18);
            // Foundation top edge
            ctx.fillStyle = '#3a3632';
            ctx.fillRect(bx - 3, groundLevel - 15, building.width + 6, 3);

            // === MAIN BUILDING STRUCTURE ===
            // Side depth (3D effect) - left side darker
            ctx.fillStyle = adjustBrightness(building.color, 0.6);
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(bx - 8, by + 8);
            ctx.lineTo(bx - 8, groundLevel - 12);
            ctx.lineTo(bx, groundLevel - 15);
            ctx.closePath();
            ctx.fill();

            // Main facade
            ctx.fillStyle = building.color;
            ctx.fillRect(bx, by, building.width, groundLevel - 15 - by);

            // === BRICK/MATERIAL TEXTURE ===
            if (building.type !== 'theater') {
                // Brick pattern with proper mortar lines
                const brickHeight = 12;
                const brickWidth = 28;
                const mortarColor = adjustBrightness(building.color, 0.7);

                // Horizontal mortar lines
                ctx.strokeStyle = mortarColor;
                ctx.lineWidth = 1;
                for (let row = by + brickHeight; row < groundLevel - 15; row += brickHeight) {
                    ctx.beginPath();
                    ctx.moveTo(bx, row);
                    ctx.lineTo(bx + building.width, row);
                    ctx.stroke();
                }

                // Vertical mortar lines (staggered)
                let rowNum = 0;
                for (let row = by; row < groundLevel - 15; row += brickHeight) {
                    const offset = (rowNum % 2) * (brickWidth / 2);
                    for (let col = offset; col < building.width; col += brickWidth) {
                        ctx.beginPath();
                        ctx.moveTo(bx + col, row);
                        ctx.lineTo(bx + col, row + brickHeight);
                        ctx.stroke();
                    }
                    rowNum++;
                }

                // Subtle brick color variation
                for (let row = by; row < groundLevel - 20; row += brickHeight) {
                    const offset = ((row - by) / brickHeight % 2) * (brickWidth / 2);
                    for (let col = offset; col < building.width - brickWidth; col += brickWidth) {
                        const variation = ((row * 7 + col * 13) % 30) - 15;
                        if (Math.abs(variation) > 8) {
                            ctx.fillStyle = `rgba(${variation > 0 ? 255 : 0}, ${variation > 0 ? 255 : 0}, ${variation > 0 ? 255 : 0}, 0.05)`;
                            ctx.fillRect(bx + col + 1, row + 1, brickWidth - 2, brickHeight - 2);
                        }
                    }
                }
            }

            // === AWNING (for shops) ===
            if (['cafe', 'pharmacy', 'bookstore', 'bar'].includes(building.type)) {
                const awningY = by + building.height * 0.65;
                const awningDepth = 25;

                // Awning frame shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(bx + 10, awningY + awningDepth, building.width - 20, 8);

                // Awning top
                ctx.fillStyle = building.type === 'cafe' ? '#8b2020' :
                               building.type === 'bar' ? '#20208b' :
                               building.type === 'pharmacy' ? '#208b20' : '#5a4030';
                ctx.beginPath();
                ctx.moveTo(bx + 10, awningY);
                ctx.lineTo(bx + building.width - 10, awningY);
                ctx.lineTo(bx + building.width - 10 + awningDepth * 0.3, awningY + awningDepth);
                ctx.lineTo(bx + 10 - awningDepth * 0.3, awningY + awningDepth);
                ctx.closePath();
                ctx.fill();

                // Awning stripes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 8;
                for (let i = 0; i < 6; i++) {
                    const x = bx + 30 + i * ((building.width - 40) / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, awningY + 2);
                    ctx.lineTo(x + awningDepth * 0.2, awningY + awningDepth - 2);
                    ctx.stroke();
                }

                // Awning edge
                ctx.fillStyle = adjustBrightness(building.type === 'cafe' ? '#8b2020' : '#5a4030', 0.7);
                ctx.fillRect(bx + 10 - awningDepth * 0.3, awningY + awningDepth - 3, building.width - 20 + awningDepth * 0.6, 5);
            }

            // === CORNICE (roof detail) ===
            // Decorative top edge
            ctx.fillStyle = adjustBrightness(building.color, 1.2);
            ctx.fillRect(bx - 2, by - 8, building.width + 4, 10);
            ctx.fillRect(bx - 4, by - 3, building.width + 8, 5);

            // Cornice shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by + 2, building.width, 4);

            // === PARAPET (roof wall) ===
            ctx.fillStyle = adjustBrightness(building.color, 0.9);
            ctx.fillRect(bx, by - 20, building.width, 15);

            // Windows
            drawBuildingWindows(building, bx, by);

            // Door
            drawBuildingDoor(building, bx, groundLevel);

            // Sign/Name
            drawBuildingSign(building, bx, by);

            // Neon sign if applicable
            if (building.hasNeon) {
                drawNeonSign(building, bx, by);
            }

            // Theater marquee
            if (building.marquee) {
                drawTheaterMarquee(building, bx, by);
            }
        }

        function drawBuildingWindows(building, bx, by) {
            const windowWidth = 35;
            const windowHeight = 45;
            const windowSpacing = 50;
            const windowsPerFloor = Math.floor((building.width - 40) / windowSpacing);
            const floorHeight = building.height / building.floors;

            // Get persistent window states for this building
            const windowStates = worldState.windowStates[building.id] || [];

            let windowIndex = 0;
            for (let floor = 0; floor < building.floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    const wx = bx + 30 + w * windowSpacing;
                    const wy = by + 30 + floor * floorHeight;

                    // Get this window's persistent state
                    const state = windowStates[windowIndex] || { lit: false, blindsDown: false, silhouette: null };
                    windowIndex++;

                    // Window frame (deeper recess)
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(wx - 2, wy - 2, windowWidth + 4, windowHeight + 4);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(wx, wy, windowWidth, windowHeight);

                    if (state.lit) {
                        // Warm interior light gradient
                        const gradient = ctx.createLinearGradient(wx, wy, wx, wy + windowHeight);
                        gradient.addColorStop(0, '#f0d890');
                        gradient.addColorStop(0.5, COLORS.windowLit);
                        gradient.addColorStop(1, COLORS.windowDim);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Window glow (subtle)
                        ctx.shadowColor = COLORS.windowLit;
                        ctx.shadowBlur = 12;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);
                        ctx.shadowBlur = 0;

                        // Blinds (if down - persistent)
                        if (state.blindsDown) {
                            ctx.fillStyle = 'rgba(180, 160, 120, 0.7)';
                            ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 8);

                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                            ctx.lineWidth = 1;
                            for (let b = 0; b < 6; b++) {
                                ctx.beginPath();
                                ctx.moveTo(wx + 2, wy + 6 + b * 6);
                                ctx.lineTo(wx + windowWidth - 2, wy + 6 + b * 6);
                                ctx.stroke();
                            }
                        }

                        // Silhouette in window (persistent)
                        if (state.silhouette === 'person' && !state.blindsDown) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            // Head
                            ctx.beginPath();
                            ctx.arc(wx + windowWidth/2, wy + 15, 6, 0, Math.PI * 2);
                            ctx.fill();
                            // Shoulders
                            ctx.beginPath();
                            ctx.moveTo(wx + windowWidth/2 - 10, wy + 35);
                            ctx.lineTo(wx + windowWidth/2 - 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 10, wy + 35);
                            ctx.closePath();
                            ctx.fill();
                        }
                    } else {
                        // Dark window with subtle reflection
                        ctx.fillStyle = COLORS.windowDark;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Night sky reflection
                        ctx.fillStyle = 'rgba(30, 30, 50, 0.5)';
                        ctx.fillRect(wx + 3, wy + 3, windowWidth - 6, windowHeight / 3);
                    }

                    // Window cross frame
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(wx + windowWidth / 2, wy);
                    ctx.lineTo(wx + windowWidth / 2, wy + windowHeight);
                    ctx.moveTo(wx, wy + windowHeight / 2);
                    ctx.lineTo(wx + windowWidth, wy + windowHeight / 2);
                    ctx.stroke();

                    // Window sill
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(wx - 2, wy + windowHeight, windowWidth + 4, 3);
                }
            }
        }

        function drawBuildingDoor(building, bx, groundLevel) {
            const doorWidth = 45;
            const doorHeight = 75;
            const doorX = bx + building.width / 2 - doorWidth / 2;
            const doorY = groundLevel - 15 - doorHeight;

            // Check if player is near door for highlight
            const playerNearDoor = Math.abs(player.x - camera.x - doorX - doorWidth/2) < 40 &&
                                   Math.abs(player.y - camera.y - groundLevel + 30) < 50;

            // === DOOR RECESS (depth) ===
            ctx.fillStyle = '#0a0805';
            ctx.fillRect(doorX - 8, doorY - 5, doorWidth + 16, doorHeight + 8);

            // Recess sides (3D depth)
            ctx.fillStyle = '#1a1510';
            ctx.fillRect(doorX - 8, doorY - 5, 6, doorHeight + 8);
            ctx.fillRect(doorX + doorWidth + 2, doorY - 5, 6, doorHeight + 8);

            // === DOOR FRAME ===
            ctx.fillStyle = '#2a2015';
            ctx.fillRect(doorX - 3, doorY - 3, doorWidth + 6, doorHeight + 6);

            // === DOOR ===
            const doorColor = playerNearDoor ? '#3a3025' : '#251a10';
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);

            // Door panels (raised)
            ctx.strokeStyle = '#1a1008';
            ctx.lineWidth = 2;
            // Top panel
            ctx.strokeRect(doorX + 5, doorY + 8, doorWidth - 10, 25);
            // Bottom panel
            ctx.strokeRect(doorX + 5, doorY + 40, doorWidth - 10, 28);

            // Panel highlights
            ctx.strokeStyle = '#3a2a18';
            ctx.lineWidth = 1;
            ctx.strokeRect(doorX + 6, doorY + 9, doorWidth - 12, 23);
            ctx.strokeRect(doorX + 6, doorY + 41, doorWidth - 12, 26);

            // === DOOR WINDOW (for certain types) ===
            if (['office', 'cafe', 'bar'].includes(building.type)) {
                // Window frame
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(doorX + 8, doorY + 10, doorWidth - 16, 22);

                // Glass with interior glow
                const glassGradient = ctx.createLinearGradient(doorX + 8, doorY + 10, doorX + 8, doorY + 32);
                glassGradient.addColorStop(0, 'rgba(200, 180, 140, 0.4)');
                glassGradient.addColorStop(1, 'rgba(150, 130, 90, 0.3)');
                ctx.fillStyle = glassGradient;
                ctx.fillRect(doorX + 10, doorY + 12, doorWidth - 20, 18);

                // Frosted glass text (business name hint)
                if (building.type === 'office') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.font = '7px Special Elite';
                    ctx.textAlign = 'center';
                    ctx.fillText('PRIVATE', doorX + doorWidth / 2, doorY + 23);
                }

                // Glass reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.moveTo(doorX + 10, doorY + 12);
                ctx.lineTo(doorX + 20, doorY + 12);
                ctx.lineTo(doorX + 10, doorY + 22);
                ctx.closePath();
                ctx.fill();
            }

            // === DOOR HARDWARE ===
            // Handle plate
            ctx.fillStyle = '#b8860b';
            ctx.fillRect(doorX + doorWidth - 14, doorY + 35, 8, 18);

            // Door knob
            ctx.fillStyle = '#d4a835';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 10, doorY + 42, 4, 0, Math.PI * 2);
            ctx.fill();

            // Knob highlight
            ctx.fillStyle = '#f0d060';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 11, doorY + 41, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Keyhole
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 10, doorY + 48, 2, 0, Math.PI * 2);
            ctx.fill();

            // === TRANSOM WINDOW (above door) ===
            ctx.fillStyle = '#0a0805';
            ctx.fillRect(doorX - 3, doorY - 20, doorWidth + 6, 15);

            // Transom glass
            const transomGlow = ctx.createLinearGradient(doorX, doorY - 20, doorX, doorY - 5);
            transomGlow.addColorStop(0, 'rgba(180, 160, 120, 0.3)');
            transomGlow.addColorStop(1, 'rgba(220, 190, 140, 0.5)');
            ctx.fillStyle = transomGlow;
            ctx.fillRect(doorX, doorY - 18, doorWidth, 11);

            // Transom dividers
            ctx.strokeStyle = '#1a1510';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(doorX + doorWidth * 0.33, doorY - 18);
            ctx.lineTo(doorX + doorWidth * 0.33, doorY - 7);
            ctx.moveTo(doorX + doorWidth * 0.66, doorY - 18);
            ctx.lineTo(doorX + doorWidth * 0.66, doorY - 7);
            ctx.stroke();

            // === LIGHT FIXTURE ===
            // Bracket
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(doorX + doorWidth / 2 - 3, doorY - 35, 6, 12);

            // Light fixture body
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.moveTo(doorX + doorWidth / 2 - 10, doorY - 35);
            ctx.lineTo(doorX + doorWidth / 2 + 10, doorY - 35);
            ctx.lineTo(doorX + doorWidth / 2 + 6, doorY - 45);
            ctx.lineTo(doorX + doorWidth / 2 - 6, doorY - 45);
            ctx.closePath();
            ctx.fill();

            // Light glow
            ctx.fillStyle = COLORS.windowLit;
            ctx.shadowColor = COLORS.windowLit;
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(doorX + doorWidth / 2, doorY - 38, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Light cone on ground
            const lightCone = ctx.createRadialGradient(
                doorX + doorWidth / 2, groundLevel - 5, 0,
                doorX + doorWidth / 2, groundLevel - 5, 60
            );
            lightCone.addColorStop(0, 'rgba(255, 237, 200, 0.25)');
            lightCone.addColorStop(1, 'rgba(255, 237, 200, 0)');
            ctx.fillStyle = lightCone;
            ctx.fillRect(doorX - 30, groundLevel - 20, doorWidth + 60, 25);

            // === INTERACTION HIGHLIGHT ===
            if (playerNearDoor) {
                ctx.strokeStyle = 'rgba(196, 163, 90, 0.6)';
                ctx.lineWidth = 2;
                ctx.strokeRect(doorX - 5, doorY - 22, doorWidth + 10, doorHeight + 27);
            }

            // === STEP ===
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(doorX - 10, groundLevel - 18, doorWidth + 20, 5);
            ctx.fillStyle = '#5a5652';
            ctx.fillRect(doorX - 10, groundLevel - 18, doorWidth + 20, 2);
        }

        function drawBuildingSign(building, bx, by) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(bx + 10, by - 35, building.width - 20, 30);

            ctx.fillStyle = COLORS.cream;
            ctx.font = 'bold 12px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lines = building.name.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, bx + building.width / 2, by - 25 + i * 12);
            });
        }

        function drawNeonSign(building, bx, by) {
            const signX = bx + building.width - 80;
            const signY = by + 20;

            // Neon glow
            ctx.shadowColor = building.neonColor;
            ctx.shadowBlur = 20;

            ctx.strokeStyle = building.neonColor;
            ctx.lineWidth = 3;
            ctx.font = 'bold 16px Bebas Neue';
            ctx.textAlign = 'center';

            // Flicker effect
            const flicker = Math.random() > 0.95 ? 0.5 : 1;
            ctx.globalAlpha = flicker;

            ctx.fillStyle = building.neonColor;
            ctx.fillText(building.neonText, signX + 30, signY + 15);

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawTheaterMarquee(building, bx, by) {
            const marqueeWidth = building.width - 40;
            const marqueeHeight = 80;
            const marqueeX = bx + 20;
            const marqueeY = by - 60;

            // Marquee structure
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(marqueeX, marqueeY, marqueeWidth, marqueeHeight);

            // Border lights
            ctx.fillStyle = COLORS.windowLit;
            const bulbSpacing = 15;
            for (let i = 0; i < marqueeWidth / bulbSpacing; i++) {
                const flicker = Math.random() > 0.9 ? 0.3 : 1;
                ctx.globalAlpha = flicker;
                ctx.shadowColor = COLORS.windowLit;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(marqueeX + 7 + i * bulbSpacing, marqueeY + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(marqueeX + 7 + i * bulbSpacing, marqueeY + marqueeHeight - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Now playing text
            ctx.fillStyle = '#ff3333';
            ctx.font = 'bold 10px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('NOW PLAYING', marqueeX + marqueeWidth / 2, marqueeY + 25);

            ctx.fillStyle = COLORS.cream;
            ctx.font = 'bold 14px Bebas Neue';
            building.nowPlaying.forEach((movie, i) => {
                ctx.fillText(movie, marqueeX + marqueeWidth / 2, marqueeY + 45 + i * 18);
            });
        }

        function drawStreetLight(light) {
            const lx = light.x - camera.x;
            const baseY = GROUND_LEVEL + 50; // Street lights sit on sidewalk

            if (lx < -50 || lx > CONFIG.CANVAS_WIDTH + 50) return;

            // Pole base (concrete)
            ctx.fillStyle = '#4a4642';
            ctx.fillRect(lx - 6, baseY - 8, 12, 10);

            // Pole (iron)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(lx - 3, baseY - 90, 6, 85);

            // Decorative rings on pole
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(lx - 4, baseY - 30, 8, 4);
            ctx.fillRect(lx - 4, baseY - 60, 8, 4);

            // Lamp arm (curved bracket)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(lx, baseY - 88);
            ctx.quadraticCurveTo(lx + 25, baseY - 95, lx + 30, baseY - 80);
            ctx.stroke();

            // Lamp housing
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.moveTo(lx + 20, baseY - 80);
            ctx.lineTo(lx + 40, baseY - 80);
            ctx.lineTo(lx + 38, baseY - 65);
            ctx.lineTo(lx + 22, baseY - 65);
            ctx.closePath();
            ctx.fill();

            // Lamp glass
            ctx.fillStyle = '#2a2520';
            ctx.fillRect(lx + 23, baseY - 78, 14, 11);

            // Light glow on ground
            const gradient = ctx.createRadialGradient(lx + 30, baseY + 20, 0, lx + 30, baseY + 20, 100);
            gradient.addColorStop(0, 'rgba(255, 237, 200, 0.35)');
            gradient.addColorStop(0.5, 'rgba(255, 237, 200, 0.15)');
            gradient.addColorStop(1, 'rgba(255, 237, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(lx + 30, baseY + 20, 100, 50, 0, 0, Math.PI * 2);
            ctx.fill();

            // Light bulb glow
            ctx.fillStyle = COLORS.streetLight;
            ctx.shadowColor = COLORS.streetLight;
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(lx + 30, baseY - 70, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Light cone effect
            ctx.fillStyle = 'rgba(255, 237, 200, 0.08)';
            ctx.beginPath();
            ctx.moveTo(lx + 23, baseY - 65);
            ctx.lineTo(lx - 40, baseY + 60);
            ctx.lineTo(lx + 100, baseY + 60);
            ctx.lineTo(lx + 37, baseY - 65);
            ctx.closePath();
            ctx.fill();
        }

        function drawCar(car) {
            const cx = car.x - camera.x;
            const streetSurface = GROUND_LEVEL + 58 + 85; // Middle of street

            if (cx < -100 || cx > CONFIG.CANVAS_WIDTH + 100) return;

            // Car shadow on street
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(cx + 55, streetSurface + 18, 58, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Car body (1950s style - larger, more detailed)
            const carY = streetSurface - 15;

            // Darker undercarriage
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(cx + 8, carY + 25, 94, 8);

            // Main body color
            ctx.fillStyle = car.color;

            // Lower body (fenders, doors)
            ctx.beginPath();
            ctx.moveTo(cx, carY + 18);
            ctx.lineTo(cx + 8, carY + 28);
            ctx.lineTo(cx + 102, carY + 28);
            ctx.lineTo(cx + 110, carY + 18);
            ctx.lineTo(cx + 108, carY + 8);
            ctx.lineTo(cx + 2, carY + 8);
            ctx.closePath();
            ctx.fill();

            // Body highlight
            ctx.fillStyle = adjustBrightness(car.color, 1.2);
            ctx.fillRect(cx + 5, carY + 10, 100, 3);

            // Roof
            ctx.fillStyle = car.color;
            ctx.beginPath();
            ctx.moveTo(cx + 22, carY + 8);
            ctx.lineTo(cx + 28, carY - 12);
            ctx.lineTo(cx + 82, carY - 12);
            ctx.lineTo(cx + 88, carY + 8);
            ctx.closePath();
            ctx.fill();

            // Roof highlight
            ctx.fillStyle = adjustBrightness(car.color, 1.3);
            ctx.beginPath();
            ctx.moveTo(cx + 30, carY - 10);
            ctx.lineTo(cx + 80, carY - 10);
            ctx.lineTo(cx + 78, carY - 8);
            ctx.lineTo(cx + 32, carY - 8);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = 'rgba(80, 100, 120, 0.8)';
            // Front window
            ctx.beginPath();
            ctx.moveTo(cx + 30, carY + 6);
            ctx.lineTo(cx + 34, carY - 8);
            ctx.lineTo(cx + 52, carY - 8);
            ctx.lineTo(cx + 52, carY + 6);
            ctx.closePath();
            ctx.fill();
            // Rear window
            ctx.beginPath();
            ctx.moveTo(cx + 58, carY + 6);
            ctx.lineTo(cx + 58, carY - 8);
            ctx.lineTo(cx + 76, carY - 8);
            ctx.lineTo(cx + 80, carY + 6);
            ctx.closePath();
            ctx.fill();

            // Window frames
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 55, carY + 6);
            ctx.lineTo(cx + 55, carY - 8);
            ctx.stroke();

            // Chrome trim
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 3, carY + 18);
            ctx.lineTo(cx + 107, carY + 18);
            ctx.stroke();

            // Chrome bumpers
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(cx - 2, carY + 20, 8, 6);
            ctx.fillRect(cx + 104, carY + 20, 8, 6);

            // Wheels with whitewalls
            // Front wheel
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e8e8e0';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 7, 0, Math.PI * 2);
            ctx.fill();
            // Hubcap
            ctx.fillStyle = '#909090';
            ctx.beginPath();
            ctx.arc(cx + 22, carY + 26, 5, 0, Math.PI * 2);
            ctx.fill();

            // Rear wheel
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e8e8e0';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#909090';
            ctx.beginPath();
            ctx.arc(cx + 88, carY + 26, 5, 0, Math.PI * 2);
            ctx.fill();

            // Headlights
            ctx.fillStyle = '#ffffee';
            ctx.shadowColor = '#ffffcc';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(cx + 105, carY + 12, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 105, carY + 20, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Taillights
            ctx.fillStyle = '#cc2020';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(cx + 5, carY + 14, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // License plate
            ctx.fillStyle = '#f0f0e0';
            ctx.fillRect(cx + 48, carY + 24, 14, 6);
            ctx.fillStyle = '#1a1a1a';
            ctx.font = '4px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('1959', cx + 55, carY + 29);
        }

        // ============================================
        // MANNEQUIN-STYLE CHARACTER RENDERING
        // Angular, art deco influenced, elongated proportions
        // ============================================

        function drawMannequin(x, y, options = {}) {
            const {
                facing = 1,           // 1 = right, -1 = left
                isMoving = false,
                walkCycle = 0,
                outfit = 'detective', // detective, suit, dress, worker, casual
                hatType = 'fedora',   // fedora, none, bowler, pillbox
                lightFactor = 1,
                isPlayer = false
            } = options;

            const cx = x;  // center x
            const cy = y;  // feet y position

            // Character proportions (mannequin style - elongated)
            const scale = 1;
            const headHeight = 10 * scale;
            const neckHeight = 4 * scale;
            const torsoHeight = 18 * scale;
            const legHeight = 28 * scale;
            const armLength = 20 * scale;
            const shoulderWidth = 14 * scale;
            const hipWidth = 8 * scale;
            const headWidth = 8 * scale;

            // Walk animation
            const walkPhase = isMoving ? Math.sin(walkCycle * 0.15) : 0;
            const legSwing = walkPhase * 8;
            const armSwing = walkPhase * 6;
            const bodyBob = Math.abs(walkPhase) * 2;

            // Calculate key points
            const feetY = cy;
            const hipY = feetY - legHeight;
            const shoulderY = hipY - torsoHeight;
            const neckY = shoulderY - neckHeight;
            const headCenterY = neckY - headHeight / 2;

            // Long dramatic shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(cx, feetY + 3, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Extended shadow for noir effect
            if (lightFactor > 0.5) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.moveTo(cx - 8, feetY);
                ctx.lineTo(cx + 40, feetY + 60);
                ctx.lineTo(cx + 50, feetY + 58);
                ctx.lineTo(cx + 8, feetY);
                ctx.closePath();
                ctx.fill();
            }

            ctx.save();
            ctx.translate(cx, 0);
            ctx.scale(facing, 1);
            ctx.translate(-cx, 0);

            // === LEGS (angular, defined) ===
            const leftFootX = cx - 4 + (isMoving ? legSwing : 0);
            const rightFootX = cx + 4 + (isMoving ? -legSwing : 0);
            const leftKneeX = cx - 3 + (isMoving ? legSwing * 0.3 : 0);
            const rightKneeX = cx + 3 + (isMoving ? -legSwing * 0.3 : 0);
            const kneeY = hipY + legHeight * 0.55;

            // Left leg
            ctx.strokeStyle = adjustBrightness('#1a1a1a', lightFactor);
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(cx - hipWidth/2, hipY - bodyBob);
            ctx.lineTo(leftKneeX, kneeY - bodyBob);
            ctx.lineTo(leftFootX, feetY);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(cx + hipWidth/2 - 2, hipY - bodyBob);
            ctx.lineTo(rightKneeX, kneeY - bodyBob);
            ctx.lineTo(rightFootX, feetY);
            ctx.stroke();

            // Shoes (angular)
            ctx.fillStyle = adjustBrightness('#0f0f0f', lightFactor);
            // Left shoe
            ctx.beginPath();
            ctx.moveTo(leftFootX - 5, feetY);
            ctx.lineTo(leftFootX + 6, feetY);
            ctx.lineTo(leftFootX + 4, feetY - 4);
            ctx.lineTo(leftFootX - 3, feetY - 4);
            ctx.closePath();
            ctx.fill();
            // Right shoe
            ctx.beginPath();
            ctx.moveTo(rightFootX - 5, feetY);
            ctx.lineTo(rightFootX + 6, feetY);
            ctx.lineTo(rightFootX + 4, feetY - 4);
            ctx.lineTo(rightFootX - 3, feetY - 4);
            ctx.closePath();
            ctx.fill();

            // === TORSO (trench coat / suit - angular cut) ===
            const coatColor = outfit === 'detective' ? '#2a2520' : '#1a1a1a';

            // Coat body - angular trapezoid
            ctx.fillStyle = adjustBrightness(coatColor, lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - shoulderWidth/2, shoulderY - bodyBob);
            ctx.lineTo(cx + shoulderWidth/2, shoulderY - bodyBob);
            ctx.lineTo(cx + hipWidth/2 + 2, hipY + 4 - bodyBob);
            ctx.lineTo(cx - hipWidth/2 - 2, hipY + 4 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Coat lapels (V-shape detail)
            ctx.strokeStyle = adjustBrightness('#1a1815', lightFactor);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 3, shoulderY + 2 - bodyBob);
            ctx.lineTo(cx, shoulderY + 10 - bodyBob);
            ctx.lineTo(cx + 3, shoulderY + 2 - bodyBob);
            ctx.stroke();

            // Coat center line
            ctx.strokeStyle = adjustBrightness('#151310', lightFactor);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx, shoulderY + 10 - bodyBob);
            ctx.lineTo(cx, hipY + 2 - bodyBob);
            ctx.stroke();

            // === ARMS (angular, hinged at elbow) ===
            const shoulderOffsetX = shoulderWidth/2 - 1;
            const elbowY = shoulderY + armLength * 0.45 - bodyBob;
            const handY = shoulderY + armLength - bodyBob;

            // Left arm
            const leftElbowX = cx - shoulderOffsetX - 3 + (isMoving ? -armSwing * 0.5 : 0);
            const leftHandX = cx - shoulderOffsetX - 1 + (isMoving ? -armSwing : 0);
            const leftHandY = handY + (isMoving ? armSwing * 0.3 : 0);

            ctx.strokeStyle = adjustBrightness(coatColor, lightFactor);
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx - shoulderOffsetX, shoulderY + 2 - bodyBob);
            ctx.lineTo(leftElbowX, elbowY);
            ctx.lineTo(leftHandX, leftHandY);
            ctx.stroke();

            // Right arm
            const rightElbowX = cx + shoulderOffsetX + 3 + (isMoving ? armSwing * 0.5 : 0);
            const rightHandX = cx + shoulderOffsetX + 1 + (isMoving ? armSwing : 0);
            const rightHandY = handY + (isMoving ? -armSwing * 0.3 : 0);

            ctx.beginPath();
            ctx.moveTo(cx + shoulderOffsetX, shoulderY + 2 - bodyBob);
            ctx.lineTo(rightElbowX, elbowY);
            ctx.lineTo(rightHandX, rightHandY);
            ctx.stroke();

            // Hands (small angular)
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.beginPath();
            ctx.moveTo(leftHandX - 2, leftHandY);
            ctx.lineTo(leftHandX + 2, leftHandY);
            ctx.lineTo(leftHandX + 1, leftHandY + 4);
            ctx.lineTo(leftHandX - 1, leftHandY + 4);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(rightHandX - 2, rightHandY);
            ctx.lineTo(rightHandX + 2, rightHandY);
            ctx.lineTo(rightHandX + 1, rightHandY + 4);
            ctx.lineTo(rightHandX - 1, rightHandY + 4);
            ctx.closePath();
            ctx.fill();

            // === NECK ===
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.fillRect(cx - 2, neckY - bodyBob, 4, neckHeight + 2);

            // Collar points
            ctx.fillStyle = adjustBrightness('#f5f0e6', lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - 4, shoulderY - bodyBob);
            ctx.lineTo(cx - 2, shoulderY - 4 - bodyBob);
            ctx.lineTo(cx, shoulderY - bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(cx, shoulderY - bodyBob);
            ctx.lineTo(cx + 2, shoulderY - 4 - bodyBob);
            ctx.lineTo(cx + 4, shoulderY - bodyBob);
            ctx.closePath();
            ctx.fill();

            // === HEAD (angular, geometric) ===
            // Jaw - angular
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
            ctx.lineTo(cx - headWidth/2 + 1, headCenterY + headHeight/2 - 2 - bodyBob);
            ctx.lineTo(cx, headCenterY + headHeight/2 + 2 - bodyBob); // chin point
            ctx.lineTo(cx + headWidth/2 - 1, headCenterY + headHeight/2 - 2 - bodyBob);
            ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Upper head / forehead
            ctx.beginPath();
            ctx.moveTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
            ctx.lineTo(cx - headWidth/2 + 1, headCenterY - headHeight/2 - bodyBob);
            ctx.lineTo(cx + headWidth/2 - 1, headCenterY - headHeight/2 - bodyBob);
            ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Face shadow (one side for noir effect)
            if (lightFactor > 0.5) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.moveTo(cx, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx, headCenterY + headHeight/2 + 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2 + 1, headCenterY + headHeight/2 - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2 + 1, headCenterY - headHeight/2 - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            // Eyes (minimal, angular)
            if (lightFactor > 0.3) {
                ctx.fillStyle = adjustBrightness('#1a1a1a', lightFactor);
                // Angular eye shapes
                ctx.beginPath();
                ctx.moveTo(cx - 4, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx - 2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - 1, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx - 2, headCenterY - bodyBob);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(cx + 1, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx + 2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx + 4, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx + 2, headCenterY - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            // === HAT (fedora - angular) ===
            if (hatType === 'fedora') {
                const hatY = headCenterY - headHeight/2 - 2 - bodyBob;

                // Hat brim - angular
                ctx.fillStyle = adjustBrightness('#1a1815', lightFactor);
                ctx.beginPath();
                ctx.moveTo(cx - 12, hatY + 3);
                ctx.lineTo(cx - 10, hatY);
                ctx.lineTo(cx + 10, hatY);
                ctx.lineTo(cx + 12, hatY + 3);
                ctx.lineTo(cx + 10, hatY + 4);
                ctx.lineTo(cx - 10, hatY + 4);
                ctx.closePath();
                ctx.fill();

                // Hat crown - angular with pinch
                ctx.beginPath();
                ctx.moveTo(cx - 7, hatY);
                ctx.lineTo(cx - 6, hatY - 8);
                ctx.lineTo(cx - 2, hatY - 10); // pinch
                ctx.lineTo(cx + 2, hatY - 10); // pinch
                ctx.lineTo(cx + 6, hatY - 8);
                ctx.lineTo(cx + 7, hatY);
                ctx.closePath();
                ctx.fill();

                // Hat band
                ctx.fillStyle = adjustBrightness('#3d352a', lightFactor);
                ctx.fillRect(cx - 6, hatY - 2, 12, 2);

                // Hat shadow on face
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(cx - headWidth/2, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx + headWidth/2, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        function drawPlayer() {
            const px = player.x - camera.x + player.width / 2;
            const py = player.y - camera.y + player.height;

            const inLight = isInLight(player.x, player.y);
            const lightFactor = inLight ? 1 : 0.35;

            if (player.isMoving) {
                player.walkCycle++;
            }

            drawMannequin(px, py, {
                facing: player.facing,
                isMoving: player.isMoving,
                walkCycle: player.walkCycle,
                outfit: 'detective',
                hatType: 'fedora',
                lightFactor: lightFactor,
                isPlayer: true
            });
        }

        function isInLight(x, y) {
            // Check street lights (light falls slightly to the right due to arm)
            for (const light of currentMap.streetLights) {
                const lightX = light.x + 30; // Offset for lamp arm
                const lightY = GROUND_LEVEL + 30;
                const dist = Math.sqrt(Math.pow(x - lightX, 2) + Math.pow(y - lightY, 2));
                if (dist < 90) return true;
            }

            // Check building doors (have lights above them)
            for (const building of currentMap.buildings) {
                const doorX = building.x + building.width / 2;
                const doorY = GROUND_LEVEL - 40;
                const dist = Math.sqrt(Math.pow(x - doorX, 2) + Math.pow(y - doorY, 2));
                if (dist < 50) return true;
            }

            return false;
        }

        function adjustBrightness(color, factor) {
            // Simple brightness adjustment
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);

                const nr = Math.floor(r * factor);
                const ng = Math.floor(g * factor);
                const nb = Math.floor(b * factor);

                return `rgb(${nr}, ${ng}, ${nb})`;
            }
            return color;
        }

        function drawNPC(npc) {
            const state = worldState.npcStates[npc.id] || { x: npc.x, y: npc.y, facingRight: true };
            const nx = state.x - camera.x + 12;
            const ny = state.y - camera.y + 64;

            const inLight = isInLight(state.x, state.y);
            const lightFactor = inLight ? 1 : 0.3;

            // Determine outfit based on role
            let outfit = 'suit';
            let hatType = 'none';

            if (npc.role === 'bartender') { outfit = 'worker'; }
            else if (npc.role === 'owner' && npc.name === 'Margaret') { outfit = 'dress'; hatType = 'none'; }
            else if (npc.role === 'owner' || npc.role === 'pharmacist') { outfit = 'suit'; }
            else if (npc.role === 'patron') { outfit = 'casual'; hatType = 'fedora'; }
            else if (npc.role === 'police') { outfit = 'suit'; hatType = 'none'; }
            else if (npc.role === 'secretary') { outfit = 'dress'; }

            drawMannequin(nx, ny, {
                facing: state.facingRight ? 1 : -1,
                isMoving: false,
                walkCycle: 0,
                outfit: outfit,
                hatType: hatType,
                lightFactor: lightFactor,
                isPlayer: false
            });
        }

        // ============================================
        // STREET PROPS RENDERING
        // ============================================

        function drawStreetProps() {
            for (const prop of worldState.props) {
                const px = prop.x - camera.x;
                const py = prop.y - camera.y;

                if (px < -50 || px > CONFIG.CANVAS_WIDTH + 50) continue;

                switch (prop.type) {
                    case 'phonebooth':
                        drawPhoneBooth(px, py);
                        break;
                    case 'bench':
                        drawBench(px, py);
                        break;
                    case 'trashcan':
                        drawTrashCan(px, py);
                        break;
                    case 'hydrant':
                        drawFireHydrant(px, py);
                        break;
                    case 'newsstand':
                        drawNewsstand(px, py);
                        break;
                    case 'mailbox':
                        drawMailbox(px, py);
                        break;
                    case 'streetsign':
                        drawStreetSign(px, py, prop.text);
                        break;
                }
            }
        }

        function drawPhoneBooth(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 58, 24, 6);

            // Booth frame
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x, y, 30, 60);

            // Glass panels
            ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
            ctx.fillRect(x + 3, y + 8, 24, 35);

            // Door frame
            ctx.strokeStyle = '#5a0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 3, y + 8, 24, 48);

            // Phone inside (silhouette)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 10, y + 18, 10, 15);

            // Light on top
            ctx.fillStyle = '#ffeecc';
            ctx.shadowColor = '#ffeecc';
            ctx.shadowBlur = 10;
            ctx.fillRect(x + 8, y - 5, 14, 5);
            ctx.shadowBlur = 0;
        }

        function drawBench(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 25, y + 22, 28, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x + 5, y + 8, 4, 14);
            ctx.fillRect(x + 41, y + 8, 4, 14);

            // Seat
            ctx.fillStyle = '#4a3a2a';
            ctx.fillRect(x, y, 50, 8);

            // Back rest
            ctx.fillRect(x, y - 15, 50, 6);
            ctx.fillRect(x + 2, y - 15, 3, 18);
            ctx.fillRect(x + 45, y - 15, 3, 18);
        }

        function drawTrashCan(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 25, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Can body
            ctx.fillStyle = '#3d3d3d';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 16, y);
            ctx.lineTo(x + 14, y + 24);
            ctx.lineTo(x + 2, y + 24);
            ctx.closePath();
            ctx.fill();

            // Rim
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(x - 1, y - 2, 18, 3);

            // Lines
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 5, y + 2);
            ctx.lineTo(x + 4, y + 22);
            ctx.moveTo(x + 11, y + 2);
            ctx.lineTo(x + 12, y + 22);
            ctx.stroke();
        }

        function drawFireHydrant(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 7, y + 22, 9, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Base
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x + 2, y + 15, 10, 7);

            // Body
            ctx.beginPath();
            ctx.moveTo(x + 1, y + 15);
            ctx.lineTo(x + 3, y + 4);
            ctx.lineTo(x + 11, y + 4);
            ctx.lineTo(x + 13, y + 15);
            ctx.closePath();
            ctx.fill();

            // Top
            ctx.fillRect(x + 4, y, 6, 4);
            ctx.fillRect(x + 5, y - 3, 4, 4);

            // Side nozzle
            ctx.fillRect(x + 12, y + 6, 5, 4);

            // Highlight
            ctx.fillStyle = '#aa2020';
            ctx.fillRect(x + 5, y + 5, 2, 8);
        }

        function drawNewsstand(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 32, 34, 6);

            // Stand body
            ctx.fillStyle = '#2a4a2a';
            ctx.fillRect(x, y, 40, 32);

            // Papers display
            ctx.fillStyle = '#e8e0d0';
            ctx.fillRect(x + 3, y + 3, 34, 20);

            // Headlines (abstract lines)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 5, y + 5, 20, 3);
            ctx.fillRect(x + 5, y + 10, 28, 2);
            ctx.fillRect(x + 5, y + 14, 25, 2);
            ctx.fillRect(x + 5, y + 18, 22, 2);

            // Coin slot area
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 15, y + 25, 10, 5);
        }

        function drawMailbox(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 35, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Post
            ctx.fillStyle = '#1a3a6a';
            ctx.fillRect(x + 5, y + 15, 6, 20);

            // Box body
            ctx.fillRect(x - 2, y, 20, 16);

            // Rounded top
            ctx.beginPath();
            ctx.arc(x + 8, y, 10, Math.PI, 0, false);
            ctx.fill();

            // Slot
            ctx.fillStyle = '#0a1a3a';
            ctx.fillRect(x + 2, y + 5, 12, 3);

            // USPS eagle (simplified)
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(x + 8, y - 4);
            ctx.lineTo(x + 12, y - 1);
            ctx.lineTo(x + 4, y - 1);
            ctx.closePath();
            ctx.fill();
        }

        function drawStreetSign(x, y, text) {
            // Pole
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(x + 12, y, 4, 50);

            // Sign
            ctx.fillStyle = '#1a5a1a';
            ctx.fillRect(x, y - 10, 60, 16);

            // Border
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y - 9, 58, 14);

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 9px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText(text, x + 30, y);
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        // ============================================
        // INTERIOR SYSTEM
        // ============================================

        const INTERIORS = {
            pi_office: {
                name: "JACK NOIR - PRIVATE INVESTIGATOR",
                width: 800,
                height: 500,
                backgroundColor: '#1a1612',
                floorColor: '#2a2218',
                wallColor: '#2d261f',
                // Furniture and props
                elements: [
                    // Waiting area (left side)
                    { type: 'couch', x: 80, y: 280, width: 120, height: 50 },
                    { type: 'table', x: 100, y: 350, width: 60, height: 40 },
                    { type: 'plant', x: 50, y: 250 },
                    { type: 'lamp', x: 210, y: 240, on: true },
                    // Secretary desk (center)
                    { type: 'desk', x: 300, y: 200, width: 150, height: 60, label: 'SECRETARY' },
                    { type: 'chair', x: 350, y: 270, facing: 'up' },
                    { type: 'filing_cabinet', x: 280, y: 120, width: 40, height: 80 },
                    { type: 'filing_cabinet', x: 460, y: 120, width: 40, height: 80 },
                    // Divider/wall to private office
                    { type: 'wall', x: 520, y: 100, width: 15, height: 300 },
                    { type: 'door_interior', x: 520, y: 180, width: 15, height: 70, label: 'PRIVATE', leadsTo: 'pi_private' },
                    // Private office (right side) - visible through door
                    { type: 'desk', x: 620, y: 200, width: 140, height: 70, label: 'YOUR DESK' },
                    { type: 'chair', x: 680, y: 280, facing: 'up' },
                    { type: 'window', x: 700, y: 80, width: 80, height: 100 },
                    { type: 'filing_cabinet', x: 580, y: 120, width: 35, height: 70 },
                    { type: 'chaise', x: 600, y: 330, width: 100, height: 45 }, // Client sits here
                    { type: 'lamp', x: 760, y: 180, on: true },
                    // Exit door
                    { type: 'exit_door', x: 380, y: 420, width: 60, height: 80 }
                ],
                // NPCs in this interior
                npcs: ['secretary'],
                // Ambient details
                details: [
                    { type: 'clock', x: 400, y: 90 },
                    { type: 'sign', x: 380, y: 60, text: 'NOIR INVESTIGATIONS' },
                    { type: 'blinds', x: 700, y: 80 }
                ]
            },

            cafe: {
                name: "ROSIE'S DINER",
                width: 700,
                height: 500,
                backgroundColor: '#1f1a15',
                floorColor: '#2a2520',
                wallColor: '#352a22',
                elements: [
                    // Counter
                    { type: 'counter', x: 50, y: 150, width: 300, height: 40 },
                    { type: 'stool', x: 80, y: 200 },
                    { type: 'stool', x: 130, y: 200 },
                    { type: 'stool', x: 180, y: 200 },
                    { type: 'stool', x: 230, y: 200 },
                    { type: 'stool', x: 280, y: 200 },
                    // Booths
                    { type: 'booth', x: 450, y: 120, width: 100, height: 70 },
                    { type: 'booth', x: 450, y: 220, width: 100, height: 70 },
                    { type: 'booth', x: 450, y: 320, width: 100, height: 70 },
                    // Tables
                    { type: 'table', x: 200, y: 300, width: 80, height: 60 },
                    { type: 'table', x: 320, y: 300, width: 80, height: 60 },
                    // Kitchen door
                    { type: 'door_interior', x: 50, y: 80, width: 60, height: 70, label: 'KITCHEN' },
                    // Pie display
                    { type: 'display_case', x: 360, y: 150, width: 60, height: 40 },
                    // Coffee machine
                    { type: 'coffee_machine', x: 100, y: 100 },
                    // Jukebox
                    { type: 'jukebox', x: 580, y: 350 },
                    // Exit
                    { type: 'exit_door', x: 320, y: 420, width: 60, height: 80 }
                ],
                npcs: ['waitress', 'cook'],
                details: [
                    { type: 'neon_sign', x: 300, y: 50, text: 'ROSIE\'S' },
                    { type: 'menu_board', x: 150, y: 70 },
                    { type: 'clock', x: 500, y: 60 }
                ]
            },

            bar: {
                name: "THE BLUE MOON",
                width: 750,
                height: 500,
                backgroundColor: '#0f0d10',
                floorColor: '#1a1618',
                wallColor: '#1f1a1d',
                elements: [
                    // Bar counter
                    { type: 'bar_counter', x: 50, y: 180, width: 350, height: 50 },
                    { type: 'stool', x: 80, y: 240 },
                    { type: 'stool', x: 130, y: 240 },
                    { type: 'stool', x: 180, y: 240 },
                    { type: 'stool', x: 230, y: 240 },
                    { type: 'stool', x: 280, y: 240 },
                    { type: 'stool', x: 330, y: 240 },
                    // Back bar with bottles
                    { type: 'back_bar', x: 50, y: 80, width: 350, height: 80 },
                    // Tables
                    { type: 'table', x: 480, y: 150, width: 70, height: 50 },
                    { type: 'table', x: 480, y: 250, width: 70, height: 50 },
                    { type: 'table', x: 600, y: 200, width: 70, height: 50 },
                    // Pool table
                    { type: 'pool_table', x: 550, y: 350, width: 120, height: 70 },
                    // Phone booth in back
                    { type: 'phone_booth', x: 680, y: 80 },
                    // Restroom doors
                    { type: 'door_interior', x: 680, y: 180, width: 50, height: 60, label: 'MEN' },
                    { type: 'door_interior', x: 680, y: 260, width: 50, height: 60, label: 'WOMEN' },
                    // Exit
                    { type: 'exit_door', x: 350, y: 420, width: 60, height: 80 }
                ],
                npcs: ['bartender', 'barfly1'],
                details: [
                    { type: 'neon_sign', x: 180, y: 50, text: 'BLUE MOON', color: '#3366ff' },
                    { type: 'dartboard', x: 620, y: 100 },
                    { type: 'mirror', x: 200, y: 90 }
                ]
            }
        };

        // Current interior state
        let currentInterior = null;
        let interiorPlayerPos = { x: 400, y: 380 };

        // Enter a building interior
        function enterBuilding(buildingId) {
            const interior = INTERIORS[buildingId];
            if (!interior) return;

            currentInterior = buildingId;
            game.state = 'interior';

            // Position player at entrance
            interiorPlayerPos = { x: interior.width / 2, y: interior.height - 100 };

            // Update location display
            document.getElementById('location-display').textContent = interior.name;
            document.getElementById('location-display').classList.add('visible');
            setTimeout(() => {
                document.getElementById('location-display').classList.remove('visible');
            }, 2000);
        }

        // Exit to street
        function exitBuilding() {
            currentInterior = null;
            game.state = 'playing';

            // Find which building we were in and position player outside its door
            for (const building of currentMap.buildings) {
                if (building.interiorId === currentInterior) {
                    player.x = building.x + building.width / 2 - player.width / 2;
                    player.y = GROUND_LEVEL + 10;
                    break;
                }
            }
        }

        // Draw interior scene
        function drawInterior() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            // Background
            ctx.fillStyle = interior.backgroundColor;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Floor
            const floorY = 250;
            ctx.fillStyle = interior.floorColor;
            ctx.fillRect(0, floorY, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT - floorY);

            // Floor boards
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1;
            for (let x = 0; x < CONFIG.CANVAS_WIDTH; x += 60) {
                ctx.beginPath();
                ctx.moveTo(x, floorY);
                ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }

            // Walls
            ctx.fillStyle = interior.wallColor;
            ctx.fillRect(0, 50, CONFIG.CANVAS_WIDTH, floorY - 50);

            // Wainscoting
            ctx.fillStyle = adjustBrightness(interior.wallColor, 0.7);
            ctx.fillRect(0, floorY - 60, CONFIG.CANVAS_WIDTH, 60);
            ctx.strokeStyle = adjustBrightness(interior.wallColor, 0.5);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, floorY - 60);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, floorY - 60);
            ctx.stroke();

            // Ceiling
            ctx.fillStyle = '#1a1815';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, 50);

            // Ceiling light
            ctx.fillStyle = '#0a0a08';
            ctx.beginPath();
            ctx.moveTo(CONFIG.CANVAS_WIDTH/2 - 40, 50);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 + 40, 50);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 + 30, 80);
            ctx.lineTo(CONFIG.CANVAS_WIDTH/2 - 30, 80);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#f0d890';
            ctx.shadowColor = '#f0d890';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(CONFIG.CANVAS_WIDTH/2, 75, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw elements
            for (const el of interior.elements) {
                drawInteriorElement(el);
            }

            // Draw details
            for (const detail of interior.details || []) {
                drawInteriorDetail(detail);
            }

            // Draw interior NPCs
            for (const npcId of interior.npcs || []) {
                const npc = npcs.find(n => n.id === npcId);
                if (npc) {
                    drawInteriorNPC(npc);
                }
            }

            // Draw player in interior
            drawMannequin(interiorPlayerPos.x, interiorPlayerPos.y + 60, {
                facing: player.facing,
                isMoving: player.isMoving,
                walkCycle: player.walkCycle,
                outfit: 'detective',
                hatType: 'fedora',
                lightFactor: 0.9,
                isPlayer: true
            });
        }

        function drawInteriorElement(el) {
            const x = el.x + (CONFIG.CANVAS_WIDTH - INTERIORS[currentInterior].width) / 2;
            const y = el.y + 100;

            switch (el.type) {
                case 'desk':
                    // Desk shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 5, el.width, 10);
                    // Desk body
                    ctx.fillStyle = '#3d2a1a';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Desk top
                    ctx.fillStyle = '#4a3520';
                    ctx.fillRect(x - 5, y - 5, el.width + 10, 10);
                    // Drawers
                    ctx.strokeStyle = '#2a1a10';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 10, y + 15, el.width/3 - 15, el.height - 25);
                    ctx.strokeRect(x + el.width/3 + 5, y + 15, el.width/3 - 10, el.height - 25);
                    // Drawer handles
                    ctx.fillStyle = '#b08030';
                    ctx.fillRect(x + 25, y + 35, 15, 4);
                    ctx.fillRect(x + el.width/3 + 20, y + 35, 15, 4);
                    // Items on desk
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x + el.width - 40, y - 15, 30, 20); // Phone
                    ctx.fillStyle = '#f0e8d8';
                    ctx.fillRect(x + 20, y - 12, 50, 35); // Papers
                    break;

                case 'chair':
                    ctx.fillStyle = '#2a2015';
                    // Seat
                    ctx.fillRect(x - 15, y, 30, 25);
                    // Back
                    ctx.fillRect(x - 12, y - 30, 24, 35);
                    // Legs
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x - 12, y + 25, 4, 15);
                    ctx.fillRect(x + 8, y + 25, 4, 15);
                    break;

                case 'couch':
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 3, el.width, 8);
                    // Base
                    ctx.fillStyle = '#3a2820';
                    ctx.fillRect(x, y + 20, el.width, el.height - 20);
                    // Cushions
                    ctx.fillStyle = '#4a3830';
                    ctx.fillRect(x + 5, y + 10, el.width/2 - 8, el.height - 15);
                    ctx.fillRect(x + el.width/2 + 3, y + 10, el.width/2 - 8, el.height - 15);
                    // Back
                    ctx.fillStyle = '#3a2820';
                    ctx.fillRect(x, y, el.width, 25);
                    // Arms
                    ctx.fillRect(x - 10, y, 15, el.height);
                    ctx.fillRect(x + el.width - 5, y, 15, el.height);
                    break;

                case 'chaise':
                    // Chaise lounge for clients
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 3, y + el.height + 2, el.width, 6);
                    ctx.fillStyle = '#4a3028';
                    ctx.fillRect(x, y + 10, el.width, el.height - 10);
                    ctx.fillStyle = '#5a4038';
                    ctx.fillRect(x + 5, y + 5, el.width - 30, el.height - 10);
                    // Raised end
                    ctx.fillStyle = '#4a3028';
                    ctx.fillRect(x + el.width - 25, y - 10, 25, el.height + 10);
                    break;

                case 'filing_cabinet':
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.strokeRect(x + 3, y + 5 + i * (el.height/3), el.width - 6, el.height/3 - 8);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(x + el.width/2 - 8, y + 15 + i * (el.height/3), 16, 4);
                    }
                    break;

                case 'table':
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(x + 3, y + el.height + 2, el.width, 5);
                    ctx.fillStyle = '#3d2a1a';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#4a3520';
                    ctx.fillRect(x - 3, y - 3, el.width + 6, 6);
                    break;

                case 'lamp':
                    // Stand
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x - 3, y, 6, 50);
                    // Base
                    ctx.fillRect(x - 12, y + 50, 24, 6);
                    // Shade
                    ctx.fillStyle = el.on ? '#e8d090' : '#4a4030';
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y);
                    ctx.lineTo(x + 20, y);
                    ctx.lineTo(x + 15, y - 25);
                    ctx.lineTo(x - 15, y - 25);
                    ctx.closePath();
                    ctx.fill();
                    if (el.on) {
                        ctx.fillStyle = 'rgba(255, 230, 150, 0.15)';
                        ctx.beginPath();
                        ctx.moveTo(x - 20, y);
                        ctx.lineTo(x - 60, y + 100);
                        ctx.lineTo(x + 60, y + 100);
                        ctx.lineTo(x + 20, y);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;

                case 'exit_door':
                    // Door frame
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x - 5, y - 5, el.width + 10, el.height + 5);
                    // Door
                    ctx.fillStyle = '#2a2015';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Window
                    ctx.fillStyle = 'rgba(100, 120, 140, 0.3)';
                    ctx.fillRect(x + 10, y + 10, el.width - 20, 30);
                    // Handle
                    ctx.fillStyle = '#b08030';
                    ctx.beginPath();
                    ctx.arc(x + el.width - 12, y + el.height/2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // EXIT sign
                    ctx.fillStyle = '#ff3030';
                    ctx.shadowColor = '#ff3030';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 12px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXIT', x + el.width/2, y - 15);
                    ctx.shadowBlur = 0;
                    break;

                case 'window':
                    ctx.fillStyle = '#0a0a15';
                    ctx.fillRect(x, y, el.width, el.height);
                    // Night sky through window
                    ctx.fillStyle = '#0f0f1a';
                    ctx.fillRect(x + 4, y + 4, el.width - 8, el.height - 8);
                    // Window frame
                    ctx.strokeStyle = '#2a2520';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, y, el.width, el.height);
                    ctx.beginPath();
                    ctx.moveTo(x + el.width/2, y);
                    ctx.lineTo(x + el.width/2, y + el.height);
                    ctx.moveTo(x, y + el.height/2);
                    ctx.lineTo(x + el.width, y + el.height/2);
                    ctx.stroke();
                    // City lights outside
                    ctx.fillStyle = '#f0d060';
                    ctx.fillRect(x + 15, y + 60, 3, 5);
                    ctx.fillRect(x + 45, y + 50, 2, 4);
                    ctx.fillRect(x + 60, y + 65, 3, 4);
                    break;

                case 'wall':
                    ctx.fillStyle = '#2a2520';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(x, y + el.height - 40, el.width, 40);
                    break;

                case 'door_interior':
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x, y, el.width + 40, el.height);
                    ctx.fillStyle = '#2a2015';
                    ctx.fillRect(x + 3, y + 3, el.width + 34, el.height - 6);
                    // Frosted glass
                    ctx.fillStyle = 'rgba(200, 180, 140, 0.2)';
                    ctx.fillRect(x + 8, y + 10, el.width + 24, el.height/2);
                    // Label
                    if (el.label) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.font = '10px Special Elite';
                        ctx.textAlign = 'center';
                        ctx.fillText(el.label, x + el.width/2 + 20, y + 30);
                    }
                    break;

                case 'stool':
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x - 2, y, 4, 30);
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#6b0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'counter':
                case 'bar_counter':
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x + 5, y + el.height + 3, el.width, 8);
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(x, y, el.width, el.height);
                    ctx.fillStyle = '#3a2515';
                    ctx.fillRect(x - 5, y - 8, el.width + 10, 12);
                    // Bar rail
                    ctx.fillStyle = '#b08030';
                    ctx.fillRect(x, y + el.height - 8, el.width, 4);
                    break;
            }
        }

        function drawInteriorDetail(detail) {
            const x = detail.x + (CONFIG.CANVAS_WIDTH - INTERIORS[currentInterior].width) / 2;
            const y = detail.y + 100;

            switch (detail.type) {
                case 'clock':
                    ctx.fillStyle = '#2a2520';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#f0e8d8';
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, Math.PI * 2);
                    ctx.fill();
                    // Hands
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 8, y - 5);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 3, y + 10);
                    ctx.stroke();
                    break;

                case 'neon_sign':
                    ctx.fillStyle = detail.color || '#ff3333';
                    ctx.shadowColor = detail.color || '#ff3333';
                    ctx.shadowBlur = 20;
                    ctx.font = 'bold 24px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText(detail.text, x, y);
                    ctx.shadowBlur = 0;
                    break;

                case 'sign':
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(x - 60, y - 15, 120, 30);
                    ctx.fillStyle = '#c4a35a';
                    ctx.font = '12px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.fillText(detail.text, x, y + 5);
                    break;
            }
        }

        function drawInteriorNPC(npc) {
            const interior = INTERIORS[currentInterior];
            const baseX = (CONFIG.CANVAS_WIDTH - interior.width) / 2;

            // Position based on role
            let npcX = baseX + 375;
            let npcY = 340;

            if (npc.role === 'secretary') {
                npcX = baseX + 375;
                npcY = 340;
            } else if (npc.role === 'bartender') {
                npcX = baseX + 200;
                npcY = 300;
            } else if (npc.role === 'owner') {
                npcX = baseX + 150;
                npcY = 340;
            }

            drawMannequin(npcX, npcY, {
                facing: 1,
                isMoving: false,
                walkCycle: 0,
                outfit: npc.role === 'secretary' ? 'dress' : 'suit',
                hatType: 'none',
                lightFactor: 0.85,
                isPlayer: false
            });
        }

        // ============================================
        // DIALOGUE SYSTEM
        // ============================================

        let currentDialogue = null;
        let dialogueIndex = 0;

        function startDialogue(npcId) {
            const npc = npcs.find(n => n.id === npcId);
            if (!npc || !npc.dialogue) return;

            currentDialogue = npc;
            dialogueIndex = 0;
            game.state = 'dialogue';

            showDialogueBox(npc.name, npc.dialogue[0]);
        }

        function advanceDialogue() {
            if (!currentDialogue) return;

            dialogueIndex++;
            if (dialogueIndex >= currentDialogue.dialogue.length) {
                endDialogue();
                return;
            }

            showDialogueBox(currentDialogue.name, currentDialogue.dialogue[dialogueIndex]);
        }

        function endDialogue() {
            currentDialogue = null;
            dialogueIndex = 0;
            game.state = currentInterior ? 'interior' : 'playing';
            hideDialogueBox();
        }

        function showDialogueBox(speaker, text) {
            document.getElementById('dialogue-speaker').textContent = speaker.toUpperCase();
            document.getElementById('dialogue-text').textContent = text;
            document.getElementById('dialogue-box').classList.add('visible');
        }

        function hideDialogueBox() {
            document.getElementById('dialogue-box').classList.remove('visible');
        }

        // ============================================
        // PLAYER UPDATE
        // ============================================

        function updatePlayer() {
            // Handle dialogue state
            if (game.state === 'dialogue') {
                return; // No movement during dialogue
            }

            // Handle interior movement
            if (game.state === 'interior') {
                updateInteriorPlayer();
                return;
            }

            if (game.state !== 'playing') return;

            player.isMoving = false;

            if (keys.up) {
                player.y -= player.speed;
                player.direction = 'up';
                player.isMoving = true;
            }
            if (keys.down) {
                player.y += player.speed;
                player.direction = 'down';
                player.isMoving = true;
            }
            if (keys.left) {
                player.x -= player.speed;
                player.direction = 'left';
                player.facing = -1;
                player.isMoving = true;
            }
            if (keys.right) {
                player.x += player.speed;
                player.direction = 'right';
                player.facing = 1;
                player.isMoving = true;
            }

            if (player.isMoving) {
                player.walkCycle++;
            }

            // Boundary checks - player stays on sidewalk/street area
            player.x = Math.max(20, Math.min(currentMap.width - player.width - 20, player.x));
            // Y boundaries: top sidewalk to bottom sidewalk
            player.y = Math.max(GROUND_LEVEL - 45, Math.min(GROUND_LEVEL + 180, player.y));

            // Collision with buildings
            for (const collider of currentMap.colliders || []) {
                const playerRight = player.x + player.width;
                const playerBottom = player.y + player.height;

                if (player.x < collider.x + collider.width &&
                    playerRight > collider.x &&
                    player.y < collider.y + collider.height &&
                    playerBottom > collider.y) {
                    // Push player out of collision
                    const overlapLeft = playerRight - collider.x;
                    const overlapRight = collider.x + collider.width - player.x;
                    const overlapTop = playerBottom - collider.y;
                    const overlapBottom = collider.y + collider.height - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop) player.y = collider.y - player.height;
                    else if (minOverlap === overlapBottom) player.y = collider.y + collider.height;
                    else if (minOverlap === overlapLeft) player.x = collider.x - player.width;
                    else if (minOverlap === overlapRight) player.x = collider.x + collider.width;
                }
            }

            // Update camera to follow player
            camera.x = player.x - CONFIG.CANVAS_WIDTH / 2 + player.width / 2;
            camera.y = player.y - CONFIG.CANVAS_HEIGHT / 2 + player.height / 2;

            // Camera bounds
            camera.x = Math.max(0, Math.min(currentMap.width - CONFIG.CANVAS_WIDTH, camera.x));
            camera.y = Math.max(0, Math.min(currentMap.height - CONFIG.CANVAS_HEIGHT, camera.y));

            // Check for interactions
            checkInteractions();
        }

        function updateInteriorPlayer() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            player.isMoving = false;

            if (keys.up) {
                interiorPlayerPos.y -= player.speed;
                player.isMoving = true;
            }
            if (keys.down) {
                interiorPlayerPos.y += player.speed;
                player.isMoving = true;
            }
            if (keys.left) {
                interiorPlayerPos.x -= player.speed;
                player.facing = -1;
                player.isMoving = true;
            }
            if (keys.right) {
                interiorPlayerPos.x += player.speed;
                player.facing = 1;
                player.isMoving = true;
            }

            if (player.isMoving) {
                player.walkCycle++;
            }

            // Boundary checks
            interiorPlayerPos.x = Math.max(50, Math.min(interior.width - 50, interiorPlayerPos.x));
            interiorPlayerPos.y = Math.max(180, Math.min(interior.height - 50, interiorPlayerPos.y));

            // Check for exit door
            checkInteriorInteractions();
        }

        function checkInteriorInteractions() {
            const interior = INTERIORS[currentInterior];
            if (!interior) return;

            const baseX = (CONFIG.CANVAS_WIDTH - interior.width) / 2;
            let nearInteractable = false;

            // Check for exit door
            for (const el of interior.elements) {
                if (el.type === 'exit_door') {
                    const doorX = el.x + baseX + el.width / 2;
                    const doorY = el.y + 100;
                    const dist = Math.sqrt(
                        Math.pow(interiorPlayerPos.x + baseX - doorX, 2) +
                        Math.pow(interiorPlayerPos.y - doorY + 40, 2)
                    );

                    if (dist < 60) {
                        nearInteractable = true;
                        document.getElementById('interact-prompt').textContent = '[E] EXIT';
                        nearInteractable = { type: 'exit' };
                        break;
                    }
                }
            }

            // Check for NPCs to talk to
            if (!nearInteractable) {
                for (const npcId of interior.npcs || []) {
                    const npc = npcs.find(n => n.id === npcId);
                    if (npc) {
                        // Calculate NPC position
                        let npcX = 375;
                        if (npc.role === 'secretary') npcX = 375;
                        else if (npc.role === 'bartender') npcX = 200;

                        const dist = Math.sqrt(
                            Math.pow(interiorPlayerPos.x - npcX, 2) +
                            Math.pow(interiorPlayerPos.y - 280, 2)
                        );

                        if (dist < 80) {
                            nearInteractable = { type: 'npc', npc: npc };
                            document.getElementById('interact-prompt').textContent = `[E] TALK TO ${npc.name.toUpperCase()}`;
                            break;
                        }
                    }
                }
            }

            const promptEl = document.getElementById('interact-prompt');
            if (nearInteractable) {
                promptEl.classList.add('visible');
                player.nearInteractable = nearInteractable;
            } else {
                promptEl.classList.remove('visible');
                player.nearInteractable = null;
            }
        }

        function checkInteractions() {
            let nearInteractable = null;

            // Check building entrances
            for (const building of currentMap.buildings) {
                if (building.enterable) {
                    const doorX = building.x + building.width / 2;
                    const doorY = GROUND_LEVEL;

                    const dist = Math.sqrt(
                        Math.pow(player.x + player.width / 2 - doorX, 2) +
                        Math.pow(player.y + player.height - doorY, 2)
                    );

                    if (dist < 60) {
                        nearInteractable = { type: 'building', building: building };
                        document.getElementById('interact-prompt').textContent = `[E] ENTER ${building.name.split('\n')[0]}`;
                        break;
                    }
                }
            }

            // Check cars
            if (!nearInteractable) {
                for (const car of currentMap.cars) {
                    if (car.canEnter) {
                        const dist = Math.sqrt(
                            Math.pow(player.x - car.x - 50, 2) +
                            Math.pow(player.y - (GROUND_LEVEL + 120), 2)
                        );

                        if (dist < 70) {
                            nearInteractable = { type: 'car', car: car };
                            document.getElementById('interact-prompt').textContent = '[E] ENTER CAR';
                            break;
                        }
                    }
                }
            }

            const promptEl = document.getElementById('interact-prompt');
            if (nearInteractable) {
                promptEl.classList.add('visible');
                player.nearInteractable = nearInteractable;
            } else {
                promptEl.classList.remove('visible');
                player.nearInteractable = null;
            }
        }

        function handleInteraction() {
            if (game.state === 'dialogue') {
                advanceDialogue();
                return;
            }

            if (game.state === 'interior') {
                if (player.nearInteractable) {
                    if (player.nearInteractable.type === 'exit') {
                        exitBuilding();
                    } else if (player.nearInteractable.type === 'npc') {
                        startDialogue(player.nearInteractable.npc.id);
                    }
                }
                return;
            }

            if (game.state === 'playing' && player.nearInteractable) {
                if (player.nearInteractable.type === 'building') {
                    const building = player.nearInteractable.building;
                    if (INTERIORS[building.interiorId]) {
                        enterBuilding(building.interiorId);
                    }
                } else if (player.nearInteractable.type === 'car') {
                    // TODO: Enter car / driving mode
                }
            }
        }

        function updateGameTime() {
            // Advance game time (1 real second = 1 game minute)
            game.time.minutes += CONFIG.GAME_SPEED;

            if (game.time.minutes >= 60) {
                game.time.minutes = 0;
                game.time.hours++;

                if (game.time.hours >= 24) {
                    game.time.hours = 0;
                    game.day++;
                }
            }

            // Update clock display
            const hours = game.time.hours % 12 || 12;
            const minutes = String(game.time.minutes).padStart(2, '0');
            const ampm = game.time.hours >= 12 ? 'PM' : 'AM';
            document.getElementById('clock').textContent = `${hours}:${minutes} ${ampm}`;
        }

        function updateLocationDisplay() {
            const locDisplay = document.getElementById('location-display');

            // Determine current area based on player position
            let currentLocation = currentMap.name;

            for (const building of currentMap.buildings) {
                const nearDoor = Math.abs(player.x - (building.x + building.width / 2)) < 100 &&
                                 Math.abs(player.y - (building.y + building.height)) < 80;

                if (nearDoor) {
                    currentLocation = building.name.split('\n')[0];
                    break;
                }
            }

            if (locDisplay.textContent !== currentLocation) {
                locDisplay.textContent = currentLocation;
                locDisplay.classList.add('visible');

                setTimeout(() => {
                    locDisplay.classList.remove('visible');
                }, 3000);
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, 150, 120);

            const scale = 150 / currentMap.width;

            // Draw buildings
            minimapCtx.fillStyle = '#3d3d3d';
            for (const building of currentMap.buildings) {
                minimapCtx.fillRect(
                    building.x * scale,
                    building.y * scale * 0.8,
                    building.width * scale,
                    building.height * scale * 0.8
                );
            }

            // Draw player
            minimapCtx.fillStyle = '#c4a35a';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale * 0.8, 3, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw viewport rectangle
            minimapCtx.strokeStyle = '#8b7355';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale * 0.8,
                CONFIG.CANVAS_WIDTH * scale,
                CONFIG.CANVAS_HEIGHT * scale * 0.8
            );
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================

        let lastTime = 0;
        let timeAccumulator = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Update game time every second
            timeAccumulator += deltaTime;
            if (timeAccumulator >= 1000) {
                updateGameTime();
                timeAccumulator = 0;
            }

            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Initialize world state on first frame
            if (!worldState.initialized) {
                initWorldState();
            }

            if (game.state === 'playing') {
                updatePlayer();
                updateLocationDisplay();

                // Draw scene
                drawSky();
                drawGround();

                // Draw street lights (back layer glow)
                for (const light of currentMap.streetLights) {
                    drawStreetLight(light);
                }

                // Draw buildings
                for (const building of currentMap.buildings) {
                    drawBuilding(building);
                }

                // Draw street props (behind characters)
                drawStreetProps();

                // Draw cars
                for (const car of currentMap.cars) {
                    drawCar(car);
                }

                // Collect all drawable entities and sort by Y for proper depth
                const entities = [];

                // Add NPCs
                for (const npc of npcs.filter(n => n.location !== 'interior')) {
                    const state = worldState.npcStates[npc.id];
                    if (state) {
                        entities.push({ type: 'npc', data: npc, y: state.y });
                    }
                }

                // Add player
                entities.push({ type: 'player', data: player, y: player.y });

                // Sort by Y position (painter's algorithm)
                entities.sort((a, b) => a.y - b.y);

                // Draw sorted entities
                for (const entity of entities) {
                    if (entity.type === 'player') {
                        drawPlayer();
                    } else if (entity.type === 'npc') {
                        drawNPC(entity.data);
                    }
                }

                // Draw minimap
                drawMinimap();
            } else if (game.state === 'interior' || game.state === 'dialogue') {
                updatePlayer();
                drawInterior();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        document.addEventListener('keydown', (e) => {
            if (game.state === 'title') {
                game.state = 'playing';
                document.getElementById('title-screen').classList.add('hidden');
                return;
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    if (!keys.interact) {
                        handleInteraction();
                    }
                    keys.interact = true;
                    break;
                case ' ':
                    keys.action = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    keys.interact = false;
                    break;
                case ' ':
                    keys.action = false;
                    break;
            }
        });

        // Touch controls
        function setupTouchControl(id, key) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
            btn.addEventListener('mousedown', () => keys[key] = true);
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }

        setupTouchControl('d-up', 'up');
        setupTouchControl('d-down', 'down');
        setupTouchControl('d-left', 'left');
        setupTouchControl('d-right', 'right');

        document.getElementById('btn-interact').addEventListener('click', () => {
            handleInteraction();
            keys.interact = true;
            setTimeout(() => keys.interact = false, 100);
        });

        document.getElementById('btn-action').addEventListener('click', () => {
            keys.action = true;
            setTimeout(() => keys.action = false, 100);
        });

        // Click/tap to start
        document.getElementById('title-screen').addEventListener('click', () => {
            game.state = 'playing';
            document.getElementById('title-screen').classList.add('hidden');
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            // Position player on sidewalk in front of PI office
            player.x = 250;
            player.y = GROUND_LEVEL - 20;

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>

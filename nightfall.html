<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NIGHTFALL - A Noir Detective Mystery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&family=Bebas+Neue&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
        }

        #game-canvas {
            background: #0d0d0d;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Film grain overlay */
        #film-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.08;
            z-index: 100;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Vignette effect */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.7) 100%);
        }

        /* Scanlines */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 98;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            color: #d4c5a9;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #hud .stat {
            margin-bottom: 8px;
            font-size: 14px;
            letter-spacing: 1px;
        }

        #hud .label {
            color: #8b7355;
            text-transform: uppercase;
            font-size: 10px;
        }

        #hud .value {
            color: #e8d5b7;
            font-size: 16px;
        }

        /* Location indicator */
        #location-display {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 24px;
            letter-spacing: 4px;
            color: #d4c5a9;
            text-shadow: 0 0 20px rgba(212, 197, 169, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #location-display.visible {
            opacity: 1;
        }

        /* Time display */
        #time-display {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 50;
            font-family: 'Special Elite', monospace;
            text-align: right;
        }

        #time-display .time {
            font-size: 28px;
            color: #e8d5b7;
            text-shadow: 0 0 10px rgba(232, 213, 183, 0.3);
        }

        #time-display .date {
            font-size: 12px;
            color: #8b7355;
            letter-spacing: 2px;
        }

        /* Controls */
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(30, 25, 20, 0.8);
            border: 1px solid #3d3428;
            color: #8b7355;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        .d-btn:hover, .d-btn:active {
            background: rgba(60, 50, 40, 0.9);
            color: #d4c5a9;
        }

        #d-up { top: 0; left: 40px; border-radius: 8px 8px 0 0; }
        #d-down { bottom: 0; left: 40px; border-radius: 0 0 8px 8px; }
        #d-left { top: 40px; left: 0; border-radius: 8px 0 0 8px; }
        #d-right { top: 40px; right: 0; border-radius: 0 8px 8px 0; }
        #d-center { top: 40px; left: 40px; background: rgba(20, 16, 12, 0.9); cursor: default; }

        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(139, 69, 19, 0.6);
            border: 2px solid #8b7355;
            color: #d4c5a9;
            font-family: 'Special Elite', monospace;
            font-size: 10px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .action-btn:hover, .action-btn:active {
            background: rgba(180, 100, 40, 0.7);
            transform: scale(1.05);
        }

        /* Title screen */
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        #title-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #title-screen h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 120px;
            letter-spacing: 20px;
            color: #d4c5a9;
            text-shadow:
                0 0 40px rgba(212, 197, 169, 0.3),
                0 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }

        #title-screen .subtitle {
            font-family: 'Special Elite', monospace;
            font-size: 16px;
            letter-spacing: 8px;
            color: #8b7355;
            margin-bottom: 60px;
        }

        #title-screen .year {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 48px;
            color: #3d3428;
            letter-spacing: 15px;
            margin-bottom: 80px;
        }

        #title-screen .start-prompt {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            letter-spacing: 4px;
            color: #8b7355;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Dialogue box */
        #dialogue-box {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
            background: rgba(15, 12, 10, 0.95);
            border: 1px solid #3d3428;
            padding: 20px 25px;
            z-index: 60;
            display: none;
        }

        #dialogue-box.visible {
            display: block;
        }

        #dialogue-speaker {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 3px;
            color: #c4a35a;
            margin-bottom: 10px;
        }

        #dialogue-text {
            font-family: 'Special Elite', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #d4c5a9;
        }

        /* Interaction prompt */
        #interact-prompt {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Special Elite', monospace;
            font-size: 12px;
            letter-spacing: 2px;
            color: #c4a35a;
            background: rgba(15, 12, 10, 0.8);
            padding: 8px 16px;
            border: 1px solid #3d3428;
            z-index: 55;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #interact-prompt.visible {
            opacity: 1;
        }

        /* Mini map */
        #minimap {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 150px;
            height: 120px;
            background: rgba(15, 12, 10, 0.8);
            border: 1px solid #3d3428;
            z-index: 50;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            #title-screen h1 {
                font-size: 60px;
                letter-spacing: 10px;
            }

            #title-screen .year {
                font-size: 32px;
            }

            #minimap {
                width: 100px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- Film effects -->
        <div id="film-grain"></div>
        <div id="vignette"></div>
        <div id="scanlines"></div>

        <!-- Title Screen -->
        <div id="title-screen">
            <h1>NIGHTFALL</h1>
            <div class="subtitle">A NOIR DETECTIVE MYSTERY</div>
            <div class="year">1 9 5 9</div>
            <div class="start-prompt">PRESS ANY KEY TO BEGIN</div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div class="stat">
                <div class="label">Cash</div>
                <div class="value" id="cash-display">$50.00</div>
            </div>
            <div class="stat">
                <div class="label">Reputation</div>
                <div class="value" id="rep-display">■■■□□</div>
            </div>
            <div class="stat">
                <div class="label">Case</div>
                <div class="value" id="case-display">None</div>
            </div>
        </div>

        <!-- Time -->
        <div id="time-display">
            <div class="date">OCTOBER 14, 1959</div>
            <div class="time" id="clock">8:47 PM</div>
        </div>

        <!-- Location -->
        <div id="location-display">DOWNTOWN</div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <!-- Interaction prompt -->
        <div id="interact-prompt">[E] ENTER</div>

        <!-- Dialogue -->
        <div id="dialogue-box">
            <div id="dialogue-speaker">STRANGER</div>
            <div id="dialogue-text">The night has a way of revealing what the day keeps hidden...</div>
        </div>

        <!-- Controls -->
        <div id="controls">
            <div id="d-pad">
                <div class="d-btn" id="d-up">▲</div>
                <div class="d-btn" id="d-down">▼</div>
                <div class="d-btn" id="d-left">◄</div>
                <div class="d-btn" id="d-right">►</div>
                <div class="d-btn" id="d-center"></div>
            </div>
            <button class="action-btn" id="btn-interact">Enter</button>
            <button class="action-btn" id="btn-action">Action</button>
        </div>
    </div>

    <script>
        // ============================================
        // NIGHTFALL - A Noir Detective Mystery
        // Set in 1959 small-town America
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Game configuration
        const CONFIG = {
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 700,
            TILE_SIZE: 60,
            PLAYER_SPEED: 3,
            CAR_SPEED: 8,
            GAME_SPEED: 1, // Time multiplier
            SHADOW_LENGTH: 2.5,
            AMBIENT_LIGHT: 0.15
        };

        // Set canvas size
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;
        minimapCanvas.width = 150;
        minimapCanvas.height = 120;

        // Color palette - 1959 Noir
        const COLORS = {
            // Sky and atmosphere
            nightSky: '#0a0a14',
            twilightSky: '#1a1a2e',
            duskSky: '#2d1f3d',

            // Buildings
            brick: '#3d2b1f',
            brickDark: '#2a1d15',
            brickLight: '#4a3828',
            concrete: '#4a4a4a',
            concreteDark: '#333333',
            wood: '#5c4033',
            woodDark: '#3d2a22',

            // Windows and lights
            windowLit: '#e8c36a',
            windowDim: '#8b7355',
            windowDark: '#1a1a1a',
            neonRed: '#ff3333',
            neonBlue: '#3366ff',
            neonGreen: '#33ff66',
            streetLight: '#ffedcc',

            // Ground
            asphalt: '#2a2a2a',
            asphaltLight: '#3a3a3a',
            sidewalk: '#5a5a5a',
            sidewalkLight: '#6a6a6a',

            // Characters
            skin: '#d4a574',
            skinShadow: '#a67c52',
            suit: '#1a1a1a',
            suitGray: '#3d3d3d',
            hat: '#2a2a2a',

            // UI
            gold: '#c4a35a',
            cream: '#d4c5a9',
            shadow: 'rgba(0,0,0,0.7)'
        };

        // Game state
        const game = {
            state: 'title', // title, playing, dialogue, inventory, paused
            currentLevel: 1, // 1: Downtown, 2: Residential, 3: Industrial
            time: { hours: 20, minutes: 47 }, // 8:47 PM
            day: 1,
            cash: 50.00,
            reputation: 3, // 1-5
            currentCase: null,
            killerSchedule: [],
            killerStrikeTime: null
        };

        // Player state
        const player = {
            x: 600,
            y: 400,
            width: 24,
            height: 64,
            speed: CONFIG.PLAYER_SPEED,
            direction: 'right', // up, down, left, right
            facing: 1, // 1 = right, -1 = left
            isMoving: false,
            walkCycle: 0,
            inCar: false,
            car: null,
            inventory: [],
            weapon: 'fists', // fists, pistol
            flashlightOn: false
        };

        // ============================================
        // OBJECT PERMANENCY SYSTEM
        // ============================================
        const worldState = {
            // Window states persist - seeded by building ID
            windowStates: {},
            // NPC positions and states persist
            npcStates: {},
            // Props placed in world
            props: [],
            // Items dropped/placed
            items: [],
            // Doors opened/closed
            doorStates: {},
            // Events that have occurred
            events: [],
            initialized: false
        };

        // Initialize persistent world state
        function initWorldState() {
            if (worldState.initialized) return;

            // Generate consistent window states for each building
            currentMap.buildings.forEach(building => {
                const windowCount = Math.floor((building.width - 40) / 50) * building.floors;
                worldState.windowStates[building.id] = [];

                // Use building position as seed for consistency
                let seed = building.x * 100 + building.y;
                for (let i = 0; i < windowCount; i++) {
                    seed = (seed * 9301 + 49297) % 233280;
                    worldState.windowStates[building.id].push({
                        lit: (seed / 233280) > 0.35,
                        blindsDown: (seed / 233280) > 0.6,
                        silhouette: (seed / 233280) > 0.85 ? 'person' : null
                    });
                }
            });

            // Initialize NPC states with persistent positions
            npcs.forEach(npc => {
                worldState.npcStates[npc.id] = {
                    x: npc.x,
                    y: npc.y,
                    activity: 'idle',
                    facingRight: true,
                    talked: false,
                    bribed: false,
                    lastInteraction: null
                };
            });

            // Add street props
            worldState.props = [
                // Phone booths
                { type: 'phonebooth', x: 520, y: 435 },
                { type: 'phonebooth', x: 1180, y: 435 },
                // Benches
                { type: 'bench', x: 350, y: 440 },
                { type: 'bench', x: 680, y: 440 },
                // Trash cans
                { type: 'trashcan', x: 150, y: 445 },
                { type: 'trashcan', x: 580, y: 445 },
                { type: 'trashcan', x: 870, y: 445 },
                { type: 'trashcan', x: 1130, y: 445 },
                // Fire hydrants
                { type: 'hydrant', x: 260, y: 448 },
                { type: 'hydrant', x: 760, y: 448 },
                { type: 'hydrant', x: 1050, y: 448 },
                // Newspaper stands
                { type: 'newsstand', x: 420, y: 438 },
                // Mailboxes
                { type: 'mailbox', x: 620, y: 442 },
                { type: 'mailbox', x: 980, y: 442 },
                // Street signs
                { type: 'streetsign', x: 300, y: 400, text: 'MAIN ST' },
                { type: 'streetsign', x: 900, y: 400, text: 'ELM AVE' },
                // Lamp posts (additional atmosphere)
                { type: 'alley_light', x: 1350, y: 520 }
            ];

            worldState.initialized = true;
        }

        // Camera
        const camera = {
            x: 0,
            y: 0,
            width: CONFIG.CANVAS_WIDTH,
            height: CONFIG.CANVAS_HEIGHT
        };

        // Input state
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            interact: false,
            action: false
        };

        // Town map - Level 1: Downtown
        const DOWNTOWN = {
            width: 2400,
            height: 1400,
            name: 'DOWNTOWN',
            buildings: [
                // Office Building (with PI office, accountant, attorney)
                {
                    id: 'office_building',
                    x: 100, y: 200,
                    width: 400, height: 250,
                    type: 'office',
                    name: "PROFESSIONAL BUILDING",
                    floors: 1,
                    color: COLORS.brick,
                    offices: [
                        { name: "MILLER & ASSOCIATES\nTAX ACCOUNTANT", x: 0, door: true },
                        { name: "JAMES CRAWFORD\nATTORNEY AT LAW", x: 1, door: true },
                        { name: "JACK NOIR\nPRIVATE INVESTIGATOR", x: 2, door: true, isPlayerOffice: true }
                    ],
                    enterable: true,
                    interiorId: 'pi_office'
                },

                // Cafe
                {
                    id: 'cafe',
                    x: 550, y: 200,
                    width: 250, height: 220,
                    type: 'cafe',
                    name: "ROSIE'S DINER",
                    floors: 1,
                    color: COLORS.brickLight,
                    hasNeon: true,
                    neonText: "OPEN 24 HRS",
                    neonColor: COLORS.neonRed,
                    enterable: true,
                    interiorId: 'cafe'
                },

                // Pharmacy
                {
                    id: 'pharmacy',
                    x: 850, y: 200,
                    width: 200, height: 220,
                    type: 'pharmacy',
                    name: "COLEMAN'S\nPHARMACY",
                    floors: 1,
                    color: COLORS.concrete,
                    hasNeon: true,
                    neonText: "Rx",
                    neonColor: COLORS.neonGreen,
                    enterable: true,
                    interiorId: 'pharmacy'
                },

                // Bookstore
                {
                    id: 'bookstore',
                    x: 1100, y: 200,
                    width: 220, height: 220,
                    type: 'bookstore',
                    name: "CHAPTER & VERSE\nBOOKS",
                    floors: 1,
                    color: COLORS.wood,
                    enterable: true,
                    interiorId: 'bookstore'
                },

                // Bar
                {
                    id: 'bar',
                    x: 100, y: 550,
                    width: 280, height: 200,
                    type: 'bar',
                    name: "THE BLUE MOON",
                    floors: 1,
                    color: COLORS.brickDark,
                    hasNeon: true,
                    neonText: "COCKTAILS",
                    neonColor: COLORS.neonBlue,
                    enterable: true,
                    interiorId: 'bar'
                },

                // Movie Theater
                {
                    id: 'theater',
                    x: 450, y: 520,
                    width: 400, height: 280,
                    type: 'theater',
                    name: "PARAMOUNT THEATER",
                    floors: 2,
                    color: COLORS.concrete,
                    marquee: true,
                    nowPlaying: ["NORTH BY NORTHWEST", "THE NUN'S STORY"],
                    enterable: true,
                    interiorId: 'theater'
                },

                // Police Station
                {
                    id: 'police',
                    x: 900, y: 550,
                    width: 300, height: 230,
                    type: 'police',
                    name: "POLICE DEPARTMENT",
                    floors: 2,
                    color: COLORS.concreteDark,
                    enterable: true,
                    interiorId: 'police'
                },

                // Apartment Building
                {
                    id: 'apartments',
                    x: 1250, y: 480,
                    width: 200, height: 350,
                    type: 'apartment',
                    name: "LAKESIDE APARTMENTS",
                    floors: 3,
                    color: COLORS.brick,
                    apartments: [
                        { floor: 1, resident: "Mrs. Henderson" },
                        { floor: 2, resident: "Frank Torres" },
                        { floor: 3, resident: "Empty" }
                    ],
                    enterable: true,
                    interiorId: 'apartments'
                }
            ],

            // Street lights
            streetLights: [
                { x: 200, y: 470 },
                { x: 500, y: 470 },
                { x: 750, y: 470 },
                { x: 1000, y: 470 },
                { x: 1200, y: 470 },
                { x: 350, y: 820 },
                { x: 700, y: 820 },
                { x: 1050, y: 820 }
            ],

            // Parked cars
            cars: [
                { x: 280, y: 480, color: '#2a3d2a', model: 'sedan', canEnter: false },
                { x: 420, y: 480, color: '#4a2a2a', model: 'coupe', canEnter: false },
                { x: 800, y: 480, color: '#1a1a2a', model: 'sedan', canEnter: true }, // Player's car
                { x: 950, y: 850, color: '#3d3d3d', model: 'truck', canEnter: false }
            ],

            // NPCs on streets
            streetNPCs: []
        };

        // Current level reference
        let currentMap = DOWNTOWN;

        // NPCs
        const npcs = [
            // Cafe staff
            { id: 'waitress', name: 'Rosie', location: 'cafe', role: 'owner', x: 600, y: 280,
              dialogue: ["Coffee's hot, stranger.", "You look like you could use a cup."] },
            { id: 'cook', name: 'Earl', location: 'cafe', role: 'cook', x: 650, y: 300,
              dialogue: ["Order up!", "Kitchen's closing in an hour."] },

            // Pharmacy
            { id: 'pharmacist', name: 'Mr. Coleman', location: 'pharmacy', role: 'pharmacist', x: 900, y: 280,
              dialogue: ["Can I help you find something?", "Prescription ready in 10 minutes."] },

            // Bookstore
            { id: 'bookstore_husband', name: 'Harold', location: 'bookstore', role: 'owner', x: 1150, y: 280,
              dialogue: ["Looking for anything in particular?", "New shipment of mysteries came in."] },
            { id: 'bookstore_wife', name: 'Margaret', location: 'bookstore', role: 'owner', x: 1200, y: 300,
              dialogue: ["The poetry section is in the back.", "Harold, we have a customer."] },

            // Bar
            { id: 'bartender', name: 'Mickey', location: 'bar', role: 'bartender', x: 180, y: 620,
              dialogue: ["What'll it be?", "We don't want any trouble here."], canBeBribed: true },
            { id: 'barfly1', name: 'Old Joe', location: 'bar', role: 'patron', x: 220, y: 650,
              dialogue: ["*mumbles*", "Buy me a drink and I'll tell you something."], canBeBribed: true },

            // Theater
            { id: 'box_office', name: 'Betty', location: 'theater', role: 'employee', x: 550, y: 600,
              dialogue: ["Two screens tonight. Hitchcock or Hepburn?", "Show starts in fifteen."] },

            // Police
            { id: 'desk_sergeant', name: 'Sgt. O\'Brien', location: 'police', role: 'police', x: 1000, y: 620,
              dialogue: ["State your business.", "This is a police station, not a social club."] },

            // PI Office
            { id: 'secretary', name: 'Dolores', location: 'pi_office', role: 'secretary', x: 250, y: 280,
              dialogue: ["A client is waiting, Mr. Noir.", "The phone's been ringing all day."] }
        ];

        // Killer AI
        const killer = {
            id: 'the_stranger',
            currentLocation: 'bar',
            schedule: [
                { time: '19:00', location: 'cafe', action: 'eating' },
                { time: '20:30', location: 'bar', action: 'drinking' },
                { time: '22:00', location: 'street', action: 'stalking' },
                { time: '23:30', location: 'apartments', action: 'hunting' }
            ],
            urgeLevel: 0, // 0-100
            targetNPC: null,
            state: 'normal', // normal, agitated, hunting, attacking
            visible: true, // Blends in as normal NPC
            disguise: 'businessman'
        };

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);

            // Night sky gradient
            if (game.time.hours >= 21 || game.time.hours < 5) {
                gradient.addColorStop(0, '#050510');
                gradient.addColorStop(0.5, '#0a0a1a');
                gradient.addColorStop(1, '#0f0f20');
            } else if (game.time.hours >= 18) {
                // Dusk
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.3, '#2d1f3d');
                gradient.addColorStop(0.7, '#3d2a4a');
                gradient.addColorStop(1, '#1a1a2e');
            } else {
                // Day (we'll mostly be in evening/night)
                gradient.addColorStop(0, '#4a4a6e');
                gradient.addColorStop(1, '#2a2a4e');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Stars (at night)
            if (game.time.hours >= 20 || game.time.hours < 5) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 47 + camera.x * 0.1) % CONFIG.CANVAS_WIDTH;
                    const y = (i * 31) % (CONFIG.CANVAS_HEIGHT * 0.4);
                    const size = (i % 3) * 0.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawGround() {
            const groundY = CONFIG.CANVAS_HEIGHT - 250;

            // Street
            ctx.fillStyle = COLORS.asphalt;
            ctx.fillRect(0, groundY, CONFIG.CANVAS_WIDTH, 150);

            // Street lines
            ctx.strokeStyle = '#4a4a3a';
            ctx.lineWidth = 2;
            ctx.setLineDash([30, 20]);
            ctx.beginPath();
            ctx.moveTo(0, groundY + 75);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, groundY + 75);
            ctx.stroke();
            ctx.setLineDash([]);

            // Sidewalk - top
            ctx.fillStyle = COLORS.sidewalk;
            ctx.fillRect(0, groundY - 40, CONFIG.CANVAS_WIDTH, 40);

            // Sidewalk edge
            ctx.fillStyle = COLORS.sidewalkLight;
            ctx.fillRect(0, groundY - 5, CONFIG.CANVAS_WIDTH, 5);

            // Sidewalk - bottom
            ctx.fillStyle = COLORS.sidewalk;
            ctx.fillRect(0, groundY + 150, CONFIG.CANVAS_WIDTH, 60);
        }

        function drawBuilding(building) {
            const bx = building.x - camera.x;
            const by = building.y - camera.y;

            // Skip if off screen
            if (bx + building.width < -50 || bx > CONFIG.CANVAS_WIDTH + 50) return;

            // Building shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(bx + 10, by + 10, building.width, building.height);

            // Main building
            ctx.fillStyle = building.color;
            ctx.fillRect(bx, by, building.width, building.height);

            // Building texture (bricks or panels)
            if (building.type !== 'theater') {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                for (let row = 0; row < building.height; row += 15) {
                    for (let col = 0; col < building.width; col += 30) {
                        const offset = (row / 15) % 2 === 0 ? 0 : 15;
                        ctx.strokeRect(bx + col + offset, by + row, 30, 15);
                    }
                }
            }

            // Windows
            drawBuildingWindows(building, bx, by);

            // Door
            drawBuildingDoor(building, bx, by);

            // Sign/Name
            drawBuildingSign(building, bx, by);

            // Neon sign if applicable
            if (building.hasNeon) {
                drawNeonSign(building, bx, by);
            }

            // Theater marquee
            if (building.marquee) {
                drawTheaterMarquee(building, bx, by);
            }

            // Roof detail
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by, building.width, 8);
        }

        function drawBuildingWindows(building, bx, by) {
            const windowWidth = 35;
            const windowHeight = 45;
            const windowSpacing = 50;
            const windowsPerFloor = Math.floor((building.width - 40) / windowSpacing);
            const floorHeight = building.height / building.floors;

            // Get persistent window states for this building
            const windowStates = worldState.windowStates[building.id] || [];

            let windowIndex = 0;
            for (let floor = 0; floor < building.floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    const wx = bx + 30 + w * windowSpacing;
                    const wy = by + 30 + floor * floorHeight;

                    // Get this window's persistent state
                    const state = windowStates[windowIndex] || { lit: false, blindsDown: false, silhouette: null };
                    windowIndex++;

                    // Window frame (deeper recess)
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(wx - 2, wy - 2, windowWidth + 4, windowHeight + 4);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(wx, wy, windowWidth, windowHeight);

                    if (state.lit) {
                        // Warm interior light gradient
                        const gradient = ctx.createLinearGradient(wx, wy, wx, wy + windowHeight);
                        gradient.addColorStop(0, '#f0d890');
                        gradient.addColorStop(0.5, COLORS.windowLit);
                        gradient.addColorStop(1, COLORS.windowDim);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Window glow (subtle)
                        ctx.shadowColor = COLORS.windowLit;
                        ctx.shadowBlur = 12;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);
                        ctx.shadowBlur = 0;

                        // Blinds (if down - persistent)
                        if (state.blindsDown) {
                            ctx.fillStyle = 'rgba(180, 160, 120, 0.7)';
                            ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 8);

                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                            ctx.lineWidth = 1;
                            for (let b = 0; b < 6; b++) {
                                ctx.beginPath();
                                ctx.moveTo(wx + 2, wy + 6 + b * 6);
                                ctx.lineTo(wx + windowWidth - 2, wy + 6 + b * 6);
                                ctx.stroke();
                            }
                        }

                        // Silhouette in window (persistent)
                        if (state.silhouette === 'person' && !state.blindsDown) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            // Head
                            ctx.beginPath();
                            ctx.arc(wx + windowWidth/2, wy + 15, 6, 0, Math.PI * 2);
                            ctx.fill();
                            // Shoulders
                            ctx.beginPath();
                            ctx.moveTo(wx + windowWidth/2 - 10, wy + 35);
                            ctx.lineTo(wx + windowWidth/2 - 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 8, wy + 22);
                            ctx.lineTo(wx + windowWidth/2 + 10, wy + 35);
                            ctx.closePath();
                            ctx.fill();
                        }
                    } else {
                        // Dark window with subtle reflection
                        ctx.fillStyle = COLORS.windowDark;
                        ctx.fillRect(wx + 2, wy + 2, windowWidth - 4, windowHeight - 4);

                        // Night sky reflection
                        ctx.fillStyle = 'rgba(30, 30, 50, 0.5)';
                        ctx.fillRect(wx + 3, wy + 3, windowWidth - 6, windowHeight / 3);
                    }

                    // Window cross frame
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(wx + windowWidth / 2, wy);
                    ctx.lineTo(wx + windowWidth / 2, wy + windowHeight);
                    ctx.moveTo(wx, wy + windowHeight / 2);
                    ctx.lineTo(wx + windowWidth, wy + windowHeight / 2);
                    ctx.stroke();

                    // Window sill
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(wx - 2, wy + windowHeight, windowWidth + 4, 3);
                }
            }
        }

        function drawBuildingDoor(building, bx, by) {
            const doorWidth = 40;
            const doorHeight = 70;
            const doorX = bx + building.width / 2 - doorWidth / 2;
            const doorY = by + building.height - doorHeight;

            // Door frame
            ctx.fillStyle = '#1a1410';
            ctx.fillRect(doorX - 5, doorY - 5, doorWidth + 10, doorHeight + 5);

            // Door
            ctx.fillStyle = '#2a2015';
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);

            // Door window (for offices)
            if (building.type === 'office') {
                ctx.fillStyle = 'rgba(200, 180, 140, 0.3)';
                ctx.fillRect(doorX + 5, doorY + 10, doorWidth - 10, 30);

                // Glass text effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.font = '6px Special Elite';
                ctx.textAlign = 'center';
                ctx.fillText('ENTER', doorX + doorWidth / 2, doorY + 28);
            }

            // Door handle
            ctx.fillStyle = '#c4a35a';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth - 10, doorY + doorHeight / 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Light above door
            ctx.fillStyle = COLORS.windowLit;
            ctx.shadowColor = COLORS.windowLit;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(doorX + doorWidth / 2, doorY - 15, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawBuildingSign(building, bx, by) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(bx + 10, by - 35, building.width - 20, 30);

            ctx.fillStyle = COLORS.cream;
            ctx.font = 'bold 12px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lines = building.name.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, bx + building.width / 2, by - 25 + i * 12);
            });
        }

        function drawNeonSign(building, bx, by) {
            const signX = bx + building.width - 80;
            const signY = by + 20;

            // Neon glow
            ctx.shadowColor = building.neonColor;
            ctx.shadowBlur = 20;

            ctx.strokeStyle = building.neonColor;
            ctx.lineWidth = 3;
            ctx.font = 'bold 16px Bebas Neue';
            ctx.textAlign = 'center';

            // Flicker effect
            const flicker = Math.random() > 0.95 ? 0.5 : 1;
            ctx.globalAlpha = flicker;

            ctx.fillStyle = building.neonColor;
            ctx.fillText(building.neonText, signX + 30, signY + 15);

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawTheaterMarquee(building, bx, by) {
            const marqueeWidth = building.width - 40;
            const marqueeHeight = 80;
            const marqueeX = bx + 20;
            const marqueeY = by - 60;

            // Marquee structure
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(marqueeX, marqueeY, marqueeWidth, marqueeHeight);

            // Border lights
            ctx.fillStyle = COLORS.windowLit;
            const bulbSpacing = 15;
            for (let i = 0; i < marqueeWidth / bulbSpacing; i++) {
                const flicker = Math.random() > 0.9 ? 0.3 : 1;
                ctx.globalAlpha = flicker;
                ctx.shadowColor = COLORS.windowLit;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(marqueeX + 7 + i * bulbSpacing, marqueeY + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(marqueeX + 7 + i * bulbSpacing, marqueeY + marqueeHeight - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Now playing text
            ctx.fillStyle = '#ff3333';
            ctx.font = 'bold 10px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('NOW PLAYING', marqueeX + marqueeWidth / 2, marqueeY + 25);

            ctx.fillStyle = COLORS.cream;
            ctx.font = 'bold 14px Bebas Neue';
            building.nowPlaying.forEach((movie, i) => {
                ctx.fillText(movie, marqueeX + marqueeWidth / 2, marqueeY + 45 + i * 18);
            });
        }

        function drawStreetLight(light) {
            const lx = light.x - camera.x;
            const ly = light.y - camera.y;

            if (lx < -50 || lx > CONFIG.CANVAS_WIDTH + 50) return;

            // Pole
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(lx - 3, ly, 6, 80);

            // Lamp head
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(lx - 15, ly);
            ctx.lineTo(lx + 15, ly);
            ctx.lineTo(lx + 10, ly - 20);
            ctx.lineTo(lx - 10, ly - 20);
            ctx.closePath();
            ctx.fill();

            // Light glow
            const gradient = ctx.createRadialGradient(lx, ly + 10, 0, lx, ly + 10, 150);
            gradient.addColorStop(0, 'rgba(255, 237, 200, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 237, 200, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 237, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(lx, ly + 80, 150, 80, 0, 0, Math.PI * 2);
            ctx.fill();

            // Light bulb
            ctx.fillStyle = COLORS.streetLight;
            ctx.shadowColor = COLORS.streetLight;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(lx, ly + 5, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawCar(car) {
            const cx = car.x - camera.x;
            const cy = car.y - camera.y;

            if (cx < -100 || cx > CONFIG.CANVAS_WIDTH + 100) return;

            // Car shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.ellipse(cx + 50, cy + 35, 55, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Car body (1950s style)
            ctx.fillStyle = car.color;

            // Lower body
            ctx.beginPath();
            ctx.moveTo(cx, cy + 15);
            ctx.lineTo(cx + 10, cy + 30);
            ctx.lineTo(cx + 90, cy + 30);
            ctx.lineTo(cx + 100, cy + 15);
            ctx.lineTo(cx + 95, cy + 5);
            ctx.lineTo(cx + 5, cy + 5);
            ctx.closePath();
            ctx.fill();

            // Roof
            ctx.beginPath();
            ctx.moveTo(cx + 20, cy + 5);
            ctx.lineTo(cx + 25, cy - 15);
            ctx.lineTo(cx + 75, cy - 15);
            ctx.lineTo(cx + 80, cy + 5);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = 'rgba(100, 120, 140, 0.7)';
            ctx.beginPath();
            ctx.moveTo(cx + 27, cy + 3);
            ctx.lineTo(cx + 30, cy - 12);
            ctx.lineTo(cx + 48, cy - 12);
            ctx.lineTo(cx + 48, cy + 3);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cx + 52, cy + 3);
            ctx.lineTo(cx + 52, cy - 12);
            ctx.lineTo(cx + 70, cy - 12);
            ctx.lineTo(cx + 73, cy + 3);
            ctx.closePath();
            ctx.fill();

            // Chrome trim
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 5, cy + 15);
            ctx.lineTo(cx + 95, cy + 15);
            ctx.stroke();

            // Wheels
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(cx + 20, cy + 28, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 80, cy + 28, 10, 0, Math.PI * 2);
            ctx.fill();

            // Hubcaps
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.arc(cx + 20, cy + 28, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 80, cy + 28, 5, 0, Math.PI * 2);
            ctx.fill();

            // Headlights
            ctx.fillStyle = '#ffeecc';
            ctx.shadowColor = '#ffeecc';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(cx + 95, cy + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Taillights
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(cx + 5, cy + 10, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // MANNEQUIN-STYLE CHARACTER RENDERING
        // Angular, art deco influenced, elongated proportions
        // ============================================

        function drawMannequin(x, y, options = {}) {
            const {
                facing = 1,           // 1 = right, -1 = left
                isMoving = false,
                walkCycle = 0,
                outfit = 'detective', // detective, suit, dress, worker, casual
                hatType = 'fedora',   // fedora, none, bowler, pillbox
                lightFactor = 1,
                isPlayer = false
            } = options;

            const cx = x;  // center x
            const cy = y;  // feet y position

            // Character proportions (mannequin style - elongated)
            const scale = 1;
            const headHeight = 10 * scale;
            const neckHeight = 4 * scale;
            const torsoHeight = 18 * scale;
            const legHeight = 28 * scale;
            const armLength = 20 * scale;
            const shoulderWidth = 14 * scale;
            const hipWidth = 8 * scale;
            const headWidth = 8 * scale;

            // Walk animation
            const walkPhase = isMoving ? Math.sin(walkCycle * 0.15) : 0;
            const legSwing = walkPhase * 8;
            const armSwing = walkPhase * 6;
            const bodyBob = Math.abs(walkPhase) * 2;

            // Calculate key points
            const feetY = cy;
            const hipY = feetY - legHeight;
            const shoulderY = hipY - torsoHeight;
            const neckY = shoulderY - neckHeight;
            const headCenterY = neckY - headHeight / 2;

            // Long dramatic shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(cx, feetY + 3, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Extended shadow for noir effect
            if (lightFactor > 0.5) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.moveTo(cx - 8, feetY);
                ctx.lineTo(cx + 40, feetY + 60);
                ctx.lineTo(cx + 50, feetY + 58);
                ctx.lineTo(cx + 8, feetY);
                ctx.closePath();
                ctx.fill();
            }

            ctx.save();
            ctx.translate(cx, 0);
            ctx.scale(facing, 1);
            ctx.translate(-cx, 0);

            // === LEGS (angular, defined) ===
            const leftFootX = cx - 4 + (isMoving ? legSwing : 0);
            const rightFootX = cx + 4 + (isMoving ? -legSwing : 0);
            const leftKneeX = cx - 3 + (isMoving ? legSwing * 0.3 : 0);
            const rightKneeX = cx + 3 + (isMoving ? -legSwing * 0.3 : 0);
            const kneeY = hipY + legHeight * 0.55;

            // Left leg
            ctx.strokeStyle = adjustBrightness('#1a1a1a', lightFactor);
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(cx - hipWidth/2, hipY - bodyBob);
            ctx.lineTo(leftKneeX, kneeY - bodyBob);
            ctx.lineTo(leftFootX, feetY);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(cx + hipWidth/2 - 2, hipY - bodyBob);
            ctx.lineTo(rightKneeX, kneeY - bodyBob);
            ctx.lineTo(rightFootX, feetY);
            ctx.stroke();

            // Shoes (angular)
            ctx.fillStyle = adjustBrightness('#0f0f0f', lightFactor);
            // Left shoe
            ctx.beginPath();
            ctx.moveTo(leftFootX - 5, feetY);
            ctx.lineTo(leftFootX + 6, feetY);
            ctx.lineTo(leftFootX + 4, feetY - 4);
            ctx.lineTo(leftFootX - 3, feetY - 4);
            ctx.closePath();
            ctx.fill();
            // Right shoe
            ctx.beginPath();
            ctx.moveTo(rightFootX - 5, feetY);
            ctx.lineTo(rightFootX + 6, feetY);
            ctx.lineTo(rightFootX + 4, feetY - 4);
            ctx.lineTo(rightFootX - 3, feetY - 4);
            ctx.closePath();
            ctx.fill();

            // === TORSO (trench coat / suit - angular cut) ===
            const coatColor = outfit === 'detective' ? '#2a2520' : '#1a1a1a';

            // Coat body - angular trapezoid
            ctx.fillStyle = adjustBrightness(coatColor, lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - shoulderWidth/2, shoulderY - bodyBob);
            ctx.lineTo(cx + shoulderWidth/2, shoulderY - bodyBob);
            ctx.lineTo(cx + hipWidth/2 + 2, hipY + 4 - bodyBob);
            ctx.lineTo(cx - hipWidth/2 - 2, hipY + 4 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Coat lapels (V-shape detail)
            ctx.strokeStyle = adjustBrightness('#1a1815', lightFactor);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 3, shoulderY + 2 - bodyBob);
            ctx.lineTo(cx, shoulderY + 10 - bodyBob);
            ctx.lineTo(cx + 3, shoulderY + 2 - bodyBob);
            ctx.stroke();

            // Coat center line
            ctx.strokeStyle = adjustBrightness('#151310', lightFactor);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx, shoulderY + 10 - bodyBob);
            ctx.lineTo(cx, hipY + 2 - bodyBob);
            ctx.stroke();

            // === ARMS (angular, hinged at elbow) ===
            const shoulderOffsetX = shoulderWidth/2 - 1;
            const elbowY = shoulderY + armLength * 0.45 - bodyBob;
            const handY = shoulderY + armLength - bodyBob;

            // Left arm
            const leftElbowX = cx - shoulderOffsetX - 3 + (isMoving ? -armSwing * 0.5 : 0);
            const leftHandX = cx - shoulderOffsetX - 1 + (isMoving ? -armSwing : 0);
            const leftHandY = handY + (isMoving ? armSwing * 0.3 : 0);

            ctx.strokeStyle = adjustBrightness(coatColor, lightFactor);
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx - shoulderOffsetX, shoulderY + 2 - bodyBob);
            ctx.lineTo(leftElbowX, elbowY);
            ctx.lineTo(leftHandX, leftHandY);
            ctx.stroke();

            // Right arm
            const rightElbowX = cx + shoulderOffsetX + 3 + (isMoving ? armSwing * 0.5 : 0);
            const rightHandX = cx + shoulderOffsetX + 1 + (isMoving ? armSwing : 0);
            const rightHandY = handY + (isMoving ? -armSwing * 0.3 : 0);

            ctx.beginPath();
            ctx.moveTo(cx + shoulderOffsetX, shoulderY + 2 - bodyBob);
            ctx.lineTo(rightElbowX, elbowY);
            ctx.lineTo(rightHandX, rightHandY);
            ctx.stroke();

            // Hands (small angular)
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.beginPath();
            ctx.moveTo(leftHandX - 2, leftHandY);
            ctx.lineTo(leftHandX + 2, leftHandY);
            ctx.lineTo(leftHandX + 1, leftHandY + 4);
            ctx.lineTo(leftHandX - 1, leftHandY + 4);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(rightHandX - 2, rightHandY);
            ctx.lineTo(rightHandX + 2, rightHandY);
            ctx.lineTo(rightHandX + 1, rightHandY + 4);
            ctx.lineTo(rightHandX - 1, rightHandY + 4);
            ctx.closePath();
            ctx.fill();

            // === NECK ===
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.fillRect(cx - 2, neckY - bodyBob, 4, neckHeight + 2);

            // Collar points
            ctx.fillStyle = adjustBrightness('#f5f0e6', lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - 4, shoulderY - bodyBob);
            ctx.lineTo(cx - 2, shoulderY - 4 - bodyBob);
            ctx.lineTo(cx, shoulderY - bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(cx, shoulderY - bodyBob);
            ctx.lineTo(cx + 2, shoulderY - 4 - bodyBob);
            ctx.lineTo(cx + 4, shoulderY - bodyBob);
            ctx.closePath();
            ctx.fill();

            // === HEAD (angular, geometric) ===
            // Jaw - angular
            ctx.fillStyle = adjustBrightness('#c4a882', lightFactor);
            ctx.beginPath();
            ctx.moveTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
            ctx.lineTo(cx - headWidth/2 + 1, headCenterY + headHeight/2 - 2 - bodyBob);
            ctx.lineTo(cx, headCenterY + headHeight/2 + 2 - bodyBob); // chin point
            ctx.lineTo(cx + headWidth/2 - 1, headCenterY + headHeight/2 - 2 - bodyBob);
            ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Upper head / forehead
            ctx.beginPath();
            ctx.moveTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
            ctx.lineTo(cx - headWidth/2 + 1, headCenterY - headHeight/2 - bodyBob);
            ctx.lineTo(cx + headWidth/2 - 1, headCenterY - headHeight/2 - bodyBob);
            ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
            ctx.closePath();
            ctx.fill();

            // Face shadow (one side for noir effect)
            if (lightFactor > 0.5) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.moveTo(cx, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx, headCenterY + headHeight/2 + 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2 + 1, headCenterY + headHeight/2 - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2 + 1, headCenterY - headHeight/2 - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            // Eyes (minimal, angular)
            if (lightFactor > 0.3) {
                ctx.fillStyle = adjustBrightness('#1a1a1a', lightFactor);
                // Angular eye shapes
                ctx.beginPath();
                ctx.moveTo(cx - 4, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx - 2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - 1, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx - 2, headCenterY - bodyBob);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(cx + 1, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx + 2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx + 4, headCenterY - 1 - bodyBob);
                ctx.lineTo(cx + 2, headCenterY - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            // === HAT (fedora - angular) ===
            if (hatType === 'fedora') {
                const hatY = headCenterY - headHeight/2 - 2 - bodyBob;

                // Hat brim - angular
                ctx.fillStyle = adjustBrightness('#1a1815', lightFactor);
                ctx.beginPath();
                ctx.moveTo(cx - 12, hatY + 3);
                ctx.lineTo(cx - 10, hatY);
                ctx.lineTo(cx + 10, hatY);
                ctx.lineTo(cx + 12, hatY + 3);
                ctx.lineTo(cx + 10, hatY + 4);
                ctx.lineTo(cx - 10, hatY + 4);
                ctx.closePath();
                ctx.fill();

                // Hat crown - angular with pinch
                ctx.beginPath();
                ctx.moveTo(cx - 7, hatY);
                ctx.lineTo(cx - 6, hatY - 8);
                ctx.lineTo(cx - 2, hatY - 10); // pinch
                ctx.lineTo(cx + 2, hatY - 10); // pinch
                ctx.lineTo(cx + 6, hatY - 8);
                ctx.lineTo(cx + 7, hatY);
                ctx.closePath();
                ctx.fill();

                // Hat band
                ctx.fillStyle = adjustBrightness('#3d352a', lightFactor);
                ctx.fillRect(cx - 6, hatY - 2, 12, 2);

                // Hat shadow on face
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(cx - headWidth/2, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx + headWidth/2, headCenterY - headHeight/2 - bodyBob);
                ctx.lineTo(cx + headWidth/2, headCenterY - 2 - bodyBob);
                ctx.lineTo(cx - headWidth/2, headCenterY - 2 - bodyBob);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        function drawPlayer() {
            const px = player.x - camera.x + player.width / 2;
            const py = player.y - camera.y + player.height;

            const inLight = isInLight(player.x, player.y);
            const lightFactor = inLight ? 1 : 0.35;

            if (player.isMoving) {
                player.walkCycle++;
            }

            drawMannequin(px, py, {
                facing: player.facing,
                isMoving: player.isMoving,
                walkCycle: player.walkCycle,
                outfit: 'detective',
                hatType: 'fedora',
                lightFactor: lightFactor,
                isPlayer: true
            });
        }

        function isInLight(x, y) {
            // Check street lights
            for (const light of currentMap.streetLights) {
                const dist = Math.sqrt(Math.pow(x - light.x, 2) + Math.pow(y - (light.y + 50), 2));
                if (dist < 120) return true;
            }

            // Check building doors (have lights above them)
            for (const building of currentMap.buildings) {
                const doorX = building.x + building.width / 2;
                const doorY = building.y + building.height;
                const dist = Math.sqrt(Math.pow(x - doorX, 2) + Math.pow(y - doorY, 2));
                if (dist < 60) return true;
            }

            return false;
        }

        function adjustBrightness(color, factor) {
            // Simple brightness adjustment
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);

                const nr = Math.floor(r * factor);
                const ng = Math.floor(g * factor);
                const nb = Math.floor(b * factor);

                return `rgb(${nr}, ${ng}, ${nb})`;
            }
            return color;
        }

        function drawNPC(npc) {
            const state = worldState.npcStates[npc.id] || { x: npc.x, y: npc.y, facingRight: true };
            const nx = state.x - camera.x + 12;
            const ny = state.y - camera.y + 64;

            const inLight = isInLight(state.x, state.y);
            const lightFactor = inLight ? 1 : 0.3;

            // Determine outfit based on role
            let outfit = 'suit';
            let hatType = 'none';

            if (npc.role === 'bartender') { outfit = 'worker'; }
            else if (npc.role === 'owner' && npc.name === 'Margaret') { outfit = 'dress'; hatType = 'none'; }
            else if (npc.role === 'owner' || npc.role === 'pharmacist') { outfit = 'suit'; }
            else if (npc.role === 'patron') { outfit = 'casual'; hatType = 'fedora'; }
            else if (npc.role === 'police') { outfit = 'suit'; hatType = 'none'; }
            else if (npc.role === 'secretary') { outfit = 'dress'; }

            drawMannequin(nx, ny, {
                facing: state.facingRight ? 1 : -1,
                isMoving: false,
                walkCycle: 0,
                outfit: outfit,
                hatType: hatType,
                lightFactor: lightFactor,
                isPlayer: false
            });
        }

        // ============================================
        // STREET PROPS RENDERING
        // ============================================

        function drawStreetProps() {
            for (const prop of worldState.props) {
                const px = prop.x - camera.x;
                const py = prop.y - camera.y;

                if (px < -50 || px > CONFIG.CANVAS_WIDTH + 50) continue;

                switch (prop.type) {
                    case 'phonebooth':
                        drawPhoneBooth(px, py);
                        break;
                    case 'bench':
                        drawBench(px, py);
                        break;
                    case 'trashcan':
                        drawTrashCan(px, py);
                        break;
                    case 'hydrant':
                        drawFireHydrant(px, py);
                        break;
                    case 'newsstand':
                        drawNewsstand(px, py);
                        break;
                    case 'mailbox':
                        drawMailbox(px, py);
                        break;
                    case 'streetsign':
                        drawStreetSign(px, py, prop.text);
                        break;
                }
            }
        }

        function drawPhoneBooth(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 58, 24, 6);

            // Booth frame
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x, y, 30, 60);

            // Glass panels
            ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
            ctx.fillRect(x + 3, y + 8, 24, 35);

            // Door frame
            ctx.strokeStyle = '#5a0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 3, y + 8, 24, 48);

            // Phone inside (silhouette)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 10, y + 18, 10, 15);

            // Light on top
            ctx.fillStyle = '#ffeecc';
            ctx.shadowColor = '#ffeecc';
            ctx.shadowBlur = 10;
            ctx.fillRect(x + 8, y - 5, 14, 5);
            ctx.shadowBlur = 0;
        }

        function drawBench(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 25, y + 22, 28, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x + 5, y + 8, 4, 14);
            ctx.fillRect(x + 41, y + 8, 4, 14);

            // Seat
            ctx.fillStyle = '#4a3a2a';
            ctx.fillRect(x, y, 50, 8);

            // Back rest
            ctx.fillRect(x, y - 15, 50, 6);
            ctx.fillRect(x + 2, y - 15, 3, 18);
            ctx.fillRect(x + 45, y - 15, 3, 18);
        }

        function drawTrashCan(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 25, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Can body
            ctx.fillStyle = '#3d3d3d';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 16, y);
            ctx.lineTo(x + 14, y + 24);
            ctx.lineTo(x + 2, y + 24);
            ctx.closePath();
            ctx.fill();

            // Rim
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(x - 1, y - 2, 18, 3);

            // Lines
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 5, y + 2);
            ctx.lineTo(x + 4, y + 22);
            ctx.moveTo(x + 11, y + 2);
            ctx.lineTo(x + 12, y + 22);
            ctx.stroke();
        }

        function drawFireHydrant(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 7, y + 22, 9, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Base
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(x + 2, y + 15, 10, 7);

            // Body
            ctx.beginPath();
            ctx.moveTo(x + 1, y + 15);
            ctx.lineTo(x + 3, y + 4);
            ctx.lineTo(x + 11, y + 4);
            ctx.lineTo(x + 13, y + 15);
            ctx.closePath();
            ctx.fill();

            // Top
            ctx.fillRect(x + 4, y, 6, 4);
            ctx.fillRect(x + 5, y - 3, 4, 4);

            // Side nozzle
            ctx.fillRect(x + 12, y + 6, 5, 4);

            // Highlight
            ctx.fillStyle = '#aa2020';
            ctx.fillRect(x + 5, y + 5, 2, 8);
        }

        function drawNewsstand(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 3, y + 32, 34, 6);

            // Stand body
            ctx.fillStyle = '#2a4a2a';
            ctx.fillRect(x, y, 40, 32);

            // Papers display
            ctx.fillStyle = '#e8e0d0';
            ctx.fillRect(x + 3, y + 3, 34, 20);

            // Headlines (abstract lines)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 5, y + 5, 20, 3);
            ctx.fillRect(x + 5, y + 10, 28, 2);
            ctx.fillRect(x + 5, y + 14, 25, 2);
            ctx.fillRect(x + 5, y + 18, 22, 2);

            // Coin slot area
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 15, y + 25, 10, 5);
        }

        function drawMailbox(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 35, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Post
            ctx.fillStyle = '#1a3a6a';
            ctx.fillRect(x + 5, y + 15, 6, 20);

            // Box body
            ctx.fillRect(x - 2, y, 20, 16);

            // Rounded top
            ctx.beginPath();
            ctx.arc(x + 8, y, 10, Math.PI, 0, false);
            ctx.fill();

            // Slot
            ctx.fillStyle = '#0a1a3a';
            ctx.fillRect(x + 2, y + 5, 12, 3);

            // USPS eagle (simplified)
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(x + 8, y - 4);
            ctx.lineTo(x + 12, y - 1);
            ctx.lineTo(x + 4, y - 1);
            ctx.closePath();
            ctx.fill();
        }

        function drawStreetSign(x, y, text) {
            // Pole
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(x + 12, y, 4, 50);

            // Sign
            ctx.fillStyle = '#1a5a1a';
            ctx.fillRect(x, y - 10, 60, 16);

            // Border
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y - 9, 58, 14);

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 9px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText(text, x + 30, y);
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function updatePlayer() {
            if (game.state !== 'playing') return;

            player.isMoving = false;

            if (keys.up) {
                player.y -= player.speed;
                player.direction = 'up';
                player.isMoving = true;
            }
            if (keys.down) {
                player.y += player.speed;
                player.direction = 'down';
                player.isMoving = true;
            }
            if (keys.left) {
                player.x -= player.speed;
                player.direction = 'left';
                player.facing = -1;
                player.isMoving = true;
            }
            if (keys.right) {
                player.x += player.speed;
                player.direction = 'right';
                player.facing = 1;
                player.isMoving = true;
            }

            // Boundary checks
            player.x = Math.max(0, Math.min(currentMap.width - player.width, player.x));
            player.y = Math.max(200, Math.min(currentMap.height - player.height, player.y));

            // Update camera to follow player
            camera.x = player.x - CONFIG.CANVAS_WIDTH / 2 + player.width / 2;
            camera.y = player.y - CONFIG.CANVAS_HEIGHT / 2 + player.height / 2;

            // Camera bounds
            camera.x = Math.max(0, Math.min(currentMap.width - CONFIG.CANVAS_WIDTH, camera.x));
            camera.y = Math.max(0, Math.min(currentMap.height - CONFIG.CANVAS_HEIGHT, camera.y));

            // Check for interactions
            checkInteractions();
        }

        function checkInteractions() {
            let nearInteractable = false;

            // Check building entrances
            for (const building of currentMap.buildings) {
                if (building.enterable) {
                    const doorX = building.x + building.width / 2;
                    const doorY = building.y + building.height;

                    const dist = Math.sqrt(
                        Math.pow(player.x + player.width / 2 - doorX, 2) +
                        Math.pow(player.y + player.height - doorY, 2)
                    );

                    if (dist < 50) {
                        nearInteractable = true;
                        document.getElementById('interact-prompt').textContent = `[E] ENTER ${building.name.split('\n')[0]}`;
                        break;
                    }
                }
            }

            // Check cars
            if (!nearInteractable) {
                for (const car of currentMap.cars) {
                    if (car.canEnter) {
                        const dist = Math.sqrt(
                            Math.pow(player.x - car.x - 50, 2) +
                            Math.pow(player.y - car.y, 2)
                        );

                        if (dist < 60) {
                            nearInteractable = true;
                            document.getElementById('interact-prompt').textContent = '[E] ENTER CAR';
                            break;
                        }
                    }
                }
            }

            const promptEl = document.getElementById('interact-prompt');
            if (nearInteractable) {
                promptEl.classList.add('visible');
            } else {
                promptEl.classList.remove('visible');
            }
        }

        function updateGameTime() {
            // Advance game time (1 real second = 1 game minute)
            game.time.minutes += CONFIG.GAME_SPEED;

            if (game.time.minutes >= 60) {
                game.time.minutes = 0;
                game.time.hours++;

                if (game.time.hours >= 24) {
                    game.time.hours = 0;
                    game.day++;
                }
            }

            // Update clock display
            const hours = game.time.hours % 12 || 12;
            const minutes = String(game.time.minutes).padStart(2, '0');
            const ampm = game.time.hours >= 12 ? 'PM' : 'AM';
            document.getElementById('clock').textContent = `${hours}:${minutes} ${ampm}`;
        }

        function updateLocationDisplay() {
            const locDisplay = document.getElementById('location-display');

            // Determine current area based on player position
            let currentLocation = currentMap.name;

            for (const building of currentMap.buildings) {
                const nearDoor = Math.abs(player.x - (building.x + building.width / 2)) < 100 &&
                                 Math.abs(player.y - (building.y + building.height)) < 80;

                if (nearDoor) {
                    currentLocation = building.name.split('\n')[0];
                    break;
                }
            }

            if (locDisplay.textContent !== currentLocation) {
                locDisplay.textContent = currentLocation;
                locDisplay.classList.add('visible');

                setTimeout(() => {
                    locDisplay.classList.remove('visible');
                }, 3000);
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, 150, 120);

            const scale = 150 / currentMap.width;

            // Draw buildings
            minimapCtx.fillStyle = '#3d3d3d';
            for (const building of currentMap.buildings) {
                minimapCtx.fillRect(
                    building.x * scale,
                    building.y * scale * 0.8,
                    building.width * scale,
                    building.height * scale * 0.8
                );
            }

            // Draw player
            minimapCtx.fillStyle = '#c4a35a';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale * 0.8, 3, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw viewport rectangle
            minimapCtx.strokeStyle = '#8b7355';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale * 0.8,
                CONFIG.CANVAS_WIDTH * scale,
                CONFIG.CANVAS_HEIGHT * scale * 0.8
            );
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================

        let lastTime = 0;
        let timeAccumulator = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Update game time every second
            timeAccumulator += deltaTime;
            if (timeAccumulator >= 1000) {
                updateGameTime();
                timeAccumulator = 0;
            }

            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            if (game.state === 'playing') {
                // Initialize world state on first frame
                if (!worldState.initialized) {
                    initWorldState();
                }

                updatePlayer();
                updateLocationDisplay();

                // Draw scene
                drawSky();
                drawGround();

                // Draw street lights (back layer glow)
                for (const light of currentMap.streetLights) {
                    drawStreetLight(light);
                }

                // Draw buildings
                for (const building of currentMap.buildings) {
                    drawBuilding(building);
                }

                // Draw street props (behind characters)
                drawStreetProps();

                // Draw cars
                for (const car of currentMap.cars) {
                    drawCar(car);
                }

                // Collect all drawable entities and sort by Y for proper depth
                const entities = [];

                // Add NPCs
                for (const npc of npcs.filter(n => n.location !== 'interior')) {
                    const state = worldState.npcStates[npc.id];
                    if (state) {
                        entities.push({ type: 'npc', data: npc, y: state.y });
                    }
                }

                // Add player
                entities.push({ type: 'player', data: player, y: player.y });

                // Sort by Y position (painter's algorithm)
                entities.sort((a, b) => a.y - b.y);

                // Draw sorted entities
                for (const entity of entities) {
                    if (entity.type === 'player') {
                        drawPlayer();
                    } else if (entity.type === 'npc') {
                        drawNPC(entity.data);
                    }
                }

                // Draw minimap
                drawMinimap();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        document.addEventListener('keydown', (e) => {
            if (game.state === 'title') {
                game.state = 'playing';
                document.getElementById('title-screen').classList.add('hidden');
                return;
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    keys.interact = true;
                    break;
                case ' ':
                    keys.action = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'e':
                case 'E':
                case 'Enter':
                    keys.interact = false;
                    break;
                case ' ':
                    keys.action = false;
                    break;
            }
        });

        // Touch controls
        function setupTouchControl(id, key) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
            btn.addEventListener('mousedown', () => keys[key] = true);
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }

        setupTouchControl('d-up', 'up');
        setupTouchControl('d-down', 'down');
        setupTouchControl('d-left', 'left');
        setupTouchControl('d-right', 'right');

        document.getElementById('btn-interact').addEventListener('click', () => {
            keys.interact = true;
            setTimeout(() => keys.interact = false, 100);
        });

        document.getElementById('btn-action').addEventListener('click', () => {
            keys.action = true;
            setTimeout(() => keys.action = false, 100);
        });

        // Click/tap to start
        document.getElementById('title-screen').addEventListener('click', () => {
            game.state = 'playing';
            document.getElementById('title-screen').classList.add('hidden');
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            // Position player in front of PI office
            player.x = 400;
            player.y = 420;

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>

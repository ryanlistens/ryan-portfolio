<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mullet Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background: #f5f2ec;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            padding: 20px;
        }
        #game-frame {
            background: #4d443d;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 750px;
            width: 100%;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            padding: 12px 20px;
            background: #2b2b2b;
            color: #f5f2ec;
            font-size: 18px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .heart { color: #e74c3c; font-size: 20px; }
        canvas {
            display: block;
            border: 4px solid #2b2b2b;
            border-radius: 6px;
            width: 100%;
            background: #e8e6dc;
        }
        #controls-section {
            margin-top: 20px;
            padding: 20px;
            background: #fffdf6;
            border-radius: 8px;
            border: 2px solid #e8e6dc;
        }
        #controls-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 30px;
            align-items: center;
            justify-items: center;
        }
        #dpad-container {
            display: grid;
            grid-template: repeat(3, 65px) / repeat(3, 65px);
            gap: 8px;
        }
        .control-btn {
            background: linear-gradient(145deg, #005f99, #004a7c);
            border: 3px solid #2b2b2b;
            border-radius: 8px;
            color: #f5f2ec;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            transition: all 0.1s;
        }
        .control-btn:active {
            background: linear-gradient(145deg, #004a7c, #003d66);
            transform: translateY(2px);
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }
        #action-btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4d443d, #3a342f);
            border: 5px solid #2b2b2b;
            color: #f5f2ec;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        #action-btn:active {
            background: linear-gradient(145deg, #3a342f, #2b2520);
            transform: scale(0.95);
        }
        #start-btn {
            display: block;
            margin: 20px auto 0;
            padding: 18px 60px;
            background: linear-gradient(145deg, #005f99, #004a7c);
            color: #f5f2ec;
            border: 3px solid #2b2b2b;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        #start-btn:hover {
            background: linear-gradient(145deg, #004a7c, #003d66);
            transform: translateY(-2px);
        }
        .empty { background: none; border: none; }
        @media (max-width: 600px) {
            #controls-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="game-frame">
        <div id="hud">
            <span>LEVEL <span id="level">1</span></span>
            <span>SCORE <span id="score">0</span></span>
            <span><span id="timer">60</span>s</span>
            <span id="lives"></span>
        </div>
        <canvas id="game" width="700" height="500"></canvas>
        <div id="controls-section">
            <div id="controls-grid">
                <div id="dpad-container">
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="up">▲</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="left">◄</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="right">►</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="down">▼</button>
                    <div class="empty"></div>
                </div>
                <button id="action-btn">ACTION</button>
            </div>
        </div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
    </div>

<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    let state = 'menu';
    let level = 1;
    let score = 0;
    let timer = 60;
    let lives = 2;
    let frame = 0;
    let cardTimer = 0;
    let menuChoice = 0;
    
    let player = { x: 350, y: 380, holding: null };
    let computer = { x: 120, y: 320 };
    let ui = { show: false, selectedColor: 0, confirming: false };
    let npcs = [];
    let cracks = [];
    let keys = {};
    
    const COLORS = [
        { name: 'RED', hex: '#e74c3c' },
        { name: 'GREEN', hex: '#27ae60' },
        { name: 'BLUE', hex: '#005f99' },
        { name: 'YELLOW', hex: '#f39c12' }
    ];
    
    function updateLives() {
        let html = '';
        for (let i = 0; i < lives; i++) html += '<span class="heart">♥</span>';
        for (let i = lives; i < 2; i++) html += '<span class="heart" style="opacity:0.3">♥</span>';
        document.getElementById('lives').innerHTML = html;
    }
    
    function initLevel(lv) {
        level = lv;
        npcs = [];
        cracks = [];
        player.holding = null;
        ui = { show: false, selectedColor: 0, confirming: false };
        
        const count = level >= 2 ? 4 : 3;
        const positions = level >= 2 ? [180, 300, 420, 540] : [230, 390, 550];
        for (let i = 0; i < count; i++) {
            npcs.push({
                x: positions[i],
                y: 340,
                color: COLORS[i],
                state: 'happy',
                needsDoc: false,
                fixAnim: 0
            });
        }
    }
    
    function startGame() {
        state = 'levelCard';
        level = 1;
        score = 0;
        timer = 60;
        lives = 2;
        cardTimer = 0;
        player = { x: 350, y: 380, holding: null };
        initLevel(1);
        document.getElementById('start-btn').style.display = 'none';
        updateLives();
        gameLoop();
    }
    
    function spawnCracks() {
        if (state !== 'playing') return;
        const delay = level === 1 ? 5000 : level === 2 ? 4000 : 3000;
        setTimeout(() => {
            if (state === 'playing') {
                const available = npcs.filter(n => n.state === 'happy');
                if (available.length > 0) {
                    const npc = available[Math.floor(Math.random() * available.length)];
                    cracks.push({ npc, time: Date.now(), max: 12000 });
                    npc.state = 'stressed';
                    npc.needsDoc = true;
                }
            }
            spawnCracks();
        }, delay);
    }
    
    function drawMulletPro(x, y) {
        const s = 2;
        
        // Shoulder-length mullet
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x-7*s, y-16*s, 14*s, 4*s);
        ctx.fillRect(x-8*s, y-12*s, 16*s, 10*s);
        
        // Head
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-5*s, y-12*s, 10*s, 10*s);
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3*s, y-9*s, 2*s, 2*s);
        ctx.fillRect(x+s, y-9*s, 2*s, 2*s);
        
        // Smile
        ctx.fillRect(x-2*s, y-5*s, 4*s, s);
        
        // Maroon blazer
        ctx.fillStyle = '#800020';
        ctx.fillRect(x-7*s, y-2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x-7*s, y-2*s, 2*s, 10*s);
        
        // Black tee
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x-3*s, y-2*s, 6*s, 4*s);
        
        // Arms
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-9*s, y, 2*s, 7*s);
        ctx.fillRect(x+7*s, y, 2*s, 7*s);
        
        // Light denim jeans
        ctx.fillStyle = '#a4c2db';
        ctx.fillRect(x-5*s, y+8*s, 4*s, 8*s);
        ctx.fillRect(x+s, y+8*s, 4*s, 8*s);
        
        // Brown loafers
        ctx.fillStyle = '#654321';
        ctx.fillRect(x-5*s, y+16*s, 4*s, 2*s);
        ctx.fillRect(x+s, y+16*s, 4*s, 2*s);
    }
    
    function drawNPC(npc) {
        const x = npc.x;
        const y = npc.y;
        const s = 2;
        
        // Colored hood
        ctx.fillStyle = npc.color.hex;
        ctx.fillRect(x-6*s, y-16*s, 12*s, 4*s);
        
        // Head
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-4*s, y-13*s, 8*s, 8*s);
        
        // Expression
        ctx.fillStyle = '#000';
        if (npc.state === 'stressed') {
            ctx.fillRect(x-3*s, y-10*s, 2*s, 3*s);
            ctx.fillRect(x+s, y-10*s, 2*s, 3*s);
            ctx.fillRect(x-s, y-7*s, 2*s, s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x-8*s, y-9*s, 3*s, 4*s);
        } else {
            ctx.fillRect(x-3*s, y-10*s, 2*s, 2*s);
            ctx.fillRect(x+s, y-10*s, 2*s, 2*s);
            ctx.fillRect(x-2*s, y-7*s, 4*s, s);
        }
        
        // Jumpsuit body
        ctx.fillStyle = npc.color.hex;
        ctx.fillRect(x-6*s, y-5*s, 12*s, 11*s);
        ctx.fillRect(x-8*s, y-3*s, 2*s, 7*s);
        ctx.fillRect(x+6*s, y-3*s, 2*s, 7*s);
        ctx.fillRect(x-5*s, y+6*s, 4*s, 7*s);
        ctx.fillRect(x+s, y+6*s, 4*s, 7*s);
        
        // White boots
        ctx.fillStyle = '#fff';
        ctx.fillRect(x-5*s, y+13*s, 4*s, 3*s);
        ctx.fillRect(x+s, y+13*s, 4*s, 3*s);
        
        if (npc.needsDoc) {
            ctx.fillStyle = '#f39c12';
            ctx.font = 'bold 28px monospace';
            ctx.fillText('!', x + 20, y - 24);
        }
        
        if (npc.state === 'fixing') {
            ctx.save();
            ctx.translate(x, 220);
            ctx.rotate(npc.fixAnim);
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(-8*s, -2*s, 16*s, 4*s);
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(-7*s, -s, 14*s, 2*s);
            ctx.restore();
        }
    }
    
    function drawScene() {
        if (state === 'menu') {
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(0, 0, 700, 500);
            
            ctx.fillStyle = '#005f99';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MULLET', 350, 180);
            
            ctx.fillStyle = '#4d443d';
            ctx.font = 'bold 72px Arial';
            ctx.fillText('PRO', 350, 260);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = '24px Arial';
            ctx.fillText('Document Delivery Arcade', 350, 310);
            
            drawMulletPro(350, 380);
            return;
        }
        
        if (state === 'levelCard') {
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(0, 0, 700, 500);
            
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL ' + level, 350, 200);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 28px Arial';
            const msgs = ['', 'TRAINING DAY', 'PRESSURE RISING!', 'MAXIMUM CHAOS!'];
            ctx.fillText(msgs[level], 350, 260);
            
            if (cardTimer > 60) {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('GET READY!', 350, 360);
            }
            return;
        }
        
        if (state === 'over' || state === 'win') {
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(0, 0, 700, 500);
            
            ctx.fillStyle = state === 'win' ? '#27ae60' : '#e74c3c';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(state === 'win' ? "YOU'RE HIRED!" : "YOU'RE FIRED!", 350, 180);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = '32px Arial';
            ctx.fillText('FINAL SCORE: ' + score, 350, 240);
            
            ctx.font = '24px Arial';
            ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
            ctx.fillText('▶ Return to Mullet.pro', 350, 320);
            ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
            ctx.fillText('▶ Keep documenting!', 350, 370);
            return;
        }
        
        ctx.fillStyle = '#e8e6dc';
        ctx.fillRect(0, 0, 700, 500);
        
        ctx.fillStyle = '#c4bfad';
        ctx.fillRect(0, 410, 700, 90);
        
        ctx.fillStyle = '#4d443d';
        ctx.fillRect(computer.x - 40, computer.y - 50, 80, 70);
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(computer.x - 35, computer.y - 45, 70, 55);
        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRINT', computer.x, computer.y + 35);
        
        for (let npc of npcs) {
            ctx.strokeStyle = npc.color.hex;
            ctx.lineWidth = 14;
            ctx.beginPath();
            ctx.moveTo(npc.x, 60);
            ctx.lineTo(npc.x, npc.y - 60);
            ctx.stroke();
            
            const crack = cracks.find(c => c.npc === npc);
            if (crack) {
                const pct = (Date.now() - crack.time) / crack.max;
                ctx.fillStyle = npc.color.hex;
                ctx.globalAlpha = 0.4 + pct * 0.6;
                const sz = 18 + pct * 28;
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(npc.x - sz/2 + (i-1)*5, 210 + i*8, sz, 8);
                }
                ctx.globalAlpha = 1;
            }
            
            drawNPC(npc);
        }
        
        drawMulletPro(player.x, player.y);
        
        if (player.holding) {
            const col = COLORS.find(c => c.name === player.holding);
            ctx.fillStyle = col.hex;
            ctx.fillRect(player.x - 20, player.y - 65, 40, 28);
            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(col.name, player.x, player.y - 45);
        }
        
        if (ui.show) {
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 340, 700, 160);
            
            if (!ui.confirming) {
                ctx.fillStyle = '#f5f2ec';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('SELECT COLOR:', 30, 375);
                
                for (let i = 0; i < 4; i++) {
                    const selected = i === ui.selectedColor;
                    ctx.strokeStyle = selected ? '#f5f2ec' : '#666';
                    ctx.lineWidth = selected ? 4 : 2;
                    ctx.fillStyle = COLORS[i].hex;
                    ctx.fillRect(30 + i * 160, 390, 140, 70);
                    ctx.strokeRect(30 + i * 160, 390, 140, 70);
                    ctx.fillStyle = '#2b2b2b';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(COLORS[i].name, 100 + i * 160, 430);
                }
            } else {
                const col = COLORS[ui.selectedColor];
                ctx.fillStyle = '#f5f2ec';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PRINT ' + col.name + ' DOC?', 350, 385);
                ctx.fillStyle = col.hex;
                ctx.fillRect(270, 410, 160, 60);
                ctx.fillStyle = '#2b2b2b';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('CONFIRM', 350, 445);
            }
        }
    }
    
    function update() {
        if (state === 'levelCard') {
            cardTimer++;
            if (cardTimer > 120) {
                state = 'playing';
                spawnCracks();
            }
            return;
        }
        
        if (state === 'over' || state === 'win') {
            if ((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
                menuChoice = 0;
                keys.upProcessed = true;
            }
            if ((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
                menuChoice = 1;
                keys.downProcessed = true;
            }
            if (!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
            if (!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;
            
            if (keys[' '] || keys['action']) {
                keys[' '] = false;
                keys['action'] = false;
                if (menuChoice === 0) {
                    window.location.href = '/';
                } else {
                    state = 'menu';
                    document.getElementById('start-btn').style.display = 'block';
                    document.getElementById('start-btn').textContent = 'START GAME';
                }
            }
            return;
        }
        
        if (state !== 'playing') return;
        
        if (keys['ArrowLeft'] || keys['left']) player.x = Math.max(60, player.x - 4);
        if (keys['ArrowRight'] || keys['right']) player.x = Math.min(640, player.x + 4);
        
        if (keys[' '] || keys['action']) {
            keys[' '] = false;
            keys['action'] = false;
            
            const atComputer = Math.abs(player.x - computer.x) < 60;
            if (atComputer && !player.holding && !ui.show) {
                ui.show = true;
                return;
            }
            
            if (ui.show && !ui.confirming) {
                ui.confirming = true;
                return;
            }
            
            if (ui.show && ui.confirming) {
                player.holding = COLORS[ui.selectedColor].name;
                ui.show = false;
                ui.confirming = false;
                ui.selectedColor = 0;
                return;
            }
            
            if (player.holding) {
                for (let npc of npcs) {
                    if (Math.abs(player.x - npc.x) < 45 && npc.needsDoc && 
                        npc.color.name === player.holding) {
                        npc.needsDoc = false;
                        npc.state = 'fixing';
                        npc.fixAnim = 0;
                        player.holding = null;
                        score += 150 * level;
                        
                        const fixInterval = setInterval(() => {
                            npc.fixAnim += 0.3;
                        }, 50);
                        
                        setTimeout(() => {
                            clearInterval(fixInterval);
                            cracks = cracks.filter(c => c.npc !== npc);
                            npc.state = 'happy';
                        }, 2000);
                        break;
                    }
                }
            }
        }
        
        if (ui.show && !ui.confirming) {
            if ((keys['ArrowLeft'] || keys['left']) && !keys.leftProcessed) {
                ui.selectedColor = Math.max(0, ui.selectedColor - 1);
                keys.leftProcessed = true;
            }
            if ((keys['ArrowRight'] || keys['right']) && !keys.rightProcessed) {
                ui.selectedColor = Math.min(3, ui.selectedColor + 1);
                keys.rightProcessed = true;
            }
            
            if (!keys['ArrowLeft'] && !keys['left']) keys.leftProcessed = false;
            if (!keys['ArrowRight'] && !keys['right']) keys.rightProcessed = false;
        }
        
        for (let crack of cracks) {
            if (Date.now() - crack.time > crack.max) {
                lives--;
                updateLives();
                if (lives <= 0) {
                    state = 'over';
                    menuChoice = 0;
                } else {
                    initLevel(level);
                }
                return;
            }
        }
    }
    
    function gameOver() {
        state = 'over';
        menuChoice = 0;
    }
    
    function winGame() {
        state = 'win';
        menuChoice = 0;
    }
    
    function nextLevel() {
        if (level < 3) {
            level++;
            timer = 60;
            state = 'levelCard';
            cardTimer = 0;
            initLevel(level);
        } else {
            winGame();
        }
    }
    
    let lastTime = Date.now();
    let counter = 0;
    
    function gameLoop() {
        if (state !== 'playing' && state !== 'levelCard' && state !== 'over' && state !== 'win') return;
        
        frame++;
        const now = Date.now();
        counter += now - lastTime;
        lastTime = now;
        
        if (state === 'playing' && counter >= 1000) {
            timer--;
            counter = 0;
            document.getElementById('timer').textContent = timer;
            if (timer <= 0) nextLevel();
        }
        
        update();
        drawScene();
        document.getElementById('level').textContent = level;
        document.getElementById('score').textContent = score;
        
        requestAnimationFrame(gameLoop);
    }
    
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
    
    document.querySelectorAll('.control-btn').forEach(btn => {
        ['touchstart', 'mousedown'].forEach(evt => {
            btn.addEventListener(evt, e => {
                e.preventDefault();
                keys[btn.dataset.dir] = true;
            });
        });
        ['touchend', 'mouseup'].forEach(evt => {
            btn.addEventListener(evt, e => {
                e.preventDefault();
                keys[btn.dataset.dir] = false;
            });
        });
    });
    
    ['touchstart', 'mousedown'].forEach(evt => {
        document.getElementById('action-btn').addEventListener(evt, e => {
            e.preventDefault();
            keys['action'] = true;
        });
    });
    
    drawScene();
</script>

</body>
</html>

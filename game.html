<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mullet Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700&family=Libre+Baskerville&family=Press+Start+2P&display=swap" rel="stylesheet" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        html, body {
            background: #000;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
        }
        #game-frame {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 6px 16px;
            background: #1a1a1a;
            color: #f5f2ec;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 0.5px;
            flex-shrink: 0;
            z-index: 10;
        }
        .heart { color: #e74c3c; }
        .money { color: #27ae60; }
        canvas {
            display: block;
            background: #000;
        }
        /* Mobile touch controls - overlaid directly on the game canvas */
        #controls-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 16px;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            z-index: 20;
            pointer-events: none;
            display: none;
        }
        #controls-grid {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        #dpad-container {
            display: grid;
            grid-template: repeat(3, 52px) / repeat(3, 52px);
            gap: 3px;
            pointer-events: auto;
            touch-action: none;
        }
        .control-btn {
            background: rgba(0, 60, 100, 0.35);
            border: 2px solid rgba(255, 255, 255, 0.18);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        .control-btn.active {
            background: rgba(0, 140, 220, 0.7);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #action-btn {
            width: 88px;
            height: 88px;
            border-radius: 50%;
            background: rgba(60, 50, 40, 0.35);
            border: 3px solid rgba(255, 255, 255, 0.18);
            color: rgba(255, 255, 255, 0.7);
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }
        #action-btn.active {
            background: rgba(120, 100, 80, 0.7);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .empty { background: none !important; border: none !important; pointer-events: none; }

        /* Show touch controls on touch devices or small screens */
        @media (hover: none) and (pointer: coarse) {
            #controls-section { display: block; }
        }
        @media (max-width: 600px) {
            #controls-section { display: block; }
        }
        /* Landscape tweaks */
        @media (orientation: landscape) {
            #hud { padding: 6px 16px; font-size: 18px; }
            #dpad-container { grid-template: repeat(3, 44px) / repeat(3, 44px); gap: 2px; }
            .control-btn { font-size: 17px; border-radius: 8px; }
            #action-btn { width: 68px; height: 68px; font-size: 13px; }
            #controls-section { padding: 4px 12px; padding-bottom: max(4px, env(safe-area-inset-bottom)); }
        }
    </style>
</head>
<body>
    <div id="game-frame">
        <div id="hud">
            <span>LEVEL <span id="level">1</span></span>
            <span>SCORE <span id="score">0</span></span>
            <span><span id="timer">60</span>s</span>
            <span id="lives"></span>
        </div>
        <canvas id="game" width="700" height="500"></canvas>
        <div id="controls-section">
            <div id="controls-grid">
                <div id="dpad-container">
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="up">▲</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="left">◄</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="right">►</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="down">▼</button>
                    <div class="empty"></div>
                </div>
                <button id="action-btn">ACTION</button>
            </div>
        </div>
    </div>
<script>


// SECTION 2: Canvas Setup and Constants
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game area is always 700x500; canvas expands to fill the full viewport
const GAME_W = 700, GAME_H = 500;
let CANVAS_W = 700, CANVAS_H = 500, GX = 0, GY = 0;

const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const hud = document.getElementById('hud');
function resizeCanvas() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const isLandscape = vw > vh;
    const hudH = hud.offsetHeight || 0;
    // Canvas fills ALL available space — controls overlay on top, no reservation
    const availH = vh - hudH;
    const viewRatio = vw / availH;

    if (isLandscape) {
        // Landscape: match viewport ratio exactly for true edge-to-edge fullscreen
        CANVAS_H = GAME_H + 40;
        CANVAS_W = Math.max(GAME_W, Math.round(CANVAS_H * viewRatio));
    } else {
        // Portrait: expand canvas height to match viewport ratio — fills the full screen
        CANVAS_W = GAME_W;
        CANVAS_H = Math.max(GAME_H, Math.min(Math.round(GAME_W / viewRatio), 1400));
    }

    GX = Math.floor((CANVAS_W - GAME_W) / 2);
    GY = Math.floor((CANVAS_H - GAME_H) / 2);

    if (canvas.width !== CANVAS_W || canvas.height !== CANVAS_H) {
        canvas.width = CANVAS_W;
        canvas.height = CANVAS_H;
    }

    // CSS: scale canvas to fill viewport while maintaining aspect ratio
    const ratio = CANVAS_W / CANVAS_H;
    let w, h;
    if (vw / availH > ratio) {
        // Viewport wider than canvas — fill height, center horizontally
        h = availH;
        w = h * ratio;
    } else {
        // Viewport taller than canvas — fill width, center vertically
        w = vw;
        h = w / ratio;
    }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
resizeCanvas();

// Load photorealistic images
const portraitImg = new Image();
portraitImg.src = 'images/14065C15-1E0F-4E93-96B0-A2B4D680271C.png';

const letterImg = new Image();
letterImg.src = 'images/604E8268-5DFB-46F1-8E86-A0B6EC8B64E6.png';

const detectiveNoteImg = new Image();
detectiveNoteImg.src = 'images/E4AAFA7C-62FB-4C7D-8B6A-B349F70101EC.png';

// Trophy cabinet images
const trophy1Img = new Image();
trophy1Img.src = 'images/0B2DF6FF-31C8-449B-8FC4-CE39DDDEB71C.png'; // Freedom isn't free - framed service members photo

const trophy2Img = new Image();
trophy2Img.src = 'images/B80FFC9A-0F00-4244-9362-1447EEEBB6DB.png'; // CEO at PipeTech construction site

const trophy3Img = new Image();
trophy3Img.src = 'images/D857460D-8FAD-4AE5-BA5A-D40EE8982533.png'; // CEO with military general

// CEO office portrait image
const ceoPortraitImg = new Image();
ceoPortraitImg.src = 'images/30802F71-C0D0-4774-87C8-F92C80CD8A18.png'; // Saturn-Pipe-Earth portrait

// Employee lobby "founding father" portrait
const foundingFatherImg = new Image();
foundingFatherImg.src = 'images/IMG_0412.png';

// OSHA safety compliance poster for cloning room
const oshaPosterImg = new Image();
oshaPosterImg.src = 'images/content.png';

// Title screen image
const titleScreenImg = new Image();
titleScreenImg.src = 'images/mullet-pro-title.PNG'; // Photorealistic Mullet Pro cover art

// Concept art image for presentation screen
const conceptArtImg = new Image();
conceptArtImg.src = 'images/mullet-pro-concept.PNG'; // 80s action movie style concept art

// Mullet/RT Games logo
const mulletLogoImg = new Image();
mulletLogoImg.src = 'assets/mullet_icon_reversed_white.png'; // RT Games branded logo

// Audio/Music System
const levelMusic = {
    menu: new Audio('music/menu.mp3'),
    level1: new Audio('music/level1.mp3'),
    level2: new Audio('music/level2.mp3'),
    level3: new Audio('music/level3.mp3'),
    level4: new Audio('music/level4.mp3'),
    level5: new Audio('music/level5.mp3'),
    level6: new Audio('music/level6.mp3')
};

// Set all music to loop and preload
Object.values(levelMusic).forEach(audio => {
    audio.loop = true;
    audio.volume = 0.5; // 50% volume by default
    audio.preload = 'auto'; // Preload audio for immediate playback
    audio.load(); // Start loading immediately
});

let currentMusic = null;
let musicMuted = false;
let audioUnlocked = false;

// Music control functions
let pendingMusicKey = null; // Track music that should play after user interaction

function playMusic(musicKey) {
    // Already playing this track — don't restart (prevents double-call issues)
    if(currentMusic === levelMusic[musicKey] && !currentMusic.paused) return;

    // Stop current music
    if(currentMusic) {
        currentMusic.pause();
        currentMusic.currentTime = 0;
    }

    // Play new music if not muted
    if(!musicMuted && levelMusic[musicKey]) {
        currentMusic = levelMusic[musicKey];

        // If audio has been unlocked by user interaction, play immediately
        if(audioUnlocked) {
            currentMusic.play().catch(err => {
                console.log('Audio playback error:', err);
                // Store as pending so it can be retried on next interaction
                pendingMusicKey = musicKey;
            });
        } else {
            // Try to play, but if blocked, store for later
            currentMusic.play().catch(err => {
                console.log('Audio playback prevented (autoplay policy):', err);
                // Store the pending music to play after user interaction
                pendingMusicKey = musicKey;
            });
        }
    } else {
        // Store pending music key if muted
        pendingMusicKey = musicKey;
    }
}

// Function to resume pending music after user interaction
function resumePendingMusic() {
    if(pendingMusicKey && !musicMuted && levelMusic[pendingMusicKey]) {
        currentMusic = levelMusic[pendingMusicKey];
        currentMusic.play().catch(err => {
            console.log('Audio playback still prevented:', err);
        });
        pendingMusicKey = null;
    }
}

function stopMusic() {
    if(currentMusic) {
        currentMusic.pause();
        currentMusic.currentTime = 0;
    }
}

function toggleMute() {
    musicMuted = !musicMuted;
    if(musicMuted && currentMusic) {
        currentMusic.pause();
    } else if(!musicMuted) {
        // Resume current music or pending music
        if(currentMusic) {
            currentMusic.play().catch(err => {
                console.log('Audio playback prevented:', err);
            });
        } else if(pendingMusicKey) {
            resumePendingMusic();
        }
    }
}

// Handle RT Presents screen interactions - must be called directly in user gesture handlers
function handleRTPresentsInteraction() {
    if(state === 'rtPresents') {
        // Unlock audio
        if(!audioUnlocked) {
            audioUnlocked = true;
            console.log('Audio unlocked on RT Presents button press');
        }
        // Play menu music DIRECTLY in user gesture context - critical for autoplay policy
        if(!musicMuted && levelMusic['menu']) {
            currentMusic = levelMusic['menu'];
            currentMusic.play().then(() => {
                console.log('Menu.mp3 playing successfully');
            }).catch(err => {
                console.error('Menu.mp3 failed to play:', err);
                pendingMusicKey = 'menu';
            });
        }
        // Transition to concept art
        state = 'conceptArt';
        frame = 0;
        return true; // Handled
    }
    return false; // Not on RT Presents screen
}

// Handle Menu screen interactions - must be called directly in user gesture handlers
function handleMenuInteraction() {
    if(state === 'menu') {
        // Unlock audio (music will be played in levelCard transition to avoid double-play)
        if(!audioUnlocked) {
            audioUnlocked = true;
            console.log('Audio unlocked on menu button press');
        }
        // Start the game (level1 music will play when transitioning to 'playing' state)
        startGame();
        return true; // Handled
    }
    return false; // Not on menu screen
}

const COLORS = [
    {name:'RED', hex:'#e74c3c'},
    {name:'GREEN', hex:'#27ae60'},
    {name:'BLUE', hex:'#005f99'},
    {name:'YELLOW', hex:'#f39c12'}
];

const OFFICE_EMAILS = {
    RED: {
        from: 'RED',
        to: 'BLUE',
        subject: 'Meeting Request',
        body: 'Dear B.,\n\nI need to speak with you urgently\nabout a confidential matter. Can we\nmeet in the parking lot after hours?\n\nI was recently contacted by a\ndetective named Khan who gave me\na number to reach him: 3546.\nStrange... it\'s not enough numbers\nfor a phone call.\n\nThis is important.\n\n—R.'
    },
    GREEN: {
        from: 'GREEN',
        to: 'YELLOW',
        subject: 'Coffee?',
        body: 'Dear Y.,\n\nWould you like to grab coffee after\nwork today? I know a great place\ndowntown.\n\nThinking of you.\n\n—G.'
    },
    BLUE: {
        from: 'BLUE',
        to: 'GREEN',
        subject: 'Homesick',
        body: 'Dear G.,\n\nI miss home so much. This job is\nwearing me down. Do you ever feel\nlike leaving it all behind?\n\nWish I could see the ocean again.\n\n—B.'
    },
    YELLOW: {
        from: 'YELLOW',
        to: 'GREEN',
        subject: 'Re: Coffee?',
        body: 'Dear G.,\n\nI would love that! You always know\nhow to make my day better.\n\nSee you at 5?\n\n—Y.'
    }
};


const SAFE_CODE = ['RED', 'GREEN', 'BLUE', 'YELLOW'];


// SECTION 3: Game State Variables
let state = 'rtPresents'; // Start with RT Games presentation screen
let level = 1;
let score = 0;
let timer = 60;
let lives = 3;
let frame = 0;
let cardTimer = 0;
let menuChoice = 0;

let player = {
    x: 350,
    y: 380,
    holding: null,
    facing: 'forward',
    lastMove: 0
};

let computer = {x: 180, y: 350};
let printer3d = {x: 50, y: 360};

let ui = {
    show: false,
    selectedColor: 0,
    confirming: false,
    gunUI: false,
    gunChoice: 0
};

let npcs = [];
let cracks = [];
let keys = {};
let explosions = [];
let bullets = [];
let muzzleFlashes = [];
let bossDoor = { state: 'closed', openPct: 0 };

let boss = {
    active: false,
    x: 750,
    y: 344,
    needsColor: null,
    walking: false,
    spawnTime: 0,
    angry: false,
    facing: 'left',
    bossKills: 0
};

let ceo = {
    x: 150,
    y: 180,
    facing: 'back',
    state: 'offering',
    health: 6,
    shootTimer: 0,
    moveTimer: 0,
    blinkTimer: 0,
    lastShot: 0,
    hasDrink: true,
    walkTarget: {x: 350, y: 340}
};

let level6 = {
    room: 'pipeRoom',
    safeUnlocked: false,
    safeUI: false,
    codeInput: [],
    selectedButton: 0,
    itemSelection: 0,
    selectingItem: false,
    hasRevolver: false,
    revolverAmmo: 6,
    cashSacks: [],
    moneyLives: 0,
    ceoDefeated: false,
    computerUI: false,
    computerChoice: 0,
    computerCompleted: false,
    endingTriggered: false,
    npcExitSequence: false,
    npcExitTimer: 0,
    exitingNPCs: [],
    npcPipes: [],
    radiationTimer: 0,
    viewingDetectiveNote: false,
    noteScrollOffset: 0
};

let ghostGun = {
    hasGun: false,
    ammo: 0,
    printing: false,
    printProgress: 0,
    printingHeart: false
};

let fadeAlpha = 0;
let fadeIn = false;
let fadeOut = false;
let resetting = false;


let level5 = {
    room: 'furnaceRoom',
    currentOffice: null,
    viewingEmail: false,
    viewingLetter: false,
    viewingPortrait: false,
    emailScrollOffset: 0,
    letterScrollOffset: 0,
    redDoorLocked: true,
    hasRedKey: false,
    redKeyOnGround: false,
    redKeyEverDropped: false,
    mulletPro: {
        x: 180,
        y: 380,
        hasDoc: false,
        docColor: null,
        giveTimer: 0,
        walkTarget: null,
        state: 'walkingToComputer',
        facing: 'left'
    },
    pipeRoom: {
        rightDoor: {x: 670, y: 340}
    },
    hallway: {
        leftDoor: {x: 30, y: 340},
        rightDoor: {x: 670, y: 340},
        offices: [
            {x: 150, y: 280, color: COLORS[0], name: 'RED'},
            {x: 280, y: 280, color: COLORS[1], name: 'GREEN'},
            {x: 420, y: 280, color: COLORS[2], name: 'BLUE'},
            {x: 550, y: 280, color: COLORS[3], name: 'YELLOW'}
        ],
        trafficTimer: 0
    },
    furnaceRoom: {
        leftDoor: {x: 30, y: 340},
        rightDoor: {x: 670, y: 340},
        furnace: {x: 350, y: 280, flameTime: 0, glowPhase: 0}
    },
    computer: {x: 180, y: 350},
    docsCollected: 0,
    npcPipes: []
};



// SECTION 4: Initialization Functions
function updateLives() {
    if(level === 5) {
        document.getElementById('lives').innerHTML = '<span class="money">$$$</span>';
        return;
    }
    if(level === 6) {
        let h = '';
        for(let i = 0; i < level6.moneyLives; i++) {
            if(level6.hasDetectiveHat) {
                h += '<span class="money" style="color:#ffd700">?</span>';
            } else {
                h += '<span class="money">$</span>';
            }
        }
        document.getElementById('lives').innerHTML = h;
        return;
    }
    let h = '';
    for(let i = 0; i < lives; i++) {
        h += '<span class="heart">♥</span>';
    }
    for(let i = lives; i < 3; i++) {
        h += '<span class="heart" style="opacity:0.3">♥</span>';
    }
    document.getElementById('lives').innerHTML = h;
}

function initLevel(lv) {
    level = lv;
    npcs = [];
    cracks = [];
    explosions = [];
    bullets = [];
    muzzleFlashes = [];
    player.holding = null;
    player.facing = 'down';
    player.x = 350;
    player.y = 380;
    ui = {show: false, selectedColor: 0, confirming: false, gunUI: false, gunChoice: 0};
    
    boss.active = false;
    boss.x = 690;
    boss.y = 344;
    boss.needsColor = null;
    boss.walking = false;
    boss.spawnTime = 0;
    boss.angry = false;
    boss.facing = 'left';
    bossDoor = { state: 'closed', openPct: 0 };
    
    resetting = false;
    fadeAlpha = 0;
    fadeIn = false;
    fadeOut = false;
    
    if(level === 5) {
    player.x = 80;
    player.y = 380;
    level5.room = 'furnaceRoom';
    level5.currentOffice = null;
    level5.viewingEmail = false;
    level5.viewingLetter = false;
    level5.emailScrollOffset = 0;
    level5.letterScrollOffset = 0;
    level5.redDoorLocked = true;
    level5.hasRedKey = false;
    level5.redKeyOnGround = false;
    level5.redKeyEverDropped = false;
    level5.mulletPro.hasDoc = false;
    level5.mulletPro.docColor = null;
    level5.mulletPro.giveTimer = 0;
    level5.mulletPro.state = 'walkingToComputer';
    level5.mulletPro.x = 180;
    level5.mulletPro.y = 380;
    level5.mulletPro.walkTarget = null;
    level5.mulletPro.facing = 'left';
    level5.furnaceRoom.furnace.flameTime = 0;
    level5.furnaceRoom.furnace.glowPhase = 0;
    level5.hallway.trafficTimer = 0;
    level5.docsCollected = 0;
    level5.npcPipes = [
        {x: 260, y: 340, color: COLORS[0], state: 'happy', needsDoc: false, crackStartTime: null},
        {x: 360, y: 340, color: COLORS[1], state: 'happy', needsDoc: false, crackStartTime: null},
        {x: 460, y: 340, color: COLORS[2], state: 'happy', needsDoc: false, crackStartTime: null},
        {x: 560, y: 340, color: COLORS[3], state: 'happy', needsDoc: false, crackStartTime: null}
    ];
    updateLives();
    return;
}

    
    if(level === 6) {
        player.x = 620;
        player.y = 380;
        level6.room = 'pipeRoom';
        level6.safeUnlocked = false;
        level6.safeUI = false;
        level6.codeInput = [];
        level6.selectedButton = 0;
        level6.itemSelection = 0;
        level6.selectingItem = false;
        level6.hasRevolver = false;
        level6.revolverAmmo = 6;
        level6.cashSacks = [];
        level6.moneyLives = 3;
        level6.ceoDefeated = false;
        level6.computerUI = false;
        level6.computerChoice = 0; // 0 = self-destruct, 1 = deliver means
        level6.computerCompleted = false;
        level6.endingTriggered = false;
        level6.npcExitSequence = false;
        level6.npcExitTimer = 0;
        level6.exitingNPCs = [];
        level6.viewingDetectiveNote = false;
        level6.noteScrollOffset = 0;
        level6.keypadUI = false;
        level6.keypadInput = [];
        level6.keypadSelected = 0;
        level6.supercomputerUnlocked = false;
        level6.keypadResult = null;
        level6.keypadResultTime = 0;
        level6.elevatorUI = false;
        level6.elevatorChoice = 0;
        level6.elevatorDoorOpen = 0;
        level6.elevatorTransition = false;
        level6.elevatorFadeAlpha = 0;
        level6.elevatorFadeIn = false;
        level6.pistol = { dropped: false, x: 0, y: 0, pickedUp: false, ammo: 7 };
        level6.hasDetectiveHat = false;
        level6.detectiveHatOnGround = false;
        level6.detectiveTransition = false;
        level6.detectiveTransAlpha = 0;
        level6.detectiveTitleCard = false;
        level6.detectiveTitleTimer = 0;
        level6.detectiveFadeIn = false;
        level6.ceoAngryMode = false;
        level6.redPhoneRinging = false;
        level6.caseClosedCard = false;
        level6.caseClosedTimer = 0;
        level6.caseClosedFadeIn = false;
        level6.bladeDoor = { openPct: 0, state: 'closed' }; // supercomputer blade door
        level6.bladeDoorMega = { openPct: 0, state: 'closed' }; // megacomputer side blade door
        level6.elevatorTarget = null; // which floor elevator is going to
        // Employee Level / Cloning Room state
        level6.cloningBoss = { x: 350, y: 365, facing: 'left', alive: true, walkDir: 1, walkTimer: 0, pauseTimer: 0, paused: false, deathTime: 0 };
        level6.hasKeycard = false;
        level6.keycardOnGround = false;
        level6.keycardX = 0;
        level6.keycardY = 0;
        level6.cloningDoorUnlocked = false; // concealed door to furnace room
        level6.cloningDoorOpen = 0; // slide animation 0-1
        level6.npcPipes = [
            {x: 260, y: 340, color: COLORS[0], state: 'happy', needsDoc: false, crackStartTime: null},
            {x: 360, y: 340, color: COLORS[1], state: 'happy', needsDoc: false, crackStartTime: null},
            {x: 460, y: 340, color: COLORS[2], state: 'happy', needsDoc: false, crackStartTime: null},
            {x: 560, y: 340, color: COLORS[3], state: 'happy', needsDoc: false, crackStartTime: null}
        ];

        ceo.x = 150;
        ceo.y = 180;
        ceo.facing = 'back';
        ceo.state = 'offering';
        ceo.health = 6;
        ceo.shootTimer = 0;
        ceo.moveTimer = 0;
        ceo.blinkTimer = 0;
        ceo.lastShot = 0;
        ceo.hasDrink = true;
        ceo.walkTarget = {x: 350, y: 340};

        updateLives();
        return;
    }
    
    if(level === 1) {
        npcs.push({x:280, y:340, color:COLORS[0], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:390, y:340, color:COLORS[1], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:500, y:340, color:COLORS[2], state:'happy', needsDoc:false, fixAnim:0});
    } else {
        npcs.push({x:260, y:340, color:COLORS[0], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:360, y:340, color:COLORS[1], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:460, y:340, color:COLORS[2], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:560, y:340, color:COLORS[3], state:'happy', needsDoc:false, fixAnim:0});
    }
    
    if(level === 3) {
        setTimeout(() => spawnBoss(), 5000);
    }
    if(level === 4) {
        setTimeout(() => spawnBoss(), 3000);
    }
}

function startGame() {
    state = 'levelCard';
    level = 1;
    score = 0;
    timer = 60;
    lives = 3;
    cardTimer = 0;
    boss.bossKills = 0;
    ghostGun = {hasGun: false, ammo: 0, printing: false, printProgress: 0, printingHeart: false};
    initLevel(1);
    updateLives();

    // Stop menu music and play level 1 music when showing level card
    playMusic('level1');
}


// SECTION 5: Spawn and Utility Functions
function spawnCracks() {
    if(state !== 'playing' || resetting || level === 5 || level === 6) return;
    
    const delay = level === 1 ? 5000 : level === 4 ? 3000 : 4000;
    
    setTimeout(() => {
        if(state === 'playing' && !resetting && level !== 5 && level !== 6) {
            const available = npcs.filter(n => n.state === 'happy');
            if(available.length > 0) {
                const npc = available[Math.floor(Math.random() * available.length)];
                cracks.push({npc: npc, time: Date.now(), max: 12000});
                npc.state = 'stressed';
                npc.needsDoc = true;
            }
        }
        spawnCracks();
    }, delay);
}

function spawnBoss() {
    if((level !== 3 && level !== 4) || state !== 'playing' || resetting) return;
    if(!boss.active) {
        boss.active = true;
        boss.x = 690;
        boss.y = 344;
        boss.needsColor = COLORS[Math.floor(Math.random() * 4)].name;
        boss.walking = true;
        boss.spawnTime = 0;
        boss.angry = false;
        boss.facing = 'left';
        bossDoor = { state: 'opening', openPct: 0 };
        
        const nextSpawn = level === 4 ? 12000 : 18000;
        setTimeout(() => spawnBoss(), nextSpawn);
    }
}

function createExplosion(x, y) {
    explosions.push({x, y, radius: 0, maxRadius: 100, alpha: 1, particles: []});
    for(let i = -4; i < 24; i++) {
        explosions[explosions.length - 1].particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8 - 2,
            life: 1
        });
    }
}

function createMuzzleFlash(x, y, facing) {
    muzzleFlashes.push({x, y, facing, life: 10});
}

function checkPromotion() {
    if(boss.bossKills >= 6) {
        state = 'promotion';
        menuChoice = 0;
    }
}


// SECTION 6: Character Drawing Functions
function drawAmmoCounter(x, y, ammo) {
    // Background panel for visibility
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    const panelWidth = 60;
    const panelHeight = 20;
    ctx.fillRect(x - panelWidth/2, y - 65, panelWidth, panelHeight);

    // Border
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - panelWidth/2, y - 65, panelWidth, panelHeight);

    // Ammo count number
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(ammo, x - panelWidth/2 + 5, y - 50);

    // "x" multiplier
    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 16px Arial';
    ctx.fillText('×', x - panelWidth/2 + 22, y - 50);

    // Bullet icon
    ctx.fillStyle = '#d4af37'; // Gold bullet
    ctx.fillRect(x - panelWidth/2 + 32, y - 60, 4, 10);
    ctx.fillStyle = '#b8941e'; // Darker tip
    ctx.beginPath();
    ctx.moveTo(x - panelWidth/2 + 32, y - 60);
    ctx.lineTo(x - panelWidth/2 + 34, y - 63);
    ctx.lineTo(x - panelWidth/2 + 36, y - 60);
    ctx.fill();
    // Shell casing
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(x - panelWidth/2 + 32, y - 50, 4, 3);
}

function drawHeldDoc(x, y, colorName) {
    const col = COLORS.find(c => c.name === colorName);

    // Realistic manila folder appearance
    const folderWidth = 40;
    const folderHeight = 35;
    const tabWidth = 18;
    const tabHeight = 8;
    const folderX = x - 20;
    const folderY = y - 70;

    // Shadow for depth
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(folderX + 2, folderY + 2, folderWidth, folderHeight);

    // Main folder body (manila/beige color)
    ctx.fillStyle = '#e8d7b8';
    ctx.fillRect(folderX, folderY, folderWidth, folderHeight);

    // Darker edge to show thickness/depth (right and bottom edge)
    ctx.fillStyle = '#d4c4a6';
    ctx.fillRect(folderX + folderWidth - 2, folderY + 2, 2, folderHeight - 2); // right edge
    ctx.fillRect(folderX + 2, folderY + folderHeight - 2, folderWidth - 2, 2); // bottom edge

    // Tab at top (offset to left)
    ctx.fillStyle = '#ead9ba';
    ctx.fillRect(folderX + 2, folderY - tabHeight, tabWidth, tabHeight + 2);

    // Tab darker edge for depth
    ctx.fillStyle = '#d4c4a6';
    ctx.fillRect(folderX + 2 + tabWidth - 1, folderY - tabHeight, 1, tabHeight);

    // Folder edge lines for realism
    ctx.strokeStyle = '#c9b89a';
    ctx.lineWidth = 1;
    ctx.strokeRect(folderX, folderY, folderWidth, folderHeight);

    // Color indicator stripe (horizontal stripe showing doc color)
    ctx.fillStyle = col.hex;
    ctx.fillRect(folderX + 4, folderY + 4, folderWidth - 8, 6);

    // Color stripe border
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(folderX + 4, folderY + 4, folderWidth - 8, 6);

    // Document label text on folder
    ctx.fillStyle = '#666';
    ctx.font = 'bold 9px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(col.name, x, y - 50);
}

function drawMulletPro(x, y, facing, holding = false, hasGun = false) {
    const s = 2;

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    if(facing === 'left') {
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 5*s, y - 16*s, 12*s, 4*s);
        ctx.fillRect(x - 6*s, y - 12*s, 14*s, 10*s);

        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 3*s, y - 5*s, 3*s, s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x + 5*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#800020';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide left arm (will be drawn by gun function), show right arm hanging
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }
        
        ctx.fillStyle = '#a4c2db';
        const legL = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);
        
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + legL, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legL, 4*s, 2*s);
        
    } else if(facing === 'right') {
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 7*s, y - 16*s, 12*s, 4*s);
        ctx.fillRect(x - 8*s, y - 12*s, 14*s, 10*s);

        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x, y - 5*s, 3*s, s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#800020';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide right arm (will be drawn by gun function), show left arm hanging
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }
        
        ctx.fillStyle = '#a4c2db';
        const legR = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);
        
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + legR, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legR, 4*s, 2*s);
        
    } else {
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 7*s, y - 16*s, 14*s, 4*s);
        ctx.fillRect(x - 8*s, y - 12*s, 16*s, 10*s);

        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x - 3*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x + s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 2*s, y - 5*s, 4*s, s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#800020';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide right arm (will be drawn by gun function), show left arm hanging
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }

        ctx.fillStyle = '#a4c2db';
        const leg = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + leg, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - leg, 4*s, 2*s);
    }
}

function drawBaldManager(x, y, facing, holding = false, hasGun = false) {
    const s = 2;

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    const skinColor = '#f5c89a';

    if(facing === 'left') {
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);
        ctx.fillStyle = '#e8d4b8';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 3*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 3*s, y - 5*s, 3*s, s);

        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x + 5*s, y - 2*s, 2*s, 10*s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 10*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#fff';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide left arm (will be drawn by gun function), show right arm hanging
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }

        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + 8*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 12*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 12*s, 4*s, 8*s);

        ctx.fillStyle = '#000';
        const legL = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 20*s + legL, 4*s, 2*s);
        ctx.fillRect(x + s, y + 20*s - legL, 4*s, 2*s);

    } else if(facing === 'right') {
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);
        ctx.fillStyle = '#e8d4b8';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 3*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x, y - 5*s, 3*s, s);

        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 10*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#fff';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide right arm (will be drawn by gun function), show left arm hanging
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }

        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + 8*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 12*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 12*s, 4*s, 8*s);

        ctx.fillStyle = '#000';
        const legR = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 20*s + legR, 4*s, 2*s);
        ctx.fillRect(x + s, y + 20*s - legR, 4*s, 2*s);
        
    } else {
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);
        ctx.fillStyle = '#e8d4b8';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 3*s);

        ctx.fillStyle = '#000';
        ctx.fillRect(x - 3*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x + s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 2*s, y - 5*s, 4*s, s);

        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);

        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 10*s);

        // Arms - raised if holding, extended if hasGun, otherwise hanging
        ctx.fillStyle = '#fff';
        if(holding) {
            // Raised arms to carry doc
            ctx.fillRect(x - 9*s, y - 14*s, 2*s, 14*s);
            ctx.fillRect(x + 7*s, y - 14*s, 2*s, 14*s);
            // Hands at doc level
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y - 16*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y - 16*s, 2*s, 2*s);
        } else if(hasGun) {
            // Gun-holding: hide right arm (will be drawn by gun function), show left arm hanging
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
        } else {
            // Normal hanging arms
            ctx.fillRect(x - 9*s, y, 2*s, 7*s);
            ctx.fillRect(x + 7*s, y, 2*s, 7*s);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 9*s, y + 6*s, 2*s, 2*s);
            ctx.fillRect(x + 7*s, y + 6*s, 2*s, 2*s);
        }

        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + 8*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 12*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 12*s, 4*s, 8*s);

        ctx.fillStyle = '#000';
        const leg = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 20*s + leg, 4*s, 2*s);
        ctx.fillRect(x + s, y + 20*s - leg, 4*s, 2*s);
    }

    // === DETECTIVE FEDORA HAT — drawn on top when wearing ===
    if(typeof level6 !== 'undefined' && level6.hasDetectiveHat) {
        const hatTopY = y - 13*s; // Just above bald head
        // Hat brim — wide dark gray ellipse
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.ellipse(x, hatTopY + 2, 14, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Hat crown — pinched fedora shape
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        ctx.moveTo(x - 9, hatTopY);
        ctx.lineTo(x - 5, hatTopY - 8);
        ctx.lineTo(x - 1, hatTopY - 5);
        ctx.lineTo(x + 1, hatTopY - 5);
        ctx.lineTo(x + 5, hatTopY - 8);
        ctx.lineTo(x + 9, hatTopY);
        ctx.closePath();
        ctx.fill();
        // Hat band
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x - 8, hatTopY - 1, 16, 2);
    }
}

// Draw pipe manager from back - colored jumpsuit with white sneakers
function drawPipeManagerBack(x, y, color, animOffset) {
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hood (back of head) - colored
    ctx.fillStyle = color.hex;
    ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

    // Hood shadow/depth at top
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(x - 5*s, y - 12*s, 10*s, 2*s);

    // Colored jumpsuit torso
    ctx.fillStyle = color.hex;
    ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);

    // Darker stripe down center (back seam)
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(x - s, y - 2*s, 2*s, 10*s);

    // Arms - animated turning motion
    const armSwing = Math.sin(animOffset) * 3;

    // Left arm
    ctx.fillStyle = color.hex;
    ctx.fillRect(x - 9*s, y + armSwing, 2*s, 7*s);
    // Left hand/glove
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(x - 9*s, y + 6*s + armSwing, 2*s, 2*s);

    // Right arm
    ctx.fillStyle = color.hex;
    ctx.fillRect(x + 7*s, y - armSwing, 2*s, 7*s);
    // Right hand/glove
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(x + 7*s, y + 6*s - armSwing, 2*s, 2*s);

    // Pants (darker shade of jumpsuit color)
    ctx.fillStyle = color.hex;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(x - 7*s, y + 8*s, 14*s, 4*s);
    ctx.fillRect(x - 5*s, y + 12*s, 4*s, 8*s);
    ctx.fillRect(x + s, y + 12*s, 4*s, 8*s);
    ctx.globalAlpha = 1;

    // White sneakers
    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 5*s, y + 20*s, 4*s, 2*s);
    ctx.fillRect(x + s, y + 20*s, 4*s, 2*s);

    // Sneaker soles (gray)
    ctx.fillStyle = '#999';
    ctx.fillRect(x - 5*s, y + 22*s, 4*s, 1);
    ctx.fillRect(x + s, y + 22*s, 4*s, 1);
}


// SECTION 7: Boss and NPC Drawing Functions
function drawBoss(x, y, facing) {
    const s = 2;
    
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    const skinColor = boss.angry ? '#cc0000' : '#f5c89a';
    
    if(facing === 'left') {
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);
        
        ctx.fillStyle = '#000';
        if(boss.angry) {
            ctx.fillRect(x - 2*s, y - 10*s, 3*s, s);
            ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x - 2*s, y - 6*s, 2*s, s);
        } else {
            ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x - 3*s, y - 6*s, 3*s, s);
        }
        
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 3*s);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 7*s, y + s, 14*s, 11*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x + 5*s, y + s, 2*s, 11*s);
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 2*s, y + s, 4*s, 11*s);
        
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 9*s, y + 2*s, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y + 2*s, 2*s, 7*s);
        
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 7*s, y + 12*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 16*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 4*s, 8*s);
        
        ctx.fillStyle = '#1a1a1a';
        const legL = boss.walking ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 24*s + legL, 4*s, 2*s);
        ctx.fillRect(x + s, y + 24*s - legL, 4*s, 2*s);
        
    } else if(facing === 'right') {
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);
        
        ctx.fillStyle = '#000';
        if(boss.angry) {
            ctx.fillRect(x - s, y - 10*s, 3*s, s);
            ctx.fillRect(x, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x, y - 6*s, 2*s, s);
        } else {
            ctx.fillRect(x, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x, y - 6*s, 3*s, s);
        }
        
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 3*s);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 7*s, y + s, 14*s, 11*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x - 7*s, y + s, 2*s, 11*s);
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 2*s, y + s, 4*s, 11*s);
        
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 9*s, y + 2*s, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y + 2*s, 2*s, 7*s);
        
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 7*s, y + 12*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 16*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 4*s, 8*s);
        
        ctx.fillStyle = '#1a1a1a';
        const legR = boss.walking ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 24*s + legR, 4*s, 2*s);
        ctx.fillRect(x + s, y + 24*s - legR, 4*s, 2*s);
    }
    
    if(boss.needsColor) {
        const col = COLORS.find(c => c.name === boss.needsColor);
        // Dynamic bubble width based on text length
        ctx.font = 'bold 18px Arial';
        const textW = ctx.measureText(col.name).width;
        const bubbleW = Math.max(60, textW + 20);
        const bubbleX = facing === 'right' ? x + 10 : x - bubbleW - 10;

        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(bubbleX, y - 55, bubbleW, 30, 8);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bubbleX + (facing === 'right' ? 5 : bubbleW - 5), y - 25);
        ctx.lineTo(bubbleX + (facing === 'right' ? 0 : bubbleW), y - 18);
        ctx.lineTo(bubbleX + (facing === 'right' ? 15 : bubbleW - 15), y - 25);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.fillText(col.name, bubbleX + bubbleW / 2, y - 35);
    }
}

function drawNPC(npc) {
    const x = npc.x;
    const y = npc.y;
    const s = 2;
    
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = npc.color.hex;
    ctx.fillRect(x - 6*s, y - 16*s, 12*s, 4*s);
    
    ctx.fillStyle = '#f5c89a';
    ctx.fillRect(x - 4*s, y - 13*s, 8*s, 8*s);
    
    ctx.fillStyle = '#000';
    if(npc.state === 'stressed') {
        ctx.fillRect(x - 3*s, y - 10*s, 2*s, 3*s);
        ctx.fillRect(x + s, y - 10*s, 2*s, 3*s);
        ctx.fillRect(x - s, y - 7*s, 2*s, s);
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 8*s, y - 9*s, 3*s, 4*s);
    } else {
        ctx.fillRect(x - 3*s, y - 10*s, 2*s, 2*s);
        ctx.fillRect(x + s, y - 10*s, 2*s, 2*s);
        ctx.fillRect(x - 2*s, y - 7*s, 4*s, s);
    }
    
    ctx.fillStyle = npc.color.hex;
    ctx.fillRect(x - 6*s, y - 5*s, 12*s, 11*s);
    ctx.fillRect(x - 8*s, y - 3*s, 2*s, 7*s);
    ctx.fillRect(x + 6*s, y - 3*s, 2*s, 7*s);
    ctx.fillRect(x - 5*s, y + 6*s, 4*s, 7*s);
    ctx.fillRect(x + s, y + 6*s, 4*s, 7*s);
    
    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 5*s, y + 13*s, 4*s, 3*s);
    ctx.fillRect(x + s, y + 13*s, 4*s, 3*s);
    
    if(npc.needsDoc) {
        ctx.fillStyle = '#f39c12';
        ctx.font = 'bold 28px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('!', x + 20, y - 24);
    }
    
    if(npc.state === 'fixing') {
        ctx.save();
        ctx.translate(x, 220);
        ctx.rotate(npc.fixAnim);
        ctx.fillStyle = '#95a5a6';
        ctx.fillRect(-10*s, -2*s, 20*s, 4*s);
        ctx.fillStyle = '#7f8c8d';
        ctx.fillRect(-9*s, -s, 18*s, 2*s);
        ctx.restore();
    }
}


// SECTION 8: Equipment and Object Drawing Functions
function drawComputer(x, y) {
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x - 30, y, 60, 35);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 25, y - 30, 50, 30);
    
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x - 22, y - 27, 44, 24);
    
    if(ui.show || player.holding) {
        const displayColor = player.holding ? 
            COLORS.find(c => c.name === player.holding).hex : 
            COLORS[ui.selectedColor].hex;
        ctx.fillStyle = displayColor;
    } else {
        ctx.fillStyle = '#004a7c';
    }
    ctx.fillRect(x - 20, y - 25, 40, 20);
    
    if(ui.show || player.holding) {
        ctx.shadowColor = ui.show ? 
            COLORS[ui.selectedColor].hex : 
            COLORS.find(c => c.name === player.holding).hex;
        ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x - 20, y - 25, 40, 20);
        ctx.shadowBlur = 0;
    }
    
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(x - 20, y - 25, 40, 5);
    
    ctx.fillStyle = '#444';
    ctx.fillRect(x - 5, y, 10, 3);
    
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 7px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('DOC PRINTER', x, y + 30);
}

function draw3DPrinter(x, y) {
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(x - 25, y - 35, 50, 50);
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x - 20, y - 30, 40, 40);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 18, y - 28, 36, 36);
    
    ctx.fillStyle = 'rgba(100,150,200,0.3)';
    ctx.fillRect(x - 16, y - 26, 32, 28);
    
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - 16, y - 26, 32, 28);
    
    if(ghostGun.printing) {
        const progress = ghostGun.printProgress;
        if(ghostGun.printingHeart) {
            const heartSize = 20 * progress;
            ctx.fillStyle = `rgba(231,76,60,${progress})`;
            ctx.font = `bold ${heartSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('♥', x, y);
        } else {
            // Gun with handle pointing up, barrel pointing left (proper orientation)
            const gunSize = 15 * progress;
            ctx.fillStyle = 'rgba(160,160,160,' + progress + ')';

            // Barrel (horizontal, pointing left)
            ctx.fillRect(x - gunSize * 0.7 + 8, y - 3, gunSize * 0.7, 6);

            // Grip/handle (vertical, pointing up)
            ctx.fillRect(x + 3, y - gunSize * 0.5 + 2, 5, gunSize * 0.5);

            // Trigger guard
            ctx.strokeStyle = `rgba(100,100,100,${progress})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 3, y - gunSize * 0.2, 3, gunSize * 0.2);
        }
    }
    
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(x - 20, y + 5, 4, 4);
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x - 25, y + 12, 50, 8);
    
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 7px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('3D PRINTER', x, y + 18);
}

function drawGhostGun(x, y, facing) {
    const skinColor = '#f5c89a';
    const sleeveColor = '#800020'; // Red jacket sleeve

    if(facing === 'left') {
        // LEFT: Proper anatomical arm extended left, gun pointing left

        // Upper arm (shoulder to elbow) - red jacket sleeve
        const shoulderX = x - 9;
        const shoulderY = y - 2;
        const elbowX = x - 17;
        const elbowY = y - 8;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(shoulderX - 8, shoulderY - 2, 11, 7);

        // Forearm (elbow to wrist)
        const wristX = x - 28;
        const wristY = y - 10;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(elbowX - 11, elbowY - 2, 13, 6);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 1, wristY - 2, 7, 8);

        // Gun pointing left
        const gunX = x - 28;
        const gunY = y - 10;

        // Barrel pointing left
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 10, gunY - 3, 18, 6);

        // Barrel extension
        ctx.fillRect(gunX - 16, gunY - 2, 6, 4);

        // Slide/sight
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX - 5, gunY - 5, 5, 2);

    } else if(facing === 'right') {
        // RIGHT: Proper anatomical arm extended right, gun pointing right

        // Upper arm (shoulder to elbow) - red jacket sleeve
        const shoulderX = x + 9;
        const shoulderY = y - 2;
        const elbowX = x + 17;
        const elbowY = y - 8;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(shoulderX - 3, shoulderY - 2, 11, 7);

        // Forearm (elbow to wrist)
        const wristX = x + 28;
        const wristY = y - 10;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(elbowX - 2, elbowY - 2, 13, 6);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 6, wristY - 2, 7, 8);

        // Gun pointing right
        const gunX = x + 28;
        const gunY = y - 10;

        // Barrel pointing right
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 8, gunY - 3, 18, 6);

        // Barrel extension
        ctx.fillRect(gunX + 10, gunY - 2, 6, 4);

        // Slide/sight
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX, gunY - 5, 5, 2);

    } else if(facing === 'up') {
        // UP: Proper anatomical arm raised up, gun pointing up

        // Upper arm (shoulder to elbow) - red jacket sleeve, raised
        const shoulderX = x + 7;
        const shoulderY = y - 2;
        const elbowX = x + 8;
        const elbowY = y - 15;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(shoulderX - 2, shoulderY, 6, 14);

        // Forearm (elbow to wrist) - extends upward
        const wristX = x + 8;
        const wristY = y - 28;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(wristX - 2, elbowY - 2, 5, 15);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 3, wristY - 2, 7, 7);

        // Gun pointing up
        const gunX = x + 8;
        const gunY = y - 32;

        // Barrel pointing up (rotated)
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 3, gunY - 16, 6, 18);

        // Barrel extension
        ctx.fillRect(gunX - 2, gunY - 22, 4, 6);

        // Slide/sight
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX - 4, gunY - 5, 2, 5);

    } else {
        // DOWN: Proper anatomical arm at side, gun holstered

        // Upper arm (shoulder to elbow) - red jacket sleeve, at side
        const shoulderX = x + 7;
        const shoulderY = y + 0;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(shoulderX - 2, shoulderY, 5, 10);

        // Forearm (elbow to wrist) - extends downward
        const elbowY = y + 10;
        const wristY = y + 18;

        ctx.fillStyle = sleeveColor;
        ctx.fillRect(shoulderX - 2, elbowY, 5, 8);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(shoulderX - 3, wristY - 1, 7, 6);

        // Gun holstered at hip
        const gunX = x + 7;
        const holsterY = y + 22;

        // Gun grip pointing down, barrel pointing up (holstered)
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 3, holsterY - 8, 6, 12);

        // Barrel top
        ctx.fillRect(gunX - 2, holsterY - 10, 4, 3);

        // Slide/sight
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX - 2, holsterY - 11, 4, 2);
    }
}

function drawRevolver(x, y, facing) {
    const s = 2;
    const skinColor = '#d4a882';

    if(facing === 'left') {
        // LEFT: Proper anatomical arm extended left, gun pointing left

        // Upper arm (shoulder to elbow) - white shirt sleeve
        const shoulderX = x - 9;
        const shoulderY = y - 2;
        const elbowX = x - 17;
        const elbowY = y - 8;

        ctx.fillStyle = '#fff';
        ctx.fillRect(shoulderX - 8, shoulderY - 2, 11, 7);

        // Forearm (elbow to wrist)
        const wristX = x - 28;
        const wristY = y - 10;

        ctx.fillStyle = '#fff';
        ctx.fillRect(elbowX - 11, elbowY - 2, 13, 6);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 1, wristY - 2, 7, 8);

        // Gun pointing left
        const gunX = x - 28;
        const gunY = y - 10;

        // Barrel
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX - 14, gunY - 2, 18, 5);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(gunX - 14, gunY - 1, 18, 2);

        // Barrel tip/sight
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(gunX - 15, gunY - 3, 2, 7);

        // Cylinder
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.arc(gunX - 2, gunY + 1, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Cylinder chambers
        ctx.fillStyle = '#2a2a2a';
        for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const cx = gunX - 2 + Math.cos(angle) * 2.5;
            const cy = gunY + 1 + Math.sin(angle) * 2.5;
            ctx.beginPath();
            ctx.arc(cx, cy, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Frame
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX + 2, gunY - 2, 4, 8);

        // Hammer
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(gunX + 3, gunY - 5, 2, 4);
        ctx.fillRect(gunX + 2, gunY - 6, 4, 2);

        // Wooden grip
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.moveTo(gunX + 5, gunY + 1);
        ctx.lineTo(gunX + 5, gunY + 10);
        ctx.lineTo(gunX + 9, gunY + 11);
        ctx.lineTo(gunX + 10, gunY + 6);
        ctx.lineTo(gunX + 9, gunY + 1);
        ctx.closePath();
        ctx.fill();

        // Grip texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(gunX + 6, gunY + 3 + i*2);
            ctx.lineTo(gunX + 9, gunY + 3 + i*2);
            ctx.stroke();
        }

        // Trigger
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.arc(gunX + 1, gunY + 3, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else if(facing === 'right') {
        // RIGHT: Proper anatomical arm extended right, gun pointing right

        // Upper arm (shoulder to elbow) - white shirt sleeve
        const shoulderX = x + 9;
        const shoulderY = y - 2;
        const elbowX = x + 17;
        const elbowY = y - 8;

        ctx.fillStyle = '#fff';
        ctx.fillRect(shoulderX - 3, shoulderY - 2, 11, 7);

        // Forearm (elbow to wrist)
        const wristX = x + 28;
        const wristY = y - 10;

        ctx.fillStyle = '#fff';
        ctx.fillRect(elbowX - 2, elbowY - 2, 13, 6);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 6, wristY - 2, 7, 8);

        // Gun pointing right (use mirror)
        const gunX = x + 28;
        const gunY = y - 10;

        ctx.save();
        ctx.translate(gunX, gunY);
        ctx.scale(-1, 1);
        ctx.translate(-gunX, -gunY);

        // Barrel
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX - 14, gunY - 2, 18, 5);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(gunX - 14, gunY - 1, 18, 2);

        // Barrel tip/sight
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(gunX - 15, gunY - 3, 2, 7);

        // Cylinder
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.arc(gunX - 2, gunY + 1, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Cylinder chambers
        ctx.fillStyle = '#2a2a2a';
        for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const cx = gunX - 2 + Math.cos(angle) * 2.5;
            const cy = gunY + 1 + Math.sin(angle) * 2.5;
            ctx.beginPath();
            ctx.arc(cx, cy, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Frame
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX + 2, gunY - 2, 4, 8);

        // Hammer
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(gunX + 3, gunY - 5, 2, 4);
        ctx.fillRect(gunX + 2, gunY - 6, 4, 2);

        // Wooden grip
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.moveTo(gunX + 5, gunY + 1);
        ctx.lineTo(gunX + 5, gunY + 10);
        ctx.lineTo(gunX + 9, gunY + 11);
        ctx.lineTo(gunX + 10, gunY + 6);
        ctx.lineTo(gunX + 9, gunY + 1);
        ctx.closePath();
        ctx.fill();

        // Grip texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(gunX + 6, gunY + 3 + i*2);
            ctx.lineTo(gunX + 9, gunY + 3 + i*2);
            ctx.stroke();
        }

        // Trigger
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.arc(gunX + 1, gunY + 3, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

    } else if(facing === 'up') {
        // UP: Proper anatomical arm raised up, gun pointing up

        // Upper arm (shoulder to elbow) - white shirt sleeve, raised
        const shoulderX = x + 7;
        const shoulderY = y - 2;
        const elbowX = x + 8;
        const elbowY = y - 15;

        ctx.fillStyle = '#fff';
        ctx.fillRect(shoulderX - 2, shoulderY, 6, 14);

        // Forearm (elbow to wrist) - extends upward
        const wristX = x + 8;
        const wristY = y - 28;

        ctx.fillStyle = '#fff';
        ctx.fillRect(wristX - 2, elbowY - 2, 5, 15);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(wristX - 3, wristY - 2, 7, 7);

        // Gun pointing up (rotated 90 degrees)
        const gunX = x + 8;
        const gunY = y - 32;

        ctx.save();
        ctx.translate(gunX, gunY);
        ctx.rotate(-Math.PI / 2);
        ctx.translate(-gunX, -gunY);

        // Barrel
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX - 14, gunY - 2, 18, 5);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(gunX - 14, gunY - 1, 18, 2);

        // Barrel tip/sight
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(gunX - 15, gunY - 3, 2, 7);

        // Cylinder
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.arc(gunX - 2, gunY + 1, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Cylinder chambers
        ctx.fillStyle = '#2a2a2a';
        for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const cx = gunX - 2 + Math.cos(angle) * 2.5;
            const cy = gunY + 1 + Math.sin(angle) * 2.5;
            ctx.beginPath();
            ctx.arc(cx, cy, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Frame
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX + 2, gunY - 2, 4, 8);

        // Hammer
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(gunX + 3, gunY - 5, 2, 4);
        ctx.fillRect(gunX + 2, gunY - 6, 4, 2);

        // Wooden grip
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.moveTo(gunX + 5, gunY + 1);
        ctx.lineTo(gunX + 5, gunY + 10);
        ctx.lineTo(gunX + 9, gunY + 11);
        ctx.lineTo(gunX + 10, gunY + 6);
        ctx.lineTo(gunX + 9, gunY + 1);
        ctx.closePath();
        ctx.fill();

        // Grip texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(gunX + 6, gunY + 3 + i*2);
            ctx.lineTo(gunX + 9, gunY + 3 + i*2);
            ctx.stroke();
        }

        // Trigger
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.arc(gunX + 1, gunY + 3, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

    } else if(facing === 'down') {
        // DOWN: Proper anatomical arm at side, gun pointing down (holstered stance)

        // Upper arm (shoulder to elbow) - white shirt sleeve, at side
        const shoulderX = x + 7;
        const shoulderY = y + 0;

        ctx.fillStyle = '#fff';
        ctx.fillRect(shoulderX - 2, shoulderY, 5, 10);

        // Forearm (elbow to wrist) - extends downward
        const elbowY = y + 10;
        const wristY = y + 18;

        ctx.fillStyle = '#fff';
        ctx.fillRect(shoulderX - 2, elbowY, 5, 8);

        // Hand gripping gun
        ctx.fillStyle = skinColor;
        ctx.fillRect(shoulderX - 3, wristY - 1, 7, 6);

        // Gun pointing down (rotated 90 degrees clockwise)
        const gunX = x + 7;
        const gunY = y + 22;

        ctx.save();
        ctx.translate(gunX, gunY);
        ctx.rotate(Math.PI / 2);
        ctx.translate(-gunX, -gunY);

        // Barrel
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX - 14, gunY - 2, 18, 5);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(gunX - 14, gunY - 1, 18, 2);

        // Barrel tip/sight
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(gunX - 15, gunY - 3, 2, 7);

        // Cylinder
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.arc(gunX - 2, gunY + 1, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Cylinder chambers
        ctx.fillStyle = '#2a2a2a';
        for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const cx = gunX - 2 + Math.cos(angle) * 2.5;
            const cy = gunY + 1 + Math.sin(angle) * 2.5;
            ctx.beginPath();
            ctx.arc(cx, cy, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Frame
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(gunX + 2, gunY - 2, 4, 8);

        // Hammer
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(gunX + 3, gunY - 5, 2, 4);
        ctx.fillRect(gunX + 2, gunY - 6, 4, 2);

        // Wooden grip
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.moveTo(gunX + 5, gunY + 1);
        ctx.lineTo(gunX + 5, gunY + 10);
        ctx.lineTo(gunX + 9, gunY + 11);
        ctx.lineTo(gunX + 10, gunY + 6);
        ctx.lineTo(gunX + 9, gunY + 1);
        ctx.closePath();
        ctx.fill();

        // Grip texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(gunX + 6, gunY + 3 + i*2);
            ctx.lineTo(gunX + 9, gunY + 3 + i*2);
            ctx.stroke();
        }

        // Trigger
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.arc(gunX + 1, gunY + 3, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

function drawCashSack(x, y) {
    // Cloth sack body - proper knotted sack shape with bulging bottom
    ctx.fillStyle = '#27ae60';
    ctx.beginPath();
    // Bottom bulge
    ctx.ellipse(x, y + 8, 13, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    // Middle section (slightly narrower)
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.ellipse(x, y, 11, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Gathered neck section
    ctx.fillStyle = '#27ae60';
    ctx.fillRect(x - 7, y - 8, 14, 8);

    // Sack texture/wrinkles
    ctx.strokeStyle = '#1e8449';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x - 9, y - 2);
    ctx.lineTo(x - 7, y + 12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 9, y);
    ctx.lineTo(x + 7, y + 14);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x - 3, y + 2);
    ctx.lineTo(x - 2, y + 16);
    ctx.stroke();

    // Tied rope/knot at neck
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(x - 8, y - 10, 16, 3);

    // Prominent rope knot
    ctx.fillStyle = '#6b4904';
    ctx.beginPath();
    ctx.arc(x, y - 9, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 2, y - 9, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 2, y - 9, 2, 0, Math.PI * 2);
    ctx.fill();

    // Large $ symbol
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('$', x, y + 10);

    // Outline for definition
    ctx.strokeStyle = '#1e8449';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y + 4, 14, 16, 0, 0, Math.PI * 2);
    ctx.stroke();
}


// === LANDSCAPE EDGE DRAWING HELPERS ===
// Draws a bolted gasket matching the level 5 hallway style at any position
function drawGasket(x, y, radius) {
    const r = radius || 18;
    ctx.fillStyle = '#999';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(x, y, r * 0.78, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(x, y, r * 0.44, 0, Math.PI * 2);
    ctx.fill();
    const boltCount = r > 14 ? 6 : 4;
    for (let b = 0; b < boltCount; b++) {
        const angle = (b / boltCount) * Math.PI * 2;
        const bx = x + Math.cos(angle) * (r * 0.67);
        const by = y + Math.sin(angle) * (r * 0.67);
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(bx, by, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Draws a wooden door matching the hallway style (brown frame, dark panel, gold knob)
function drawEdgeDoor(x, y, w, h) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(x + 4, y + 5, w - 8, h - 5);
    // Panel inset
    ctx.strokeStyle = '#3a2a0a';
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 8, y + 10, w - 16, h / 2 - 15);
    ctx.strokeRect(x + 8, y + h / 2, w - 16, h / 2 - 10);
    // Gold doorknob
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(x + w - 12, y + h / 2, 3, 0, Math.PI * 2);
    ctx.fill();
}

// Death Star trapezoidal blast door — used for supercomputer room entry/exit
// side: 'right' (pipe room, door on right) or 'left' (megacomputer, door on left)
// openPct: 0 (closed) to 1 (fully open) for blade animation
// showKeypad: whether to draw keypad panel
// unlocked: door lock state
function drawDeathStarBlastDoor(x, y, w, h, side, openPct, showKeypad, unlocked) {
    const t = Date.now();
    const frameW = 14;
    const trapInset = 12; // trapezoidal taper amount

    // Outer trapezoidal frame — dark gunmetal
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    if (side === 'right') {
        ctx.moveTo(x - frameW - 4, y - 24 + trapInset);
        ctx.lineTo(x + w + frameW + 4, y - 24);
        ctx.lineTo(x + w + frameW + 4, y + h + 8);
        ctx.lineTo(x - frameW - 4, y + h + 8 - trapInset);
    } else {
        ctx.moveTo(x - frameW - 4, y - 24);
        ctx.lineTo(x + w + frameW + 4, y - 24 + trapInset);
        ctx.lineTo(x + w + frameW + 4, y + h + 8 - trapInset);
        ctx.lineTo(x - frameW - 4, y + h + 8);
    }
    ctx.closePath();
    ctx.fill();

    // Inner frame plate — slightly lighter
    ctx.fillStyle = '#222';
    ctx.beginPath();
    if (side === 'right') {
        ctx.moveTo(x - frameW, y - 20 + trapInset * 0.8);
        ctx.lineTo(x + w + frameW, y - 20);
        ctx.lineTo(x + w + frameW, y + h + 4);
        ctx.lineTo(x - frameW, y + h + 4 - trapInset * 0.8);
    } else {
        ctx.moveTo(x - frameW, y - 20);
        ctx.lineTo(x + w + frameW, y - 20 + trapInset * 0.8);
        ctx.lineTo(x + w + frameW, y + h + 4 - trapInset * 0.8);
        ctx.lineTo(x - frameW, y + h + 4);
    }
    ctx.closePath();
    ctx.fill();

    // Side frame pillars with brushed steel gradient
    const leftPillarX = (side === 'right') ? x - frameW : x - frameW;
    const rightPillarX = x + w;
    // Left pillar
    const lpGrad = ctx.createLinearGradient(leftPillarX, 0, leftPillarX + frameW, 0);
    lpGrad.addColorStop(0, '#2a2a2a');
    lpGrad.addColorStop(0.5, '#444');
    lpGrad.addColorStop(1, '#2a2a2a');
    ctx.fillStyle = lpGrad;
    ctx.fillRect(leftPillarX, y - 2, frameW, h + 4);
    // Right pillar
    const rpGrad = ctx.createLinearGradient(rightPillarX, 0, rightPillarX + frameW, 0);
    rpGrad.addColorStop(0, '#2a2a2a');
    rpGrad.addColorStop(0.5, '#444');
    rpGrad.addColorStop(1, '#2a2a2a');
    ctx.fillStyle = rpGrad;
    ctx.fillRect(rightPillarX, y - 2, frameW, h + 4);

    // Top header plate
    ctx.fillStyle = '#333';
    ctx.fillRect(x - 2, y - 20, w + 4, 18);
    // Hazard chevrons on header
    for (let ch = 0; ch < Math.floor(w / 14); ch++) {
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(x + 4 + ch * 14, y - 18, 7, 14);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x + 9 + ch * 14, y - 18, 5, 14);
    }

    // Exposed wiring conduits on left pillar
    const wireColors = ['#ff3333', '#00ccff', '#ffd700', '#00ff88'];
    for (let wi = 0; wi < 4; wi++) {
        const wy = y + 10 + wi * (h / 5);
        ctx.strokeStyle = wireColors[wi];
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(leftPillarX - 6, wy);
        ctx.quadraticCurveTo(leftPillarX - 2, wy + 6, leftPillarX + 2, wy);
        ctx.stroke();
        // Small connector dot
        ctx.fillStyle = wireColors[wi];
        ctx.beginPath();
        ctx.arc(leftPillarX - 6, wy, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // Blinking indicator lights on right pillar
    for (let li = 0; li < 5; li++) {
        const ly = y + 8 + li * (h / 6);
        const blinkOn = Math.sin(t / 350 + li * 1.3) > 0;
        ctx.fillStyle = blinkOn ? '#00ff88' : '#0a2a0a';
        ctx.beginPath();
        ctx.arc(rightPillarX + frameW + 5, ly, 3, 0, Math.PI * 2);
        ctx.fill();
        if (blinkOn) {
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(rightPillarX + frameW + 5, ly, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }
    // Red warning light at top center
    const redBlink = Math.sin(t / 500) > 0;
    ctx.fillStyle = redBlink ? '#ff3333' : '#2a0a0a';
    ctx.beginPath();
    ctx.arc(x + w / 2, y - 24 + (side === 'right' ? trapInset / 2 : trapInset / 2), 4, 0, Math.PI * 2);
    ctx.fill();
    if (redBlink) {
        ctx.shadowColor = '#ff3333';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(x + w / 2, y - 24 + trapInset / 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // Door opening / blade animation
    if (openPct > 0.02) {
        // Dark recessed interior behind door
        ctx.fillStyle = '#050505';
        ctx.fillRect(x, y, w, h);
        // Green LED edge strips inside
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 10;
        ctx.fillRect(x + 1, y, 2, h);
        ctx.fillRect(x + w - 3, y, 2, h);
        ctx.shadowBlur = 0;
    }

    // Blade door panels — split top/bottom, retract into frame
    const bladeTopH = (h / 2) * (1 - openPct);
    const bladeBotH = (h / 2) * (1 - openPct);
    if (bladeTopH > 1) {
        // Top blade
        const tGrad = ctx.createLinearGradient(x, y, x, y + bladeTopH);
        tGrad.addColorStop(0, '#666');
        tGrad.addColorStop(0.3, '#888');
        tGrad.addColorStop(0.7, '#777');
        tGrad.addColorStop(1, '#555');
        ctx.fillStyle = tGrad;
        ctx.fillRect(x, y, w, bladeTopH);
        // Reinforcement ribs
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x + 3, y + bladeTopH - 4, w - 6, 3);
        ctx.fillRect(x + 3, y + 4, w - 6, 3);
        // Center seam
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w / 2, y + bladeTopH);
        ctx.stroke();
        // Cyan LED strip at seam edge
        ctx.fillStyle = unlocked ? '#00ff88' : '#00ccff';
        ctx.shadowColor = unlocked ? '#00ff88' : '#00ccff';
        ctx.shadowBlur = 4;
        ctx.fillRect(x + 4, y + bladeTopH - 2, w - 8, 2);
        ctx.shadowBlur = 0;
    }
    if (bladeBotH > 1) {
        const botY = y + h - bladeBotH;
        // Bottom blade
        const bGrad = ctx.createLinearGradient(x, botY, x, botY + bladeBotH);
        bGrad.addColorStop(0, '#555');
        bGrad.addColorStop(0.3, '#777');
        bGrad.addColorStop(0.7, '#888');
        bGrad.addColorStop(1, '#666');
        ctx.fillStyle = bGrad;
        ctx.fillRect(x, botY, w, bladeBotH);
        // Reinforcement ribs
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x + 3, botY + 1, w - 6, 3);
        ctx.fillRect(x + 3, botY + bladeBotH - 7, w - 6, 3);
        // Center seam
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + w / 2, botY);
        ctx.lineTo(x + w / 2, botY + bladeBotH);
        ctx.stroke();
        // Cyan LED strip at seam edge
        ctx.fillStyle = unlocked ? '#00ff88' : '#00ccff';
        ctx.shadowColor = unlocked ? '#00ff88' : '#00ccff';
        ctx.shadowBlur = 4;
        ctx.fillRect(x + 4, botY, w - 8, 2);
        ctx.shadowBlur = 0;
    }

    // Keypad panel
    if (showKeypad) {
        const kpSide = (side === 'right') ? rightPillarX + frameW + 8 : leftPillarX - 28;
        const kpY = y + 30;
        // Dark mounting plate
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(kpSide - 2, kpY - 6, 24, 44);
        ctx.fillStyle = '#111';
        ctx.fillRect(kpSide, kpY - 4, 20, 40);
        // Screen
        ctx.fillStyle = unlocked ? '#002200' : '#002211';
        ctx.fillRect(kpSide + 2, kpY - 2, 16, 10);
        ctx.fillStyle = unlocked ? '#00ff88' : '#00ccff';
        ctx.font = 'bold 6px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(unlocked ? 'OPEN' : 'LOCK', kpSide + 10, kpY + 6);
        // Button grid
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                const bOn = Math.sin(t / 300 + r * 2 + c) > 0.3;
                ctx.fillStyle = unlocked ? (bOn ? '#00ff88' : '#003311') : (bOn ? '#00ccff' : '#004455');
                ctx.fillRect(kpSide + 2 + c * 6, kpY + 12 + r * 8, 4, 6);
            }
        }
        // Status indicator
        const indColor = unlocked ? '#00ff88' : '#ff3333';
        ctx.fillStyle = indColor;
        ctx.shadowColor = indColor;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(kpSide + 10, kpY - 10, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// Right-side gasket + boss door at pipe termination (levels 1-5 pipe rooms)
// Pipe inserts into gasket hole — matching level 5 hallway style (dark center = depth)
function drawPipeRoomRightWall(gasketY) {
    if (GX <= 5) return;

    // Bolted gasket at x=700 wall — dark center opening creates depth illusion
    // Pipe ends 6px before gasket center; #444 center = hole pipe enters
    drawGasket(700, gasketY);

    // Boss door — only from level 3 onward (company "built up")
    if (level >= 3) {
        // Door matching hallway door size (50x60), at right edge
        const doorX = 686, doorY = 340, doorW = 50, doorH = 60;
        if (bossDoor.state === 'open' || bossDoor.openPct > 0) {
            // Open door frame — wide dark opening boss emerges from
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(doorX, doorY, doorW, doorH);
            // Swung door (perspective: narrow slice on the right)
            const swingW = doorW * (1 - bossDoor.openPct) * 0.8;
            if (swingW > 2) {
                ctx.fillStyle = '#654321';
                ctx.fillRect(doorX + doorW - swingW, doorY + 2, swingW, doorH - 4);
                ctx.fillStyle = '#4a3a1a';
                ctx.fillRect(doorX + doorW - swingW + 3, doorY + 6, swingW - 6, doorH - 12);
            }
            // Door frame molding
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.strokeRect(doorX - 1, doorY - 1, doorW + 2, doorH + 2);
            // Door frame header
            ctx.fillStyle = '#666';
            ctx.fillRect(doorX - 2, doorY - 6, doorW + 4, 6);
        } else {
            // Closed door — matching hallway edge door style
            drawEdgeDoor(doorX, doorY, doorW, doorH);
            // Frame
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.strokeRect(doorX - 1, doorY - 1, doorW + 2, doorH + 2);
            ctx.fillStyle = '#666';
            ctx.fillRect(doorX - 2, doorY - 6, doorW + 4, 6);
        }
    }
}

// Edge door for level 6 room transitions (matching room aesthetic)
function drawLevel6EdgeDoor(side, roomStyle) {
    if (GX <= 5) return;
    const x = side === 'left' ? -6 : 670;
    const doorW = 40;
    const doorH = 80;
    const doorY = 320;

    if (roomStyle === 'dark') {
        // Dark steel door for megacomputer/dark rooms
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(x, doorY, doorW, doorH);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x + 3, doorY + 4, doorW - 6, doorH - 4);
        ctx.strokeStyle = '#4a4a4a';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 6, doorY + 8, doorW - 12, doorH / 2 - 12);
        ctx.strokeRect(x + 6, doorY + doorH / 2, doorW - 12, doorH / 2 - 8);
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(side === 'left' ? x + doorW - 10 : x + 10, doorY + doorH / 2, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (roomStyle === 'red') {
        // Wooden door with red tint for entryway
        ctx.fillStyle = '#5a2a1a';
        ctx.fillRect(x, doorY, doorW, doorH);
        ctx.fillStyle = '#4a1a0a';
        ctx.fillRect(x + 4, doorY + 5, doorW - 8, doorH - 5);
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(side === 'left' ? x + doorW - 10 : x + 10, doorY + doorH / 2, 3, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Standard wooden door for pipe room
        drawEdgeDoor(x, doorY, doorW, doorH);
    }
}


// SECTION 9: Level 5 Scene Drawing Functions (Part 1)
function drawLevel5PipeRoom() {
    ctx.fillStyle = '#e8e6dc';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    
    ctx.fillStyle = '#808080';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }
    
    ctx.fillStyle = '#7a7a7a';
    ctx.fillRect(20, 30, 220, 110);
    ctx.fillStyle = '#6a6a6a';
    ctx.fillRect(25, 35, 210, 100);
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(28, 38, 204, 94);
    
    for(let bx = 0; bx < 2; bx++) {
        for(let by = 0; by < 2; by++) {
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.arc(35 + bx * 190, 45 + by * 80, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8a8a8a';
            ctx.beginPath();
            ctx.arc(34 + bx * 190, 44 + by * 80, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 130, 75);
    
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(50, 82, 160, 1);
    
    ctx.fillStyle = '#d0d0d0';
    ctx.font = '10px Arial';
    ctx.fillText('GLOBAL LEADER IN PIPE DREAMS', 130, 97);
    
    for(let i = 0; i < 4; i++) {
        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(50, 105 + i * 5, 160, 3);
    }
    
    ctx.fillStyle = '#c4bfad';
    ctx.fillRect(-GX, 410, CANVAS_W, CANVAS_H);
    
    const comp = level5.computer;
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(comp.x - 30, comp.y, 60, 35);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(comp.x - 25, comp.y - 30, 50, 30);
    
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(comp.x - 22, comp.y - 27, 44, 24);
    
    if(level5.mulletPro.hasDoc && level5.mulletPro.docColor) {
        ctx.fillStyle = level5.mulletPro.docColor.hex;
    } else {
        ctx.fillStyle = '#004a7c';
    }
    ctx.fillRect(comp.x - 20, comp.y - 25, 40, 20);
    
    if(level5.mulletPro.hasDoc && level5.mulletPro.docColor) {
        ctx.shadowColor = level5.mulletPro.docColor.hex;
        ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(comp.x - 20, comp.y - 25, 40, 20);
        ctx.shadowBlur = 0;
    }
    
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(comp.x - 20, comp.y - 25, 40, 5);
    
    ctx.fillStyle = '#444';
    ctx.fillRect(comp.x - 5, comp.y, 10, 3);
    
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 7px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('DOC PRINTER', comp.x, comp.y + 30);

    // Right wall gasket BEFORE pipes so gasket renders behind
    drawPipeRoomRightWall(265);

    for(let npc of level5.npcPipes) {
        const pipeY = 240;

        // Wall gasket at top - curved mount with round bolted bevel (matching level 6)
        // Outer bevel ring (mounted in wall)
        ctx.fillStyle = '#999';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 18, 0, Math.PI * 2);
        ctx.fill();

        // Inner gasket plate (recessed)
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 14, 0, Math.PI * 2);
        ctx.fill();

        // Center pipe opening
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 8, 0, Math.PI * 2);
        ctx.fill();

        // Round bolts around the bevel (6 bolts evenly spaced)
        for(let b = 0; b < 6; b++) {
            const angle = (b / 6) * Math.PI * 2;
            const boltX = npc.x + Math.cos(angle) * 12;
            const boltY = 54 + Math.sin(angle) * 12;

            // Bolt head
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Bolt shadow/depth
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pipe starts from inner gasket opening (56) not outer edge (58)
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(npc.x, 56);
        ctx.lineTo(npc.x, pipeY);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(npc.x - 4, 56);
        ctx.lineTo(npc.x - 4, pipeY);
        ctx.stroke();
        
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.beginPath();
        ctx.moveTo(npc.x, pipeY);
        ctx.quadraticCurveTo(npc.x, pipeY + 25, npc.x + 25, pipeY + 25);
        ctx.lineTo(694, pipeY + 25);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(npc.x + 21, pipeY + 25);
        ctx.lineTo(694, pipeY + 25);
        ctx.stroke();

        // Animated flow effect on horizontal pipe section
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 6;
        ctx.setLineDash([12, 18]);
        ctx.lineDashOffset = -Date.now() / 150;
        ctx.beginPath();
        ctx.moveTo(npc.x + 25, pipeY + 25);
        ctx.lineTo(694, pipeY + 25);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        if(npc.needsDoc && npc.crackStartTime) {
            const crackTime = Date.now() - npc.crackStartTime;
            const pct = Math.min(crackTime / 15000, 1);
            ctx.fillStyle = npc.color.hex;
            ctx.globalAlpha = 0.4 + pct * 0.6;
            const sz = 18 + pct * 28;
            for(let i = 0; i < 3; i++) {
                ctx.fillRect(npc.x - sz / 2 + (i - 1) * 5, pipeY - 40 + i * 8, sz, 8);
            }
            ctx.globalAlpha = 1;
        }
        
        drawNPC(npc);
    }

    drawMulletPro(level5.mulletPro.x, level5.mulletPro.y, level5.mulletPro.facing, level5.mulletPro.hasDoc);

    if(level5.mulletPro.hasDoc && level5.mulletPro.docColor) {
        drawHeldDoc(level5.mulletPro.x, level5.mulletPro.y, level5.mulletPro.docColor.name);
    }

    // Right edge door prompt
    if(player.x >= 600) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(660 - 70, 310, 140, 20);
        ctx.fillStyle = '#ffd700';
        ctx.fillText('ACTION: HALLWAY \u2192', 660, 326);
    }
}

function drawLevel5Hallway() {
    ctx.fillStyle = '#d4c8b0';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    
    ctx.fillStyle = '#a89b85';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    
    for(let i = -4; i < 24; i++) {
        ctx.strokeStyle = '#988870';
        ctx.lineWidth = 1;
        ctx.strokeRect(i * 35, 400, 35, 100);
    }

    // CEO portrait at top - photorealistic image with ornate frame
    const portraitX = 350;
    const portraitY = 30;
    const portraitW = 120;
    const portraitH = 140;

    // Ornate golden frame
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(portraitX - portraitW/2 - 8, portraitY - 8, portraitW + 16, portraitH + 16);
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(portraitX - portraitW/2 - 6, portraitY - 6, portraitW + 12, portraitH + 12);
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(portraitX - portraitW/2 - 4, portraitY - 4, portraitW + 8, portraitH + 8);

    // Draw photorealistic portrait image
    if(portraitImg.complete && portraitImg.naturalWidth > 0) {
        ctx.drawImage(portraitImg, portraitX - portraitW/2, portraitY, portraitW, portraitH);
    } else {
        // Fallback dark background if image not loaded
        ctx.fillStyle = '#2b2520';
        ctx.fillRect(portraitX - portraitW/2, portraitY, portraitW, portraitH);
    }
    
    ctx.fillStyle = '#005f99';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PipeTech is your family.', 350, 215);

    const pipeY = 240;

    // Left wall gasket (over pipe room entrance) - curved mount with round bolted bevel
    const leftGasketX = 40;

    // Outer bevel ring (mounted in wall)
    ctx.fillStyle = '#999';
    ctx.beginPath();
    ctx.arc(leftGasketX, pipeY, 18, 0, Math.PI * 2);
    ctx.fill();

    // Inner gasket plate (recessed)
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(leftGasketX, pipeY, 14, 0, Math.PI * 2);
    ctx.fill();

    // Center pipe opening
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(leftGasketX, pipeY, 8, 0, Math.PI * 2);
    ctx.fill();

    // Round bolts around the bevel (6 bolts evenly spaced)
    for(let b = 0; b < 6; b++) {
        const angle = (b / 6) * Math.PI * 2;
        const boltX = leftGasketX + Math.cos(angle) * 12;
        const boltY = pipeY + Math.sin(angle) * 12;

        // Bolt head
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
        ctx.fill();

        // Bolt shadow/depth
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Right wall gasket (past blue office, before furnace) - curved mount with round bolted bevel
    const rightGasketX = 660;

    // Outer bevel ring (mounted in wall)
    ctx.fillStyle = '#999';
    ctx.beginPath();
    ctx.arc(rightGasketX, pipeY, 18, 0, Math.PI * 2);
    ctx.fill();

    // Inner gasket plate (recessed)
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(rightGasketX, pipeY, 14, 0, Math.PI * 2);
    ctx.fill();

    // Center pipe opening
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(rightGasketX, pipeY, 8, 0, Math.PI * 2);
    ctx.fill();

    // Round bolts around the bevel (6 bolts evenly spaced)
    for(let b = 0; b < 6; b++) {
        const angle = (b / 6) * Math.PI * 2;
        const boltX = rightGasketX + Math.cos(angle) * 12;
        const boltY = pipeY + Math.sin(angle) * 12;

        // Bolt head
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
        ctx.fill();

        // Bolt shadow/depth
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Gold pipe running between gaskets - starts from inner gasket openings
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 14;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(leftGasketX + 6, pipeY);
    ctx.lineTo(rightGasketX - 6, pipeY);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(leftGasketX + 6, pipeY - 4);
    ctx.lineTo(rightGasketX - 6, pipeY - 4);
    ctx.stroke();
    
    // Decorative office doors at ground level (y=280) - game.html style
    const officeDoorY = 280;
    for(let office of level5.hallway.offices) {
        // Office colored frame
        ctx.fillStyle = office.color.hex;
        ctx.fillRect(office.x - 35, officeDoorY, 70, 120);
        ctx.fillStyle = office.color.hex;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(office.x - 30, officeDoorY + 5, 60, 110);
        ctx.globalAlpha = 1;

        // Office door
        ctx.fillStyle = '#654321';
        ctx.fillRect(office.x - 22, officeDoorY + 15, 44, 95);
        ctx.fillStyle = '#4a3a1a';
        ctx.fillRect(office.x - 18, officeDoorY + 20, 36, 85);

        // Door knob
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(office.x + 10, officeDoorY + 62, 3, 0, Math.PI * 2);
        ctx.fill();

        // Color name above door
        ctx.fillStyle = '#2b2b2b';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(office.name, office.x, officeDoorY - 8);
    }

    // Left working door (50x60 size, at y=340)
    ctx.fillStyle = '#654321';
    ctx.fillRect(level5.hallway.leftDoor.x - 10, level5.hallway.leftDoor.y, 50, 60);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(level5.hallway.leftDoor.x - 5, level5.hallway.leftDoor.y + 5, 40, 50);
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(level5.hallway.leftDoor.x + 30, level5.hallway.leftDoor.y + 30, 3, 0, Math.PI * 2);
    ctx.fill();

    // Right working door (50x60 size, at y=340)
    ctx.fillStyle = '#654321';
    ctx.fillRect(level5.hallway.rightDoor.x - 10, level5.hallway.rightDoor.y, 50, 60);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(level5.hallway.rightDoor.x - 5, level5.hallway.rightDoor.y + 5, 40, 50);
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(level5.hallway.rightDoor.x - 25, level5.hallway.rightDoor.y + 30, 3, 0, Math.PI * 2);
    ctx.fill();

    // White outline for left door when in range
    if(Math.abs(player.x - level5.hallway.leftDoor.x) < 50) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(level5.hallway.leftDoor.x - 12, level5.hallway.leftDoor.y - 2, 54, 64);
    }

    // White outline for right door when in range
    if(Math.abs(player.x - level5.hallway.rightDoor.x) < 50) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(level5.hallway.rightDoor.x - 12, level5.hallway.rightDoor.y - 2, 54, 64);
    }

    // Draw lock icon on RED door when locked
    if(level5.redDoorLocked) {
        const redOffice = level5.hallway.offices[0]; // RED is index 0
        const lx = redOffice.x, ly = officeDoorY + 55;
        // Padlock body
        ctx.fillStyle = '#c0392b';
        ctx.fillRect(lx - 7, ly, 14, 12);
        // Padlock shackle
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(lx, ly - 2, 6, Math.PI, 0);
        ctx.stroke();
    }

    // White outline for office doors when in range + lock/unlock prompts
    for(let office of level5.hallway.offices) {
        if(Math.abs(player.x - office.x) < 40) {
            // RED door lock prompts
            if(office.name === 'RED' && level5.redDoorLocked) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.strokeRect(office.x - 37, officeDoorY - 2, 74, 124);
                ctx.fillStyle = level5.hasRedKey ? '#ffd700' : '#e74c3c';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(level5.hasRedKey ? 'UNLOCK?' : 'LOCKED', office.x, officeDoorY - 14);
            } else {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(office.x - 37, officeDoorY - 2, 74, 124);
            }
        }
    }

    // Portrait interaction - white outline when in range
    if(Math.abs(player.x - portraitX) < 80 && player.y < 320) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(portraitX - portraitW/2 - 12, portraitY - 5, portraitW + 24, portraitH + 10);
    }
}



// SECTION 10: Level 5 Scene Drawing Functions (Part 2)
function drawLevel5FurnaceRoom() {
    ctx.fillStyle = '#2b2520';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    
    ctx.fillStyle = '#1a1815';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#0a0a08';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }
    
    const furnace = level5.furnaceRoom.furnace;
    level5.furnaceRoom.furnace.glowPhase += 0.05;
    const glowIntensity = Math.sin(level5.furnaceRoom.furnace.glowPhase) * 0.3 + 0.7;
    
    const gradient = ctx.createRadialGradient(furnace.x, furnace.y, 20, furnace.x, furnace.y, 120);
    gradient.addColorStop(0, `rgba(255,100,0,${glowIntensity * 0.6})`);
    gradient.addColorStop(0.5, `rgba(255,50,0,${glowIntensity * 0.3})`);
    gradient.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(furnace.x, furnace.y, 120, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(furnace.x - 60, furnace.y - 40, 120, 80);
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(furnace.x - 50, furnace.y - 30, 100, 60);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(furnace.x - 40, furnace.y - 20, 80, 40);
    
    const isFlaming = Date.now() - furnace.flameTime < 2000;
    if(isFlaming) {
        const flameAlpha = Math.max(0, 1 - (Date.now() - furnace.flameTime) / 2000);
        for(let i = 0; i < 5; i++) {
            const flameY = furnace.y - 10 + Math.sin(frame * 0.3 + i) * 8;
            const flameH = 30 + Math.cos(frame * 0.2 + i) * 10;
            ctx.fillStyle = `rgba(255,${100 + i * 30},0,${flameAlpha * 0.8})`;
            ctx.fillRect(furnace.x - 30 + i * 15, flameY, 8, flameH);
        }
    } else {
        ctx.fillStyle = `rgba(255,100,0,${glowIntensity})`;
        ctx.fillRect(furnace.x - 35, furnace.y - 15, 70, 30);
    }
    
    ctx.fillStyle = '#654321';
    ctx.fillRect(level5.furnaceRoom.leftDoor.x - 10, level5.furnaceRoom.leftDoor.y, 50, 60);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(level5.furnaceRoom.leftDoor.x - 5, level5.furnaceRoom.leftDoor.y + 5, 40, 50);
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(level5.furnaceRoom.leftDoor.x + 30, level5.furnaceRoom.leftDoor.y + 30, 3, 0, Math.PI * 2);
    ctx.fill();

    if(Math.abs(player.x - level5.furnaceRoom.leftDoor.x) < 50) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('← HALLWAY', level5.furnaceRoom.leftDoor.x + 15, level5.furnaceRoom.leftDoor.y - 10);
    }
    
    if(Math.abs(player.x - furnace.x) < 90 && !player.holding && !level5.redKeyOnGround) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('FURNACE', furnace.x, furnace.y - 60);
    }
    if(Math.abs(player.x - furnace.x) < 90 && player.holding) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION TO BURN DOC', furnace.x, furnace.y - 60);
    }

    // Draw golden key on the ground (dropped from furnace after burning red doc)
    if(level5.redKeyOnGround) {
        const kx = furnace.x, ky = 385;
        // Glow effect
        ctx.fillStyle = 'rgba(255,215,0,0.25)';
        ctx.beginPath();
        ctx.arc(kx, ky, 20, 0, Math.PI * 2);
        ctx.fill();
        // Key ring (red keychain)
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(kx - 6, ky - 6, 6, 0, Math.PI * 2);
        ctx.stroke();
        // Key shaft
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(kx, ky - 2);
        ctx.lineTo(kx + 14, ky - 2);
        ctx.stroke();
        // Key teeth
        ctx.beginPath();
        ctx.moveTo(kx + 10, ky - 2);
        ctx.lineTo(kx + 10, ky + 4);
        ctx.moveTo(kx + 14, ky - 2);
        ctx.lineTo(kx + 14, ky + 4);
        ctx.stroke();
        // Pickup prompt
        if(Math.abs(player.x - furnace.x) < 60 && !player.holding) {
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PRESS ACTION - PICK UP KEY', kx, ky - 30);
        }
    }

    // Concealed right door — passage to cloning room (visible when unlocked)
    const rdX = 640, rdY = 340, rdW = 50, rdH = 60;
    if (level6.cloningDoorUnlocked) {
        // Open passage with dark interior and green LED edge
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(rdX, rdY, rdW, rdH);
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 6;
        ctx.fillRect(rdX, rdY, 2, rdH);
        ctx.shadowBlur = 0;
        // Subtle frame outline
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 2;
        ctx.strokeRect(rdX, rdY, rdW, rdH);

        if (player.x > 600) {
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(rdX + rdW/2 - 55, rdY - 20, 110, 18);
            ctx.fillStyle = '#00ff88';
            ctx.fillText('CLONING LAB →', rdX + rdW/2, rdY - 6);
        }
    }
}

function drawOfficeRoom(officeName) {
    const office = level5.hallway.offices.find(o => o.name === officeName);
    const color = office.color;
    
    ctx.fillStyle = '#d4c8b0';
    ctx.fillRect(-GX, -GY, CANVAS_W, 300 + GY);
    
    // Color-coded carpet — prominent tint matching office manager color
    ctx.fillStyle = color.hex;
    ctx.globalAlpha = 0.55;
    ctx.fillRect(-GX, 300, CANVAS_W, CANVAS_H);
    ctx.globalAlpha = 1;

    for(let i = -4; i < 24; i++) {
        ctx.strokeStyle = color.hex;
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 1;
        ctx.strokeRect(i * 35, 300, 35, 200);
        ctx.globalAlpha = 1;
    }
    
    // Window view - realistic outdoor scene
    // Sky with gradient
    const skyGradient = ctx.createLinearGradient(180, 40, 180, 120);
    skyGradient.addColorStop(0, '#87CEEB');
    skyGradient.addColorStop(1, '#b0d8f0');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(180, 40, 340, 200);

    // Clouds
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(250, 70, 20, 0, Math.PI * 2);
    ctx.arc(270, 70, 25, 0, Math.PI * 2);
    ctx.arc(290, 70, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(420, 90, 18, 0, Math.PI * 2);
    ctx.arc(435, 90, 22, 0, Math.PI * 2);
    ctx.arc(450, 90, 18, 0, Math.PI * 2);
    ctx.fill();

    // Window frame - wooden
    ctx.strokeStyle = '#4a3a1a';
    ctx.lineWidth = 8;
    ctx.strokeRect(180, 40, 340, 200);

    // Window curtains/blinds
    ctx.fillStyle = color.hex;
    ctx.globalAlpha = 0.8;
    ctx.fillRect(160, 35, 15, 210);
    ctx.fillRect(525, 35, 15, 210);
    ctx.globalAlpha = 1;

    // Curtain texture
    ctx.strokeStyle = color.hex;
    ctx.globalAlpha = 0.5;
    ctx.lineWidth = 2;
    for(let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(163 + i * 3, 40);
        ctx.lineTo(163 + i * 3, 240);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(528 + i * 3, 40);
        ctx.lineTo(528 + i * 3, 240);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Distant buildings/skyline
    ctx.fillStyle = '#7a7a7a';
    ctx.fillRect(190, 80, 320, 75);
    ctx.fillStyle = '#8a8a8a';
    ctx.fillRect(210, 90, 40, 65);
    ctx.fillRect(280, 100, 50, 55);
    ctx.fillRect(360, 95, 45, 60);
    ctx.fillRect(430, 105, 55, 50);

    // Building windows
    for(let row = 0; row < 2; row++) {
        for(let col = 0; col < 8; col++) {
            ctx.fillStyle = row % 2 === col % 2 ? '#4a9eff' : '#3a8eef';
            ctx.fillRect(200 + col * 38, 135 + row * 12, 25, 8);
        }
    }

    // Parking lot surface - realistic asphalt
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(190, 160, 320, 78);

    // Parking lot lines (white stripes)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    for(let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(190 + i * 80, 160);
        ctx.lineTo(190 + i * 80, 238);
        ctx.stroke();
    }

    // Realistic cars with better detail
    const carColors = [
        {body: '#c0392b', dark: '#8b2a1f', light: '#e74c3c'},  // Red
        {body: '#27ae60', dark: '#1e8449', light: '#2ecc71'},  // Green
        {body: '#005f99', dark: '#004466', light: '#007acc'},  // Blue
        {body: '#d68910', dark: '#aa6c08', light: '#f39c12'}   // Orange
    ];

    for(let i = 0; i < 4; i++) {
        const carX = 200 + i * 80;
        const carY = 180;
        const colors = carColors[i];

        // Car body
        ctx.fillStyle = colors.body;
        ctx.fillRect(carX, carY, 60, 35);

        // Car roof
        ctx.fillRect(carX + 10, carY - 15, 40, 15);

        // Car shading
        ctx.fillStyle = colors.dark;
        ctx.fillRect(carX, carY + 30, 60, 5);
        ctx.fillRect(carX + 10, carY - 15, 40, 3);

        // Windshield
        ctx.fillStyle = 'rgba(150,180,220,0.6)';
        ctx.fillRect(carX + 12, carY - 13, 16, 12);

        // Back window
        ctx.fillRect(carX + 32, carY - 13, 16, 12);

        // Side window reflection
        ctx.fillStyle = 'rgba(200,220,255,0.3)';
        ctx.fillRect(carX + 5, carY + 5, 50, 18);

        // Tires
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(carX + 8, carY + 32, 10, 6);
        ctx.fillRect(carX + 42, carY + 32, 10, 6);

        // Tire shine
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(carX + 10, carY + 33, 6, 2);
        ctx.fillRect(carX + 44, carY + 33, 6, 2);

        // Headlights
        ctx.fillStyle = colors.light;
        ctx.fillRect(carX + 2, carY + 10, 3, 8);
        ctx.fillRect(carX + 2, carY + 20, 3, 8);
    }

    // Ground/grass at base
    ctx.fillStyle = '#5a7a3a';
    ctx.fillRect(190, 232, 320, 8);

    // Ground texture
    ctx.fillStyle = '#6b8e23';
    ctx.fillRect(192, 234, 316, 2);
    ctx.fillRect(194, 237, 312, 1);

    // Steel beam pole for sign - reflective metallic gray/silver
    ctx.fillStyle = '#9a9a9a';
    ctx.fillRect(346, 150, 8, 86);

    // Metallic shine on beam
    ctx.fillStyle = '#c0c0c0';
    ctx.fillRect(347, 150, 3, 86);

    // Dark edge for depth
    ctx.fillStyle = '#707070';
    ctx.fillRect(353, 150, 1, 86);

    // PipeTech sign - brutalist style mounted on steel beam
    // Dark background panel
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(295, 95, 110, 50);

    // Brutalist company name
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 350, 115);

    // Four-colored pipe logo stripes
    const stripeY = 120;
    const stripeWidth = 80;
    const stripeHeight = 4;
    for(let i = 0; i < 4; i++) {
        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(350 - stripeWidth/2, stripeY + i * 5, stripeWidth, stripeHeight);
    }

    // Metallic mounting brackets
    ctx.fillStyle = '#888';
    ctx.fillRect(293, 100, 4, 40);
    ctx.fillRect(403, 100, 4, 40);
    ctx.fillStyle = '#aaa';
    ctx.fillRect(293, 100, 2, 40);
    ctx.fillRect(403, 100, 2, 40);
    
    const deskX = 350;
    const deskY = 250;

    // Desk - more realistic with wood-like appearance
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(deskX - 52, deskY - 2, 104, 44);

    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(deskX - 50, deskY, 100, 40);

    // Desk surface with gradient effect
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(deskX - 48, deskY + 2, 96, 36);

    // Desk legs
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(deskX - 45, deskY + 38, 6, 12);
    ctx.fillRect(deskX + 39, deskY + 38, 6, 12);

    // Desk edge highlight
    ctx.strokeStyle = '#6a6a6a';
    ctx.lineWidth = 2;
    ctx.strokeRect(deskX - 50, deskY, 100, 40);
    
    // Monitor - positioned center/right of desk
    const monitorX = deskX + 10;
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(monitorX - 18, deskY + 6, 36, 26);
    ctx.fillRect(monitorX - 15, deskY + 4, 30, 30);

    // Monitor screen
    ctx.fillStyle = level5.viewingEmail ? '#4a9eff' : '#1a1a1a';
    ctx.fillRect(monitorX - 13, deskY + 8, 26, 18);

    // Screen glow effect when active
    if(level5.viewingEmail) {
        ctx.shadowColor = '#4a9eff';
        ctx.shadowBlur = 20;
        ctx.fillRect(monitorX - 13, deskY + 8, 26, 18);
        ctx.shadowBlur = 0;

        // Email content preview
        ctx.fillStyle = '#fff';
        ctx.font = '6px Arial';
        ctx.fillRect(monitorX - 11, deskY + 10, 22, 2);
        ctx.fillRect(monitorX - 11, deskY + 13, 18, 1);
        ctx.fillRect(monitorX - 11, deskY + 15, 20, 1);
        ctx.fillRect(monitorX - 11, deskY + 17, 16, 1);
    } else {
        // Idle screen with subtle blue tint
        ctx.fillStyle = 'rgba(74, 158, 255, 0.1)';
        ctx.fillRect(monitorX - 13, deskY + 8, 26, 18);
    }

    // Monitor bezel highlights
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 1;
    ctx.strokeRect(monitorX - 13, deskY + 8, 26, 18);

    // Monitor stand
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(monitorX - 4, deskY + 30, 8, 6);
    ctx.fillRect(monitorX - 10, deskY + 36, 20, 3);
    
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(deskX - 38, deskY + 15, 18, 12);
    ctx.fillRect(deskX - 43, deskY + 12, 8, 6);
    ctx.fillStyle = '#3a3a3a';
    for(let i = 0; i < 3; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.fillRect(deskX - 36 + j * 5, deskY + 18 + i * 3, 3, 2);
        }
    }
    
    ctx.fillStyle = color.hex;
    ctx.fillRect(deskX + 25, deskY + 18, 14, 16);
    ctx.strokeStyle = color.hex;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(deskX + 32, deskY + 26, 7, 0, Math.PI * 2);
    ctx.stroke();
    
    for(let i = 0; i < 4; i++) {
        ctx.strokeStyle = COLORS[i].hex;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(deskX + 27 + i * 3, deskY + 18);
        ctx.lineTo(deskX + 27 + i * 3, deskY + 8);
        ctx.stroke();
    }
    
    // Letter on LEFT side of desk (RED office only)
    if(officeName === 'RED') {
        const letterX = deskX - 25;
        ctx.fillStyle = '#fff';
        ctx.fillRect(letterX - 7, deskY + 10, 14, 18);

        // Coffee stain ring
        ctx.strokeStyle = 'rgba(139,69,19,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(letterX + 2, deskY + 15, 5, 0, Math.PI * 2);
        ctx.stroke();

        // Letter text lines
        ctx.fillStyle = '#000';
        ctx.globalAlpha = 0.3;
        for(let i = 0; i < 4; i++) {
            ctx.fillRect(letterX - 5, deskY + 13 + i * 3, 10, 1);
        }
        ctx.globalAlpha = 1;
    }
    
    // Office chair - more detailed and recognizable
    // Chair back
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(deskX - 18, deskY + 54, 36, 38);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(deskX - 16, deskY + 56, 32, 34);

    // Chair back cushion detail
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(deskX - 14, deskY + 58, 28, 30);

    // Chair seat
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(deskX - 20, deskY + 44, 40, 14);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(deskX - 18, deskY + 46, 36, 10);

    // Chair base/wheels
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(deskX - 2, deskY + 86, 4, 6);

    // Wheels
    ctx.fillStyle = '#555';
    ctx.fillRect(deskX - 18, deskY + 90, 8, 3);
    ctx.fillRect(deskX + 10, deskY + 90, 8, 3);
    ctx.fillRect(deskX - 4, deskY + 90, 8, 3);

    // Exit area (no physical door - open space)
    if(player.y > 420 && Math.abs(player.x - 350) < 70) {
        // Exit prompt with dark background for visibility
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(200, 418, 300, 24);

        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION - EXIT TO HALLWAY', 350, 435);

        // Arrow pointing down/out
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(340, 445);
        ctx.lineTo(350, 455);
        ctx.lineTo(360, 445);
        ctx.fill();
    }

    // Monitor interaction prompt - more visible and clearer range
    if(Math.abs(player.x - deskX) < 60 && player.y > deskY + 30 && player.y < deskY + 70 && !level5.viewingEmail && !level5.viewingLetter) {
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION - VIEW MONITOR', deskX, deskY - 5);

        // Arrow pointing to monitor
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(deskX - 5, deskY);
        ctx.lineTo(deskX, deskY + 5);
        ctx.lineTo(deskX + 5, deskY);
        ctx.fill();
    }

    // Letter interaction prompt (RED office only) - aligned with letter position
    if(officeName === 'RED') {
        const letterX = deskX - 25;
        if(Math.abs(player.x - letterX) < 35 && player.y > deskY + 30 && player.y < deskY + 70 && !level5.viewingEmail && !level5.viewingLetter) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ACTION - VIEW LETTER', letterX, deskY + 5);

            // Arrow pointing to letter
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(letterX - 5, deskY + 8);
            ctx.lineTo(letterX, deskY + 3);
            ctx.lineTo(letterX + 5, deskY + 8);
            ctx.fill();
        }
    }
}
// SECTION 10: Level 6 Scene Drawing Functions
function drawLevel6PipeRoom() {
    ctx.fillStyle = '#e8e6dc';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    ctx.fillStyle = '#808080';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);

    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    ctx.fillStyle = '#c4bfad';
    ctx.fillRect(-GX, 410, CANVAS_W, CANVAS_H);

    // Wall-mounted PipeTech signage (brutalist painted text) - large, centered, edge to edge
    ctx.fillStyle = '#3a3a3a';
    ctx.font = 'bold 80px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 350, 70);

    // Four colored stripe lines running wall to wall underneath, centered on wall
    const lineY = 85;
    for(let i = 0; i < 4; i++) {
        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(-GX, lineY + i * 8, CANVAS_W, 6);
    }

    // Draw pipes running from top wall gaskets to floor gaskets with managers
    // Inverted positions from previous levels (opposite side of wall)
    const pipePositions = [280, 380, 480, 580]; // Inverted from typical positions

    for(let i = 0; i < level6.npcPipes.length; i++) {
        const npc = level6.npcPipes[i];
        const pipeX = pipePositions[i];

        // Wall gasket at top - curved mount with round bolted bevel
        // Outer bevel ring (mounted in wall)
        ctx.fillStyle = '#999';
        ctx.beginPath();
        ctx.arc(pipeX, 130, 18, 0, Math.PI * 2);
        ctx.fill();

        // Inner gasket plate (recessed)
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(pipeX, 130, 14, 0, Math.PI * 2);
        ctx.fill();

        // Center pipe opening
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(pipeX, 130, 8, 0, Math.PI * 2);
        ctx.fill();

        // Round bolts around the bevel (6 bolts evenly spaced)
        for(let b = 0; b < 6; b++) {
            const angle = (b / 6) * Math.PI * 2;
            const boltX = pipeX + Math.cos(angle) * 12;
            const boltY = 130 + Math.sin(angle) * 12;

            // Bolt head
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Bolt shadow/depth
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Vertical pipe connecting directly from gasket center to floor
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(pipeX, 138); // Start from gasket opening
        ctx.lineTo(pipeX, 400);
        ctx.stroke();

        // Primary highlight (bright metallic shine)
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(pipeX - 5, 138);
        ctx.lineTo(pipeX - 5, 400);
        ctx.stroke();

        // Secondary highlight (subtle)
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(pipeX - 3, 138);
        ctx.lineTo(pipeX - 3, 400);
        ctx.stroke();

        // Shadow on opposite side for depth
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pipeX + 5, 138);
        ctx.lineTo(pipeX + 5, 400);
        ctx.stroke();

        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';

        // Floor gasket at bottom
        ctx.fillStyle = '#888';
        ctx.fillRect(pipeX - 12, 398, 24, 8);
        ctx.fillStyle = '#666';
        ctx.fillRect(pipeX - 10, 400, 20, 4);
    }

    // Death Star trapezoidal blast door to megacomputer (right side)
    const doorX = 618, doorY = 275, doorW = 70, doorH = 125;
    drawDeathStarBlastDoor(doorX, doorY, doorW, doorH, 'right', level6.bladeDoor.openPct, true, level6.supercomputerUnlocked);

    // Private elevator (left side, in-frame for portrait + landscape)
    const elvX = 5, elvY = 240, elvW = 130, elvH = 160;
    // Outer wall surround — dark concrete
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(elvX - 6, elvY - 24, elvW + 12, elvH + 30);
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(elvX - 4, elvY - 22, elvW + 8, elvH + 26);
    // Elevator frame — brushed gold
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(elvX - 2, elvY - 2, elvW + 4, elvH + 4);
    // Elevator shaft interior
    const elvDoorOpen = level6.elevatorDoorOpen || 0;
    const halfW = (elvW / 2) * (1 - elvDoorOpen);
    if (elvDoorOpen > 0.5) {
        // Open — bright glowing interior with depth
        ctx.fillStyle = '#fffde8';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;
        ctx.fillRect(elvX, elvY, elvW, elvH);
        ctx.shadowBlur = 0;
        // Interior back wall
        ctx.fillStyle = '#e8e0c8';
        ctx.fillRect(elvX + 8, elvY + 8, elvW - 16, elvH - 16);
        // Interior railing
        ctx.strokeStyle = '#d4af37';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(elvX + 12, elvY + elvH * 0.6);
        ctx.lineTo(elvX + elvW - 12, elvY + elvH * 0.6);
        ctx.stroke();
    } else {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(elvX, elvY, elvW, elvH);
    }
    // Door panels (slide open/closed)
    if (halfW > 1) {
        const doorGrad = ctx.createLinearGradient(elvX, elvY, elvX + halfW, elvY);
        doorGrad.addColorStop(0, '#c8c8c8');
        doorGrad.addColorStop(0.5, '#e0e0e0');
        doorGrad.addColorStop(1, '#a0a0a0');
        ctx.fillStyle = doorGrad;
        ctx.fillRect(elvX, elvY, halfW, elvH);
        const doorGrad2 = ctx.createLinearGradient(elvX + elvW - halfW, elvY, elvX + elvW, elvY);
        doorGrad2.addColorStop(0, '#a0a0a0');
        doorGrad2.addColorStop(0.5, '#e0e0e0');
        doorGrad2.addColorStop(1, '#c8c8c8');
        ctx.fillStyle = doorGrad2;
        ctx.fillRect(elvX + elvW - halfW, elvY, halfW, elvH);
        // Center seam line
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(elvX + halfW, elvY + 4);
        ctx.lineTo(elvX + halfW, elvY + elvH - 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(elvX + elvW - halfW, elvY + 4);
        ctx.lineTo(elvX + elvW - halfW, elvY + elvH - 4);
        ctx.stroke();
    }
    // Engraved letters on doors: "PI" | "PE"
    if (halfW > 18) {
        ctx.fillStyle = '#d4af37';
        ctx.font = 'bold 22px serif';
        ctx.textAlign = 'center';
        ctx.fillText('PI', elvX + halfW / 2, elvY + elvH / 2 + 8);
        ctx.fillText('PE', elvX + elvW - halfW / 2, elvY + elvH / 2 + 8);
    }
    // Frame outline
    ctx.strokeStyle = '#8a7a2a';
    ctx.lineWidth = 3;
    ctx.strokeRect(elvX - 2, elvY - 2, elvW + 4, elvH + 4);
    // LED floor indicator above door (wider)
    ctx.fillStyle = '#111';
    ctx.fillRect(elvX + elvW / 2 - 22, elvY - 20, 44, 16);
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.strokeRect(elvX + elvW / 2 - 22, elvY - 20, 44, 16);
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('B1', elvX + elvW / 2, elvY - 8);
    // Call button panel (right of door)
    ctx.fillStyle = '#555';
    ctx.fillRect(elvX + elvW + 8, elvY + elvH / 2 - 16, 18, 32);
    ctx.strokeStyle = '#777';
    ctx.lineWidth = 1;
    ctx.strokeRect(elvX + elvW + 8, elvY + elvH / 2 - 16, 18, 32);
    // Up arrow button
    ctx.fillStyle = player.x < 130 ? '#ffd700' : '#444';
    ctx.beginPath();
    const cbx = elvX + elvW + 17;
    ctx.moveTo(cbx, elvY + elvH / 2 - 8);
    ctx.lineTo(cbx - 5, elvY + elvH / 2);
    ctx.lineTo(cbx + 5, elvY + elvH / 2);
    ctx.closePath();
    ctx.fill();
    // Down arrow button
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.moveTo(cbx, elvY + elvH / 2 + 10);
    ctx.lineTo(cbx - 5, elvY + elvH / 2 + 2);
    ctx.lineTo(cbx + 5, elvY + elvH / 2 + 2);
    ctx.closePath();
    ctx.fill();

    // Direction prompts — dark background pill for readability against light wall
    if(player.x < 130) {
        const promptText = 'ACTION: ELEVATOR';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        const ptX = elvX + elvW / 2 + 10, ptY = elvY - 30;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(ptX - 90, ptY - 14, 180, 22);
        ctx.fillStyle = '#fff';
        ctx.fillText(promptText, ptX, ptY);
    }

    if(player.x > 620 && !level6.supercomputerUnlocked) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(550 - 105, 280 - 14, 210, 22);
        ctx.fillStyle = '#00ccff';
        ctx.fillText('ACTION TO ENTER CODE', 550, 280);
    } else if(player.x > 620 && level6.supercomputerUnlocked) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(550 - 85, 280 - 14, 170, 22);
        ctx.fillStyle = '#00ff88';
        ctx.fillText('ACCESS GRANTED →', 550, 280);
    }
}

function drawLevel6MegacomputerRoom() {
    // Dark room background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Floor
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);

    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    // Death Star trapezoidal blast door on left — matching pipe room gateway
    const mcDoorX = 20, mcDoorY = 275, mcDoorW = 70, mcDoorH = 125;
    drawDeathStarBlastDoor(mcDoorX, mcDoorY, mcDoorW, mcDoorH, 'left', level6.bladeDoorMega.openPct, false, true);

    // Wall-mounted brutalist slogan painted wall to wall
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Creating a new fission of the future.', 350, 60);

    // Yellow pipe running from left wall gasket to center
    const pipeY = 180; // Same relative height as Level 5 hallway

    // Left wall gasket - curved mount with round bolted bevel (matching pipe room style)
    const gasketX = 17;

    // Outer bevel ring (mounted in wall)
    ctx.fillStyle = '#999';
    ctx.beginPath();
    ctx.arc(gasketX, pipeY, 18, 0, Math.PI * 2);
    ctx.fill();

    // Inner gasket plate (recessed)
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(gasketX, pipeY, 14, 0, Math.PI * 2);
    ctx.fill();

    // Center pipe opening
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(gasketX, pipeY, 8, 0, Math.PI * 2);
    ctx.fill();

    // Round bolts around the bevel (6 bolts evenly spaced)
    for(let b = 0; b < 6; b++) {
        const angle = (b / 6) * Math.PI * 2;
        const boltX = gasketX + Math.cos(angle) * 12;
        const boltY = pipeY + Math.sin(angle) * 12;

        // Bolt head
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
        ctx.fill();

        // Bolt shadow/depth
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Nuclear-powered AI Megacomputer
    const compX = 350;
    const compY = 350;
    const reservoirY = compY - 60; // 290
    const reservoirX = compX - 50;

    // Right-angle yellow pipe from gasket to reservoir top (L-shape: horizontal then vertical)
    const endX = reservoirX + 20; // Pipe connects to reservoir
    const endY = reservoirY;
    const cornerX = endX; // Corner point for right angle
    const cornerY = pipeY; // Keep same Y until corner

    ctx.strokeStyle = COLORS[3].hex; // Yellow
    ctx.lineWidth = 14;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(gasketX, pipeY);

    // Right angle: horizontal from gasket, then vertical down to reservoir
    ctx.lineTo(cornerX, cornerY); // Horizontal segment
    ctx.lineTo(endX, endY); // Vertical segment down
    ctx.stroke();

    // Pipe shine following the right-angle path
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(gasketX, pipeY - 4);
    ctx.lineTo(cornerX, cornerY - 4); // Horizontal segment
    ctx.lineTo(endX, endY - 4); // Vertical segment down
    ctx.stroke();

    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';

    // Main computer body (bulky 80s sci-fi style)
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(compX - 80, compY - 80, 160, 100);

    // Darker panels
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(compX - 75, compY - 75, 70, 90);
    ctx.fillRect(compX + 5, compY - 75, 70, 90);

    // Nuclear reactor reservoir with glowing green liquid
    // reservoirX and reservoirY already declared above at lines 2662 and 2661
    const reservoirW = 40;
    const reservoirH = 70;

    // Glass container outline
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 3;
    ctx.strokeRect(reservoirX, reservoirY, reservoirW, reservoirH);

    // Glowing green bubbling liquid (brighter, more volatile)
    const liquidLevel = reservoirH - 10;
    const bubbleTime = Date.now() / 200; // Faster bubbling

    // Bright glowing liquid with pulsing effect
    const pulseBrightness = 0.85 + Math.sin(Date.now() / 400) * 0.15;
    ctx.fillStyle = '#00ff00';
    ctx.globalAlpha = pulseBrightness;
    ctx.fillRect(reservoirX + 2, reservoirY + (reservoirH - liquidLevel), reservoirW - 4, liquidLevel);
    ctx.globalAlpha = 1;

    // Stronger glow effect around liquid
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 25;
    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
    ctx.fillRect(reservoirX - 2, reservoirY, reservoirW + 4, reservoirH);
    ctx.shadowBlur = 0;

    // More volatile bubbles rising in liquid
    for(let b = 0; b < 6; b++) { // More bubbles
        const bubbleY = reservoirY + reservoirH - ((bubbleTime * 1.5 + b * 20) % liquidLevel);
        const bubbleX = reservoirX + 8 + Math.sin(bubbleTime / 5 + b) * 12 + b * 4;
        ctx.fillStyle = 'rgba(200, 255, 200, 0.8)';
        ctx.beginPath();
        ctx.arc(bubbleX, bubbleY, 2 + (b % 3), 0, Math.PI * 2);
        ctx.fill();
    }

    // Monitor screen with blinking green prompt (moved higher to avoid overlap)
    const screenX = compX + 15;
    const screenY = compY - 65;
    const screenW = 50;
    const screenH = 35;

    // Screen bezel
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(screenX - 3, screenY - 3, screenW + 6, screenH + 6);

    // Screen display
    ctx.fillStyle = '#001a00';
    ctx.fillRect(screenX, screenY, screenW, screenH);

    // Blinking green text
    const textBlink = Math.floor(Date.now() / 700) % 2;
    if(textBlink) {
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 7px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Awaiting', screenX + screenW / 2, screenY + 12);
        ctx.fillText('executive', screenX + screenW / 2, screenY + 20);
        ctx.fillText('command...', screenX + screenW / 2, screenY + 28);
    }

    // Biohazard warning sticker on nuclear reservoir tank
    const stickerX = reservoirX + reservoirW / 2;
    const stickerY = reservoirY + 8;

    // Yellow warning sticker background (smaller to fit within tank)
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(stickerX - 14, stickerY, 28, 28);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.strokeRect(stickerX - 14, stickerY, 28, 28);

    // Biohazard symbol
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('☢', stickerX, stickerY + 19);

    // Warning text below sticker - better spaced for readability
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 6px Arial';
    ctx.fillText('WARNING', stickerX, stickerY + 36);
    ctx.font = '5px Arial';
    ctx.fillText('HAZARDOUS', stickerX, stickerY + 42);
    ctx.fillText('Gear required', stickerX, stickerY + 48);

    // Bundled and organized wiring - more precise arrangement
    const wireColors = ['#e74c3c', '#27ae60', '#005f99', '#f39c12'];
    const bundleX = compX - 65;
    const bundleY = compY + 15;

    // Wire bundle runs from bottom of computer to liquid tank
    for(let i = 0; i < 4; i++) {
        ctx.strokeStyle = wireColors[i];
        ctx.lineWidth = 2.5;
        ctx.beginPath();

        // Organized parallel routing with slight offset
        const wireOffset = i * 3 - 4.5;
        ctx.moveTo(bundleX + wireOffset, bundleY);
        ctx.lineTo(bundleX + wireOffset, compY - 40); // Up to tank level

        // Curve into tank
        ctx.quadraticCurveTo(
            bundleX + wireOffset + 5, compY - 50,
            reservoirX - 5, compY - 55 + i * 3
        );

        ctx.stroke();

        // Wire connectors at tank
        ctx.fillStyle = wireColors[i];
        ctx.beginPath();
        ctx.arc(reservoirX - 5, compY - 55 + i * 3, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // Vintage Star Trek style blinking buttons
    const buttonTime = Date.now() / 500;
    const buttonColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
    for(let i = 0; i < 12; i++) {
        const btnX = compX - 70 + (i % 6) * 12;
        const btnY = compY + 28 + Math.floor(i / 6) * 12;
        const blinkState = Math.floor(buttonTime + i) % 2;
        ctx.fillStyle = blinkState ? buttonColors[i % buttonColors.length] : '#333';
        ctx.beginPath();
        ctx.arc(btnX, btnY, 4, 0, Math.PI * 2);
        ctx.fill();
    }

    // Radiation glow zone indicator (where player takes damage)
    if(player.x > 233 && player.x < 467) {
        ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
        ctx.fillRect(233, 0, 234, 500);

        // Show radiation warning overlay on player
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(player.x, player.y, 30, 0, Math.PI * 2);
        ctx.fill();
    }

    // Dead private detective - lying on ground (90° from standing position)
    // Body positioned horizontally, head to the left, feet to the right
    // Right arm raised holding note (upward from body)
    const detectiveX = 540; // Center point of body
    const detectiveY = 445; // Ground level
    const s = 2; // Scale factor to match other NPCs

    // Simple blood pool (no active splatter - he's been dead for hours)
    ctx.fillStyle = '#6b0000';
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.ellipse(detectiveX, detectiveY + 2, 60, 25, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Darker center of dried blood pool
    ctx.fillStyle = '#4a0000';
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.ellipse(detectiveX, detectiveY + 2, 40, 15, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // DETECTIVE CHARACTER - Pixel art style like mullet pro/bald boss
    // Lying flat on back (90° from standing position)
    // Complete horizontal body from head (left) to feet (right)

    // Define skin tone (pale/dead)
    const detectiveSkin = '#c9b5a0';

    // Back/far leg (left leg, behind) - repositioned to connect with torso
    ctx.fillStyle = '#2a2a3d'; // Dark blue suit pants
    ctx.fillRect(detectiveX + 6*s, detectiveY - 2*s, 16*s, 4*s); // Upper leg - connects to torso
    ctx.fillRect(detectiveX + 20*s, detectiveY - 3*s, 14*s, 4*s); // Lower leg

    // Back shoe
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(detectiveX + 33*s, detectiveY - 4*s, 5*s, 4*s);

    // Left arm (down by side)
    ctx.fillStyle = '#1a1a4d'; // Dark blue detective suit
    ctx.fillRect(detectiveX - 10*s, detectiveY - 8*s, 12*s, 3*s); // Left arm along body
    ctx.fillStyle = detectiveSkin;
    ctx.fillRect(detectiveX - 11*s, detectiveY - 9*s, 3*s, 3*s); // Left hand

    // HEAD - lying flat, face up
    ctx.fillStyle = detectiveSkin;
    ctx.fillRect(detectiveX - 18*s, detectiveY - 16*s, 10*s, 11*s); // Head

    // Short dark hair (detective style)
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(detectiveX - 18*s, detectiveY - 17*s, 10*s, 4*s); // Hair top
    ctx.fillRect(detectiveX - 19*s, detectiveY - 14*s, 2*s, 6*s); // Hair side
    ctx.fillRect(detectiveX - 8*s, detectiveY - 14*s, 2*s, 6*s); // Hair other side

    // Dead pallor/shading
    ctx.fillStyle = 'rgba(100, 80, 120, 0.15)';
    ctx.fillRect(detectiveX - 18*s, detectiveY - 13*s, 10*s, 8*s);

    // Closed eyes (dead)
    ctx.fillStyle = '#000';
    ctx.fillRect(detectiveX - 16*s, detectiveY - 12*s, 2*s, 1); // Left eye
    ctx.fillRect(detectiveX - 11*s, detectiveY - 12*s, 2*s, 1); // Right eye

    // Nose
    ctx.fillStyle = '#b59f8a';
    ctx.fillRect(detectiveX - 14*s, detectiveY - 10*s, 3*s, 2*s);

    // Mouth (slightly open, dead)
    ctx.fillStyle = '#4a2a2a';
    ctx.fillRect(detectiveX - 15*s, detectiveY - 7*s, 4*s, 1);

    // Small blood trickle from mouth
    ctx.fillStyle = '#660000';
    ctx.fillRect(detectiveX - 11*s, detectiveY - 7*s, 1, 2*s);

    // Fedora fallen beside head (on ground) — disappears once picked up
    const hatX = detectiveX - 24*s;
    const hatY = detectiveY - 8*s;
    if(!level6.hasDetectiveHat) {
        ctx.fillStyle = '#3a3a3a'; // Dark gray fedora
        ctx.beginPath();
        ctx.ellipse(hatX, hatY, 14, 10, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Hat crown
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        ctx.ellipse(hatX - 1, hatY, 8, 6, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Hat band
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(hatX - 7, hatY - 1, 12, 2);
    }

    // Neck - connecting head to torso
    ctx.fillStyle = detectiveSkin;
    ctx.fillRect(detectiveX - 10*s, detectiveY - 8*s, 5*s, 4*s); // Neck piece

    // TORSO - lying flat, facing up (extended to connect with legs)
    ctx.fillStyle = '#1a1a4d'; // Dark blue detective suit jacket
    ctx.fillRect(detectiveX - 8*s, detectiveY - 14*s, 20*s, 14*s); // Extended torso to connect with legs

    // Suit jacket lapels and details
    ctx.fillStyle = '#14143d'; // Darker blue for shading
    ctx.fillRect(detectiveX + 8*s, detectiveY - 14*s, 4*s, 10*s); // Right lapel shadow
    ctx.fillRect(detectiveX - 8*s, detectiveY - 14*s, 4*s, 10*s); // Left lapel shadow

    // White shirt at collar
    ctx.fillStyle = '#e8e8e8';
    ctx.fillRect(detectiveX - 4*s, detectiveY - 12*s, 8*s, 3*s);

    // Burgundy tie
    ctx.fillStyle = '#8b1a1a';
    ctx.fillRect(detectiveX - 2*s, detectiveY - 11*s, 4*s, 10*s);

    // Six bullet holes in torso (2 rows of 3)
    for(let i = 0; i < 6; i++) {
        const row = Math.floor(i / 3);
        const col = i % 3;
        const holeX = detectiveX - 4*s + col * 4*s;
        const holeY = detectiveY - 10*s + row * 5*s;

        // Bullet hole
        ctx.fillStyle = '#660000';
        ctx.beginPath();
        ctx.arc(holeX, holeY, 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Darker center
        ctx.fillStyle = '#330000';
        ctx.beginPath();
        ctx.arc(holeX, holeY, 1, 0, Math.PI * 2);
        ctx.fill();
    }

    // Front/near leg (right leg, in front) - repositioned to connect with torso
    ctx.fillStyle = '#2a2a3d';
    ctx.fillRect(detectiveX + 6*s, detectiveY - 1*s, 16*s, 4*s); // Upper leg - connects to torso
    ctx.fillRect(detectiveX + 20*s, detectiveY - 2*s, 14*s, 4*s); // Lower leg

    // Front shoe
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(detectiveX + 33*s, detectiveY - 2*s, 5*s, 4*s);

    // Right arm RAISED holding note (extends upward from body)
    ctx.fillStyle = '#1a1a4d'; // Suit sleeve
    ctx.fillRect(detectiveX + 10*s, detectiveY - 16*s, 3*s, 8*s); // Upper arm vertical
    ctx.fillRect(detectiveX + 11*s, detectiveY - 24*s, 3*s, 10*s); // Forearm raised

    // Right hand holding note
    ctx.fillStyle = detectiveSkin;
    ctx.fillRect(detectiveX + 10*s, detectiveY - 26*s, 4*s, 4*s); // Hand

    // Yellow note in raised hand
    const noteX = detectiveX + 10*s;
    const noteY = detectiveY - 30*s;
    ctx.fillStyle = '#f4e5a8'; // Yellow legal pad color
    ctx.fillRect(noteX, noteY, 18, 24);

    // Note lines
    ctx.strokeStyle = '#c0c0c0';
    ctx.lineWidth = 0.5;
    for(let i = 0; i < 7; i++) {
        ctx.beginPath();
        ctx.moveTo(noteX + 2, noteY + 3 + i * 3);
        ctx.lineTo(noteX + 16, noteY + 3 + i * 3);
        ctx.stroke();
    }

    // Blood splatter on note
    ctx.fillStyle = '#660000';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(noteX + 12, noteY + 18, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Detective hat pickup prompt — hat becomes interactable after pistol is picked up
    if(level6.pistol.pickedUp && !level6.hasDetectiveHat) {
        // Highlight the fedora on ground
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(hatX, hatY, 16, 12, -0.1, 0, Math.PI * 2);
        ctx.stroke();
        // Prompt
        if(Math.abs(player.x - hatX) < 50 && Math.abs(player.y - hatY) < 60) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(hatX - 65, hatY - 30, 130, 20);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ACTION: TAKE HAT', hatX, hatY - 14);
        }
    }
    // Hide hat from detective body once picked up (already wearing it)
    // (The fedora drawing above is skipped implicitly since we don't modify it —
    //  but visually the hat on ground is the one the player takes)

    // Interaction prompt for note (when not viewing) - aligned with note center
    const noteInteractX = noteX + 9; // Center of note
    const noteInteractY = noteY + 12; // Center of note
    if(!level6.viewingDetectiveNote && Math.abs(player.x - noteInteractX) < 50 && Math.abs(player.y - noteInteractY) < 50) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ACTION - VIEW NOTE', noteInteractX, noteY - 20);

        // Arrow pointing to note
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(noteInteractX - 5, noteY - 8);
        ctx.lineTo(noteInteractX, noteY - 3);
        ctx.lineTo(noteInteractX + 5, noteY - 8);
        ctx.fill();
    }

    // Dropped pistol near detective
    if(level6.pistol.dropped) {
        const gx = level6.pistol.x, gy = level6.pistol.y;
        // Dark steel pistol body
        ctx.fillStyle = '#333';
        ctx.fillRect(gx - 12, gy - 3, 24, 6);
        ctx.fillStyle = '#222';
        ctx.fillRect(gx + 5, gy + 3, 8, 12);
        ctx.fillStyle = '#444';
        ctx.fillRect(gx - 14, gy - 4, 4, 8);
        // Glow indicator
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(gx, gy - 8, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        // Pickup prompt
        if(Math.abs(player.x - gx) < 50) {
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ACTION TO TAKE PISTOL', gx, gy - 18);
        }
    }

}

function drawLevel6EmployeeLobby() {
    // Dark industrial lobby — same aesthetic as Level 6 pipe room
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Floor tiles
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    // Bold brutalist PipeTech logo on wall — large painted style
    ctx.fillStyle = '#555';
    ctx.fillRect(80, 50, 360, 80);
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(84, 54, 352, 72);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 3;
    ctx.strokeRect(80, 50, 360, 80);
    ctx.fillStyle = '#ddd';
    ctx.font = 'bold 42px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 260, 100);
    ctx.fillStyle = '#888';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('GLOBAL LEADER IN PIPE DREAMS', 260, 122);
    // Rainbow pipe accent under logo
    const rainbowColors = ['#ff3333', '#33cc33', '#3388ff', '#ffcc00'];
    for (let rc = 0; rc < 4; rc++) {
        ctx.fillStyle = rainbowColors[rc];
        ctx.fillRect(130 + rc * 65, 128, 55, 4);
    }

    // CEO portrait above plants — ornate golden frame
    const pX = 260, pY = 150, pW = 100, pH = 110;
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(pX - pW/2 - 6, pY - 6, pW + 12, pH + 12);
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(pX - pW/2 - 4, pY - 4, pW + 8, pH + 8);
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(pX - pW/2 - 2, pY - 2, pW + 4, pH + 4);
    if(foundingFatherImg && foundingFatherImg.complete && foundingFatherImg.naturalWidth > 0) {
        ctx.drawImage(foundingFatherImg, pX - pW/2, pY, pW, pH);
    } else {
        ctx.fillStyle = '#2b2520';
        ctx.fillRect(pX - pW/2, pY, pW, pH);
    }
    // Text below portrait
    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 16px serif';
    ctx.textAlign = 'center';
    ctx.fillText('Meet your founding father.', 260, pY + pH + 22);

    // 4 colored fern-style potted plants next to elevator
    const plantColors = ['#ff3333', '#33cc33', '#3388ff', '#ffcc00'];
    const fernBaseX = 160;
    for (let pi = 0; pi < 4; pi++) {
        const px2 = fernBaseX + pi * 60;
        const py2 = 390;
        // Colored pot
        ctx.fillStyle = plantColors[pi];
        ctx.beginPath();
        ctx.moveTo(px2 - 14, py2 - 4);
        ctx.lineTo(px2 + 14, py2 - 4);
        ctx.lineTo(px2 + 10, py2 + 16);
        ctx.lineTo(px2 - 10, py2 + 16);
        ctx.closePath();
        ctx.fill();
        // Pot rim
        ctx.fillStyle = plantColors[pi];
        ctx.fillRect(px2 - 16, py2 - 8, 32, 5);
        // Darker shade for depth
        const darker = ['#cc2222', '#228822', '#2266cc', '#cc9900'];
        ctx.fillStyle = darker[pi];
        ctx.fillRect(px2 - 14, py2 - 4, 28, 3);

        // Fern fronds — multiple curving green shapes
        const fernGreen = '#1a7a2a';
        const fernLight = '#22aa33';
        ctx.strokeStyle = fernGreen;
        ctx.lineWidth = 2;
        // Center frond
        ctx.beginPath();
        ctx.moveTo(px2, py2 - 8);
        ctx.quadraticCurveTo(px2, py2 - 45, px2 + 3, py2 - 55);
        ctx.stroke();
        // Left fronds
        for (let f = 0; f < 3; f++) {
            ctx.strokeStyle = f % 2 === 0 ? fernGreen : fernLight;
            ctx.beginPath();
            ctx.moveTo(px2 - 2, py2 - 10 - f * 10);
            ctx.quadraticCurveTo(px2 - 18 - f * 4, py2 - 25 - f * 12, px2 - 22 - f * 5, py2 - 35 - f * 8);
            ctx.stroke();
            // Tiny leaf tips
            ctx.fillStyle = fernLight;
            ctx.beginPath();
            ctx.arc(px2 - 22 - f * 5, py2 - 35 - f * 8, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        // Right fronds
        for (let f = 0; f < 3; f++) {
            ctx.strokeStyle = f % 2 === 0 ? fernLight : fernGreen;
            ctx.beginPath();
            ctx.moveTo(px2 + 2, py2 - 10 - f * 10);
            ctx.quadraticCurveTo(px2 + 18 + f * 4, py2 - 25 - f * 12, px2 + 22 + f * 5, py2 - 35 - f * 8);
            ctx.stroke();
            ctx.fillStyle = fernGreen;
            ctx.beginPath();
            ctx.arc(px2 + 22 + f * 5, py2 - 35 - f * 8, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Elevator on right side — matching pipe room elevator style
    const elvX = 530, elvY = 240, elvW = 130, elvH = 160;
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(elvX - 6, elvY - 24, elvW + 12, elvH + 30);
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(elvX - 4, elvY - 22, elvW + 8, elvH + 26);
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(elvX - 2, elvY - 2, elvW + 4, elvH + 4);
    // Closed elevator doors
    const eGrad = ctx.createLinearGradient(elvX, 0, elvX + elvW, 0);
    eGrad.addColorStop(0, '#c0c0c0');
    eGrad.addColorStop(0.5, '#e0e0e0');
    eGrad.addColorStop(1, '#c0c0c0');
    ctx.fillStyle = eGrad;
    ctx.fillRect(elvX, elvY, elvW, elvH);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(elvX + elvW/2, elvY + 4);
    ctx.lineTo(elvX + elvW/2, elvY + elvH - 4);
    ctx.stroke();
    // LED indicator
    ctx.fillStyle = '#222';
    ctx.fillRect(elvX + elvW/2 - 20, elvY - 18, 40, 14);
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('EMP', elvX + elvW/2, elvY - 8);
    // Frame
    ctx.strokeStyle = '#8a7a2a';
    ctx.lineWidth = 2;
    ctx.strokeRect(elvX - 2, elvY - 2, elvW + 4, elvH + 4);

    // Direction prompts
    if(player.x > 560) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(elvX + elvW/2 - 80, elvY - 42, 160, 20);
        ctx.fillStyle = '#ffd700';
        ctx.fillText('ACTION: ELEVATOR', elvX + elvW/2, elvY - 26);
    }
    if(player.x < 80) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(40 - 70, 360, 140, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText('← CLONING LAB', 40, 376);
    }
}

function drawLevel6CloningRoom() {
    const t = Date.now();
    // Dark industrial room
    ctx.fillStyle = '#222';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Industrial floor
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    // === LEFT WALL GASKET (BEHIND pipes — design rule) ===
    const gasketY = 35;
    const gasketX = 17;
    ctx.fillStyle = '#999';
    ctx.beginPath();
    ctx.arc(gasketX, gasketY, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(gasketX, gasketY, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(gasketX, gasketY, 8, 0, Math.PI * 2);
    ctx.fill();
    for(let b = 0; b < 6; b++) {
        const angle = (b / 6) * Math.PI * 2;
        const bx = gasketX + Math.cos(angle) * 12;
        const by = gasketY + Math.sin(angle) * 12;
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(bx, by, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // === 4 STEEL VATS with colored ooze and floating fetal PMs ===
    const vatColors = ['#ff3333', '#33cc33', '#3388ff', '#ffcc00'];
    const vatDarkColors = ['#990000', '#006600', '#003388', '#996600'];
    const vatX0 = 160;
    for (let vi = 0; vi < 4; vi++) {
        const vx = vatX0 + vi * 95;
        const vy = 80, vw = 50, vh = 140;

        // Steel vat body
        const vatGrad = ctx.createLinearGradient(vx, 0, vx + vw, 0);
        vatGrad.addColorStop(0, '#555');
        vatGrad.addColorStop(0.3, '#888');
        vatGrad.addColorStop(0.5, '#999');
        vatGrad.addColorStop(0.7, '#888');
        vatGrad.addColorStop(1, '#555');
        ctx.fillStyle = vatGrad;
        ctx.fillRect(vx, vy, vw, vh);

        // Steel rim top & bottom
        ctx.fillStyle = '#aaa';
        ctx.fillRect(vx - 3, vy - 4, vw + 6, 8);
        ctx.fillRect(vx - 3, vy + vh - 4, vw + 6, 8);
        ctx.fillStyle = '#777';
        ctx.fillRect(vx - 2, vy - 2, vw + 4, 4);
        ctx.fillRect(vx - 2, vy + vh - 2, vw + 4, 4);

        // Clear window panel
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(vx + 8, vy + 20, vw - 16, vh - 40);
        // Colored genetic ooze
        const oozeAlpha = 0.5 + Math.sin(t / 1000 + vi * 1.5) * 0.15;
        ctx.fillStyle = vatColors[vi];
        ctx.globalAlpha = oozeAlpha;
        ctx.fillRect(vx + 9, vy + 22, vw - 18, vh - 44);
        ctx.globalAlpha = 1;

        // Floating fetal PM silhouette — bobbing animation
        const fetalY = vy + 55 + Math.sin(t / 800 + vi * 2) * 12;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        // Head
        ctx.beginPath();
        ctx.arc(vx + vw/2, fetalY, 7, 0, Math.PI * 2);
        ctx.fill();
        // Curled body
        ctx.beginPath();
        ctx.arc(vx + vw/2, fetalY + 12, 9, 0, Math.PI);
        ctx.fill();
        // Tiny arm buds
        ctx.fillRect(vx + vw/2 - 12, fetalY + 6, 5, 3);
        ctx.fillRect(vx + vw/2 + 7, fetalY + 6, 5, 3);

        // Bubbles
        for (let b = 0; b < 3; b++) {
            const bx = vx + 14 + (b * 10) + Math.sin(t / 500 + vi + b) * 3;
            const by = vy + 30 + ((t / 15 + b * 40 + vi * 20) % (vh - 50));
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(bx, by, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // === PIPE from vat going UP then LEFT to merge ===
        ctx.strokeStyle = vatColors[vi];
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        // Vertical from vat top upward
        ctx.moveTo(vx + vw/2, vy - 4);
        ctx.lineTo(vx + vw/2, 50);
        // Curve left
        ctx.quadraticCurveTo(vx + vw/2, 35, vx + vw/2 - 20, 35);
        // Horizontal to left wall gasket center
        ctx.lineTo(gasketX, 35);
        ctx.stroke();
        // Highlight
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(vx + vw/2, vy - 2);
        ctx.lineTo(vx + vw/2, 50);
        ctx.quadraticCurveTo(vx + vw/2, 37, vx + vw/2 - 20, 37);
        ctx.lineTo(gasketX, 37);
        ctx.stroke();

        // === ALUMINUM DRYER VENT TUBE from vat to centrifuge ===
        const centX = 350, centY = 310;
        const tubeEndX = centX - 60 + vi * 30;
        const tubeEndY = centY - 20;
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 8;
        ctx.setLineDash([6, 3]); // Corrugated vent look
        ctx.beginPath();
        ctx.moveTo(vx + vw/2, vy + vh);
        ctx.quadraticCurveTo(vx + vw/2, tubeEndY + 30, tubeEndX, tubeEndY);
        ctx.stroke();
        ctx.setLineDash([]);
        // Tube shadow
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(vx + vw/2 + 3, vy + vh);
        ctx.quadraticCurveTo(vx + vw/2 + 3, tubeEndY + 32, tubeEndX + 2, tubeEndY + 2);
        ctx.stroke();
    }

    // === ROTATING CENTRIFUGE (PM Printer core) ===
    const centX = 350, centY = 330, centR = 55;
    const rotation = (t / 2000) % (Math.PI * 2);

    // Centrifuge housing — large steel drum
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(centX, centY, centR + 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(centX, centY, centR + 10, 0, Math.PI * 2);
    ctx.stroke();
    // Inner drum
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(centX, centY, centR, 0, Math.PI * 2);
    ctx.fill();

    // Heat lamp glow in center
    const lampGlow = 0.4 + Math.sin(t / 300) * 0.15;
    ctx.fillStyle = `rgba(255, 120, 30, ${lampGlow})`;
    ctx.beginPath();
    ctx.arc(centX, centY, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ff8844';
    ctx.shadowColor = '#ff6600';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(centX, centY, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Easter egg pod capsules — 4 rotating around center
    for (let ei = 0; ei < 4; ei++) {
        const eggAngle = rotation + (ei / 4) * Math.PI * 2;
        const eggX = centX + Math.cos(eggAngle) * (centR - 18);
        const eggY = centY + Math.sin(eggAngle) * (centR - 18);

        // Egg capsule — oval with color tint
        ctx.fillStyle = vatColors[ei];
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(eggX, eggY, 12, 16, eggAngle, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Shiny highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.ellipse(eggX - 3, eggY - 4, 4, 6, eggAngle, 0, Math.PI * 2);
        ctx.fill();
        // PM silhouette visible through egg
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.arc(eggX, eggY - 3, 4, 0, Math.PI * 2); // head
        ctx.fill();
        ctx.fillRect(eggX - 3, eggY + 1, 6, 8); // body
    }

    // Centrifuge steel bolts around rim
    for (let bi = 0; bi < 8; bi++) {
        const ba = (bi / 8) * Math.PI * 2;
        const bx = centX + Math.cos(ba) * (centR + 5);
        const by = centY + Math.sin(ba) * (centR + 5);
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(bx, by, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // === PM PRINTER LABEL (mounted on wall above pipes) ===
    ctx.fillStyle = '#444';
    ctx.fillRect(275, -8, 150, 26);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.strokeRect(275, -8, 150, 26);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PM PRINTER', 350, 12);

    // === CONCEALED DOOR — left wall sliding brick panel ===
    const cdX = 0, cdY = 280, cdW = 60, cdH = 120;
    const slideOffset = level6.cloningDoorOpen * cdW; // slides right to reveal

    if (level6.cloningDoorOpen < 1) {
        // Brick wall section that slides — matches dark room wall
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(cdX + slideOffset, cdY, cdW - slideOffset, cdH);
        // Brick pattern (subtle, matching wall tone)
        for (let row = 0; row < 6; row++) {
            for (let col = 0; col < 3; col++) {
                const brickX = cdX + slideOffset + col * 22 + (row % 2) * 11;
                const brickY = cdY + row * 20;
                if (brickX < cdX + cdW) {
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(brickX, brickY, 20, 18);
                }
            }
        }
        // OSHA safety compliance poster on brick wall (slides with door)
        const posterX = cdX + slideOffset + 5;
        const posterY = cdY + 15;
        const posterW = 42;
        const posterH = 54;
        ctx.save();
        ctx.beginPath();
        ctx.rect(cdX + slideOffset, cdY, cdW - slideOffset, cdH);
        ctx.clip();
        if(oshaPosterImg && oshaPosterImg.complete && oshaPosterImg.naturalWidth > 0) {
            // White border frame
            ctx.fillStyle = '#ddd';
            ctx.fillRect(posterX - 2, posterY - 2, posterW + 4, posterH + 4);
            ctx.drawImage(oshaPosterImg, posterX, posterY, posterW, posterH);
        } else {
            // Fallback: simple OSHA poster
            ctx.fillStyle = '#fff';
            ctx.fillRect(posterX, posterY, posterW, posterH);
            ctx.fillStyle = '#cc0000';
            ctx.font = 'bold 7px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LAB SAFETY', posterX + posterW/2, posterY + 20);
            ctx.fillText('FIRST', posterX + posterW/2, posterY + 30);
        }
        // Tack pins
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        ctx.arc(posterX + 4, posterY + 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(posterX + posterW - 4, posterY + 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    if (level6.cloningDoorOpen > 0.1) {
        // Dark passage revealed behind
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(cdX, cdY, slideOffset, cdH);
        // Green LED strips inside passage
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 6;
        ctx.fillRect(cdX, cdY, 2, cdH);
        ctx.shadowBlur = 0;
    }

    // Door outline visible even when closed
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 2;
    ctx.strokeRect(cdX, cdY, cdW, cdH);

    // Keycard reader beside concealed door
    if (!level6.cloningDoorUnlocked) {
        const krX = cdW + 8, krY = cdY + 40;
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(krX, krY, 18, 30);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(krX + 2, krY + 2, 14, 26);
        // Card slot
        ctx.fillStyle = '#333';
        ctx.fillRect(krX + 4, krY + 8, 10, 3);
        // LED — red when locked
        ctx.fillStyle = '#ff3333';
        ctx.shadowColor = '#ff3333';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(krX + 9, krY + 20, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        if (player.x < 80 && level6.hasKeycard) {
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(50 - 65, cdY + cdH + 8, 130, 18);
            ctx.fillStyle = '#00ccff';
            ctx.fillText('ACTION: USE KEYCARD', 50, cdY + cdH + 22);
        } else if (player.x < 80 && !level6.hasKeycard) {
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(50 - 65, cdY + cdH + 8, 130, 18);
            ctx.fillStyle = '#ff6666';
            ctx.fillText('KEYCARD REQUIRED', 50, cdY + cdH + 22);
        }
    } else {
        // Unlocked reader — green
        const krX = cdW + 8 + level6.cloningDoorOpen * cdW, krY = cdY + 40;
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(krX, krY, 18, 30);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(krX + 2, krY + 2, 14, 26);
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(krX + 9, krY + 20, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // === CLONING BOSS — Lab Supervisor patrolling in front of centrifuge ===
    const cb = level6.cloningBoss;
    if (cb.alive) {
        const bx = cb.x, by = cb.y;
        const walkCycle = cb.paused ? 0 : Math.sin(Date.now() / 150) * 5;
        const bob = cb.paused ? 0 : Math.abs(Math.sin(Date.now() / 150)) * 1.5;

        // White hard hat (taller, wider — supervisor style)
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(bx - 16, by - 64 - bob, 32, 10);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(bx - 18, by - 56 - bob, 36, 5);
        // Hat brim shadow
        ctx.fillStyle = '#ccc';
        ctx.fillRect(bx - 17, by - 52 - bob, 34, 2);

        // Head
        ctx.fillStyle = '#f5d5a8';
        ctx.fillRect(bx - 11, by - 50 - bob, 22, 22);
        // Eyes — stern expression
        ctx.fillStyle = '#000';
        ctx.fillRect(bx - 7, by - 44 - bob, 4, 4);
        ctx.fillRect(bx + 3, by - 44 - bob, 4, 4);
        // Angry eyebrows
        ctx.strokeStyle = '#4a3520';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx - 8, by - 48 - bob); ctx.lineTo(bx - 3, by - 46 - bob);
        ctx.moveTo(bx + 8, by - 48 - bob); ctx.lineTo(bx + 3, by - 46 - bob);
        ctx.stroke();
        // Mouth — frown
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(bx, by - 34 - bob, 4, 0.2, Math.PI - 0.2);
        ctx.stroke();

        // White lab coat (open, extends past hips)
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(bx - 16, by - 28 - bob, 32, 36);
        // Coat lapels
        ctx.fillStyle = '#e8e8e8';
        ctx.beginPath();
        ctx.moveTo(bx - 16, by - 28 - bob);
        ctx.lineTo(bx - 4, by - 18 - bob);
        ctx.lineTo(bx - 16, by - 18 - bob);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(bx + 16, by - 28 - bob);
        ctx.lineTo(bx + 4, by - 18 - bob);
        ctx.lineTo(bx + 16, by - 18 - bob);
        ctx.closePath();
        ctx.fill();
        // Red shirt underneath (visible between lapels)
        ctx.fillStyle = '#cc2222';
        ctx.fillRect(bx - 6, by - 28 - bob, 12, 28);
        // Black tie
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(bx - 3, by - 28 - bob);
        ctx.lineTo(bx + 3, by - 28 - bob);
        ctx.lineTo(bx + 2, by - 6 - bob);
        ctx.lineTo(bx, by - 2 - bob);
        ctx.lineTo(bx - 2, by - 6 - bob);
        ctx.closePath();
        ctx.fill();
        // Coat pocket with pen
        ctx.fillStyle = '#ddd';
        ctx.fillRect(bx + 6, by - 16 - bob, 8, 10);
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx + 6, by - 16 - bob, 8, 10);
        ctx.fillStyle = '#2244cc';
        ctx.fillRect(bx + 9, by - 20 - bob, 2, 8);

        // Arms — animated swing when walking
        const armSwing = walkCycle * 0.6;
        // Left arm
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(bx - 20, by - 26 - bob + armSwing, 6, 22);
        ctx.fillStyle = '#f5d5a8';
        ctx.fillRect(bx - 20, by - 6 - bob + armSwing, 6, 6);
        // Right arm + clipboard
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(bx + 14, by - 26 - bob - armSwing, 6, 22);
        ctx.fillStyle = '#f5d5a8';
        ctx.fillRect(bx + 14, by - 6 - bob - armSwing, 6, 6);
        // Clipboard in right hand
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(bx + (cb.facing === 'right' ? 18 : -24), by - 10 - bob - armSwing, 10, 16);
        ctx.fillStyle = '#fff';
        ctx.fillRect(bx + (cb.facing === 'right' ? 19 : -23), by - 8 - bob - armSwing, 8, 12);

        // Dark pants
        ctx.fillStyle = '#2a2a2a';
        const legOffset = walkCycle;
        ctx.fillRect(bx - 10, by + 8 - bob, 9, 18 + legOffset);
        ctx.fillRect(bx + 1, by + 8 - bob, 9, 18 - legOffset);
        // Black steel-toe boots
        ctx.fillStyle = '#111';
        ctx.fillRect(bx - 12, by + 26 - bob + legOffset, 12, 5);
        ctx.fillRect(bx, by + 26 - bob - legOffset, 12, 5);
        // Boot steel toe caps
        ctx.fillStyle = '#444';
        ctx.fillRect(bx - 12, by + 26 - bob + legOffset, 4, 3);
        ctx.fillRect(bx + 8, by + 26 - bob - legOffset, 4, 3);

    } else if (cb.deathTime > 0) {
        // Dead boss — collapsed on ground (larger, lab coat visible)
        const bx = cb.x, by = 392;
        // Body on ground
        ctx.fillStyle = '#f5f5f5'; // lab coat
        ctx.fillRect(bx - 18, by - 2, 36, 8);
        // Head
        ctx.fillStyle = '#f5d5a8';
        ctx.fillRect(bx - 10, by - 8, 16, 10);
        // Hard hat knocked off
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(bx + 16, by - 4, 14, 6);
        // X eyes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(bx - 6, by - 6); ctx.lineTo(bx - 2, by - 2);
        ctx.moveTo(bx - 2, by - 6); ctx.lineTo(bx - 6, by - 2);
        ctx.moveTo(bx + 2, by - 6); ctx.lineTo(bx + 6, by - 2);
        ctx.moveTo(bx + 6, by - 6); ctx.lineTo(bx + 2, by - 2);
        ctx.stroke();
        // Red shirt visible
        ctx.fillStyle = '#cc2222';
        ctx.fillRect(bx - 6, by, 12, 4);
        // Black tie askew
        ctx.fillStyle = '#111';
        ctx.fillRect(bx - 1, by - 1, 3, 6);
    }

    // === DROPPED KEYCARD ===
    if (level6.keycardOnGround) {
        const kx = level6.keycardX, ky = level6.keycardY;
        // Card body
        ctx.fillStyle = '#ddd';
        ctx.fillRect(kx - 12, ky - 4, 24, 14);
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.strokeRect(kx - 12, ky - 4, 24, 14);
        // Magnetic stripe
        ctx.fillStyle = '#333';
        ctx.fillRect(kx - 10, ky + 4, 20, 3);
        // Blinking glow
        const cardGlow = Math.sin(t / 300) > 0;
        if (cardGlow) {
            ctx.fillStyle = '#00ccff';
            ctx.shadowColor = '#00ccff';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(kx, ky - 8, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        if (Math.abs(player.x - kx) < 50) {
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(kx - 65, ky - 24, 130, 18);
            ctx.fillStyle = '#00ccff';
            ctx.fillText('ACTION: TAKE KEYCARD', kx, ky - 10);
        }
    }

    // Direction prompts
    if (player.x > 620) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(660 - 55, 360, 110, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText('LOBBY →', 660, 376);
    }
}

// === Level 6 Furnace Room — dark industrial furnace with evidence of CEO's escape ===
function drawL6FurnaceRoom() {
    // Dark industrial walls
    ctx.fillStyle = '#2b2520';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Dark floor tiles
    ctx.fillStyle = '#1a1815';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#0a0a08';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    // === FURNACE (center-right, prominent) ===
    const fx = 420, fy = 340;
    // Radial heat glow
    const glowPhase = Math.sin(Date.now() / 800) * 0.3 + 0.7;
    const gradient = ctx.createRadialGradient(fx, fy, 20, fx, fy, 140);
    gradient.addColorStop(0, `rgba(255,100,0,${glowPhase * 0.5})`);
    gradient.addColorStop(0.5, `rgba(255,50,0,${glowPhase * 0.2})`);
    gradient.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(fx, fy, 140, 0, Math.PI * 2);
    ctx.fill();

    // Furnace body (industrial steel)
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(fx - 65, fy - 45, 130, 90);
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(fx - 55, fy - 35, 110, 70);
    // Fire window
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(fx - 42, fy - 22, 84, 44);
    // Perpetual glow inside
    ctx.fillStyle = `rgba(255,100,0,${glowPhase})`;
    ctx.fillRect(fx - 38, fy - 18, 76, 36);
    // Flickering flames
    for(let i = 0; i < 6; i++) {
        const flameX = fx - 30 + i * 12;
        const flameH = 20 + Math.sin(Date.now() / 150 + i * 1.3) * 10;
        const flameY = fy + 10 - flameH;
        ctx.fillStyle = `rgba(255,${150 + i * 15},0,0.8)`;
        ctx.fillRect(flameX, flameY, 6, flameH);
    }
    // Chimney/exhaust pipe going up
    ctx.fillStyle = '#444';
    ctx.fillRect(fx - 12, fy - 130, 24, 90);
    ctx.fillStyle = '#555';
    ctx.fillRect(fx - 15, fy - 135, 30, 10);
    // Heat shimmer from chimney
    ctx.fillStyle = `rgba(255,80,0,${0.15 + Math.sin(Date.now() / 400) * 0.1})`;
    ctx.fillRect(fx - 8, fy - 180, 16, 50);
    // Steel rivets on furnace
    for(let r = 0; r < 4; r++) {
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(fx - 55 + r * 38, fy - 40, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(fx - 55 + r * 38, fy + 40, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    // FURNACE label
    ctx.fillStyle = '#cc8844';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('INCINERATOR', fx, fy + 55);

    // === DISCARDED RED JUMPSUIT on floor in front of furnace ===
    const jsX = fx - 30, jsY = 388;
    // Crumpled jumpsuit body — irregularly shaped heap
    ctx.fillStyle = '#cc2222';
    // Main body mass
    ctx.beginPath();
    ctx.moveTo(jsX, jsY);
    ctx.lineTo(jsX + 35, jsY - 4);
    ctx.lineTo(jsX + 40, jsY + 8);
    ctx.lineTo(jsX + 32, jsY + 16);
    ctx.lineTo(jsX + 10, jsY + 18);
    ctx.lineTo(jsX - 5, jsY + 12);
    ctx.closePath();
    ctx.fill();
    // Darker fold shadows
    ctx.fillStyle = '#991a1a';
    ctx.beginPath();
    ctx.moveTo(jsX + 8, jsY + 2);
    ctx.lineTo(jsX + 22, jsY);
    ctx.lineTo(jsX + 25, jsY + 10);
    ctx.lineTo(jsX + 12, jsY + 12);
    ctx.closePath();
    ctx.fill();
    // Sleeve hanging out
    ctx.fillStyle = '#cc2222';
    ctx.fillRect(jsX + 36, jsY + 2, 14, 6);
    ctx.fillStyle = '#991a1a';
    ctx.fillRect(jsX + 36, jsY + 4, 14, 2);
    // Collar detail
    ctx.fillStyle = '#e63333';
    ctx.fillRect(jsX + 10, jsY - 4, 12, 5);
    // PipeTech logo patch (small white square on shoulder area)
    ctx.fillStyle = '#ddd';
    ctx.fillRect(jsX + 28, jsY, 6, 5);
    ctx.fillStyle = '#cc2222';
    ctx.font = '3px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PT', jsX + 31, jsY + 4);

    // === BLOODY WHITE BOOTS next to jumpsuit ===
    const bx1 = fx + 18, by1 = 392;
    // Left boot
    ctx.fillStyle = '#e8e8e8';
    ctx.fillRect(bx1, by1, 10, 14);
    ctx.fillRect(bx1 - 3, by1 + 10, 16, 5);
    // Boot sole
    ctx.fillStyle = '#333';
    ctx.fillRect(bx1 - 3, by1 + 14, 16, 2);
    // Blood stains on left boot
    ctx.fillStyle = '#8b0000';
    ctx.fillRect(bx1, by1 + 6, 6, 4);
    ctx.fillStyle = '#6a0000';
    ctx.beginPath();
    ctx.arc(bx1 + 2, by1 + 12, 3, 0, Math.PI * 2);
    ctx.fill();
    // Right boot (fallen sideways)
    const bx2 = bx1 + 18, by2 = 394;
    ctx.fillStyle = '#e8e8e8';
    ctx.fillRect(bx2, by2, 14, 8);
    ctx.fillRect(bx2 + 10, by2 - 3, 5, 14);
    // Boot sole (visible, sideways)
    ctx.fillStyle = '#333';
    ctx.fillRect(bx2, by2 + 7, 14, 2);
    // Blood stains on right boot
    ctx.fillStyle = '#8b0000';
    ctx.fillRect(bx2 + 2, by2 + 2, 8, 3);
    ctx.fillStyle = '#6a0000';
    ctx.beginPath();
    ctx.arc(bx2 + 8, by2 + 5, 2, 0, Math.PI * 2);
    ctx.fill();

    // === BLOODY FOOTPRINTS leading from boots toward secret door (left wall) ===
    const fpSteps = [
        {x: fx + 5, y: 400, rot: -0.3, size: 1},
        {x: fx - 30, y: 398, rot: -0.2, size: 0.95},
        {x: fx - 70, y: 400, rot: -0.15, size: 0.9},
        {x: fx - 115, y: 397, rot: -0.1, size: 0.85},
        {x: fx - 160, y: 399, rot: -0.1, size: 0.8},
        {x: fx - 205, y: 398, rot: -0.05, size: 0.75},
        {x: fx - 245, y: 400, rot: 0, size: 0.7},
        {x: fx - 280, y: 397, rot: 0, size: 0.65},
        {x: fx - 310, y: 399, rot: 0, size: 0.55},
        {x: fx - 340, y: 398, rot: 0, size: 0.45},
    ];
    for(let fp of fpSteps) {
        ctx.save();
        ctx.translate(fp.x, fp.y);
        ctx.rotate(fp.rot);
        ctx.globalAlpha = 0.3 + fp.size * 0.5;
        // Barefoot print — heel + ball + toes
        ctx.fillStyle = '#6a0000';
        const s = fp.size;
        // Heel
        ctx.beginPath();
        ctx.ellipse(0, 6 * s, 4 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        // Ball of foot
        ctx.beginPath();
        ctx.ellipse(0, -4 * s, 5 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        // Toes (5 small dots)
        for(let t = 0; t < 5; t++) {
            const tx = -4 * s + t * 2 * s;
            const ty = -9 * s + Math.abs(t - 2) * 0.5 * s;
            ctx.beginPath();
            ctx.arc(tx, ty, 1.2 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    // === SECRET DOOR (left wall) — concealed panel the CEO escaped through ===
    const sdX = 10, sdY = 300, sdW = 45, sdH = 100;
    // Door outline barely visible — hairline crack in wall
    ctx.strokeStyle = '#3a3530';
    ctx.lineWidth = 1;
    ctx.strokeRect(sdX, sdY, sdW, sdH);
    // Subtle handle scratch marks
    ctx.strokeStyle = '#4a4540';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(sdX + sdW - 5, sdY + 40);
    ctx.lineTo(sdX + sdW - 5, sdY + 60);
    ctx.stroke();
    // Bloody handprint on wall near secret door
    ctx.fillStyle = 'rgba(106,0,0,0.4)';
    ctx.fillRect(sdX + sdW + 5, sdY + 30, 14, 18);
    // Finger smears
    for(let f = 0; f < 4; f++) {
        ctx.fillRect(sdX + sdW + 7 + f * 3, sdY + 20, 2, 12);
    }
    // Fading bloody footprints disappear into door crack
    ctx.fillStyle = 'rgba(106,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(sdX + sdW/2, sdY + sdH - 8, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(106,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(sdX + sdW/2 - 6, sdY + sdH - 3, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // === STILL-BURNING CIGAR next to secret wall door ===
    const cigX = sdX + sdW + 25, cigY = sdY + sdH - 15;
    // Cigar body — brown cylinder
    ctx.fillStyle = '#8B6914';
    ctx.fillRect(cigX, cigY, 18, 5);
    // Cigar band — gold ring
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(cigX + 4, cigY, 4, 5);
    // Ash tip — gray
    ctx.fillStyle = '#aaa';
    ctx.fillRect(cigX - 3, cigY + 1, 4, 3);
    // Burning ember at tip
    const emberGlow = 0.6 + Math.sin(Date.now() / 300) * 0.4;
    ctx.fillStyle = `rgba(255,100,0,${emberGlow})`;
    ctx.beginPath();
    ctx.arc(cigX - 2, cigY + 2.5, 2.5, 0, Math.PI * 2);
    ctx.fill();
    // Smoke wisps rising from cigar
    for(let sw = 0; sw < 3; sw++) {
        const smokeY = cigY - 8 - sw * 12;
        const smokeX = cigX - 2 + Math.sin(Date.now() / 600 + sw * 1.5) * 6;
        const smokeAlpha = 0.25 - sw * 0.07;
        ctx.fillStyle = `rgba(180,180,180,${smokeAlpha})`;
        ctx.beginPath();
        ctx.arc(smokeX, smokeY, 3 + sw * 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Left door — wooden door to hallway (same style as Level 5)
    const ldX = 55, ldY = 340, ldW = 50, ldH = 60;
    ctx.fillStyle = '#654321';
    ctx.fillRect(ldX - 10, ldY, ldW, ldH);
    ctx.fillStyle = '#4a3a1a';
    ctx.fillRect(ldX - 5, ldY + 5, ldW - 10, ldH - 10);
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(ldX + 30, ldY + 30, 3, 0, Math.PI * 2);
    ctx.fill();
    // Highlight when near
    if(player.x < 100) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(ldX - 12, ldY - 2, ldW + 4, ldH + 4);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('\u2190 HALLWAY', ldX + 15, ldY - 10);
    }

    // === OPEN WALL DOOR on right side (passage back to cloning room) ===
    const rdX = 655, rdY = 300, rdW = 45, rdH = 100;
    // Dark interior of open doorway
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(rdX, rdY, rdW, rdH);
    // Door frame — concrete edges
    ctx.fillStyle = '#3a3530';
    ctx.fillRect(rdX - 3, rdY - 3, 3, rdH + 6);
    ctx.fillRect(rdX, rdY - 3, rdW, 3);
    ctx.fillRect(rdX, rdY + rdH, rdW, 3);
    // Green LED strip on doorframe edge
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(rdX - 2, rdY, 1, rdH);
    // Dim light spilling from doorway
    ctx.fillStyle = 'rgba(0,255,136,0.05)';
    ctx.fillRect(rdX - 20, rdY, 20, rdH);

    // Right exit direction prompt (back to cloning room)
    if(player.x > 600) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(660 - 55, 350, 110, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText('CLONING \u2192', 660, 366);
    }

    // Ambient label
    if(player.x > 200 && player.x < 500) {
        ctx.fillStyle = 'rgba(255,200,150,0.5)';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Someone discarded their uniform here...', 350, 280);
    }
}

function drawLevel6Entryway() {
    ctx.fillStyle = '#8b0000';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    ctx.fillStyle = '#660000';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);

    for(let i = -4; i < 24; i++) {
        ctx.strokeStyle = '#550000';
        ctx.lineWidth = 1;
        ctx.strokeRect(i * 35, 400, 35, 100);
    }
    
    // Giant double doors
    ctx.fillStyle = '#4a2a0a';
    ctx.fillRect(250, 150, 200, 250);
    
    ctx.fillStyle = '#3a1a00';
    ctx.fillRect(255, 155, 90, 240);
    ctx.fillRect(355, 155, 90, 240);
    
    // Door panels
    for(let i = 0; i < 2; i++) {
        const doorX = 255 + i * 100;
        ctx.strokeStyle = '#2a1000';
        ctx.lineWidth = 3;
        ctx.strokeRect(doorX + 10, 165, 70, 100);
        ctx.strokeRect(doorX + 10, 275, 70, 110);
    }
    
    // Gold handles
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(330, 300, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(370, 300, 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Golden placard — wide enough for full name
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(230, 120, 240, 25);
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(235, 123, 230, 19);

    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ALDON PIPERSWORTH', 350, 137);
    
    // Functional elevator on right (return elevator)
    const eelvX = 590, eelvY = 260, eelvW = 90, eelvH = 140;
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(eelvX - 2, eelvY - 2, eelvW + 4, eelvH + 4);
    // Closed elevator doors
    const eGrad = ctx.createLinearGradient(eelvX, 0, eelvX + eelvW, 0);
    eGrad.addColorStop(0, '#c0c0c0');
    eGrad.addColorStop(0.5, '#e0e0e0');
    eGrad.addColorStop(1, '#c0c0c0');
    ctx.fillStyle = eGrad;
    ctx.fillRect(eelvX, eelvY, eelvW, eelvH);
    ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(eelvX + eelvW/2, eelvY+4); ctx.lineTo(eelvX + eelvW/2, eelvY+eelvH-4); ctx.stroke();
    // Engraved letters
    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 14px serif';
    ctx.textAlign = 'center';
    ctx.fillText('PI', eelvX + eelvW/4, eelvY + eelvH/2 + 5);
    ctx.fillText('PE', eelvX + 3*eelvW/4, eelvY + eelvH/2 + 5);
    // Frame
    ctx.strokeStyle = '#8a7a2a'; ctx.lineWidth = 2;
    ctx.strokeRect(eelvX - 2, eelvY - 2, eelvW + 4, eelvH + 4);
    // LED indicator
    ctx.fillStyle = '#222';
    ctx.fillRect(eelvX + 12, eelvY - 16, 30, 12);
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 9px monospace';
    ctx.fillText('CEO', eelvX + 27, eelvY - 7);

    if(Math.abs(player.x - 350) < 100 && player.y > 360) {
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(350 - 115, 420 - 14, 230, 22);
        ctx.fillStyle = '#ffd700';
        ctx.fillText('PRESS ACTION TO ENTER', 350, 420);
    }
    if(player.x > 560) {
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(eelvX + eelvW/2 - 80, eelvY - 40, 160, 20);
        ctx.fillStyle = '#ffd700';
        ctx.fillText('ACTION: ELEVATOR', eelvX + eelvW/2, eelvY - 24);
    }
}

function drawLevel6CEOOffice() {
    // Black void background
    ctx.fillStyle = '#000';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    
    // Room floor - circular rug
    const rugCenterX = 350;
    const rugCenterY = 350;
    
    ctx.fillStyle = '#2b1810';
    ctx.beginPath();
    ctx.ellipse(rugCenterX, rugCenterY, 300, 140, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#3a2416';
    ctx.beginPath();
    ctx.ellipse(rugCenterX, rugCenterY, 280, 120, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Earth rug pattern with pipe rings
    const earthX = 350;
    const earthY = 380;
    
    // Pipes as rings around earth
    for(let i = 0; i < 4; i++) {
        const radius = 50 + i * 12;
        ctx.strokeStyle = COLORS[i].hex;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.ellipse(earthX, earthY, radius, radius * 0.3, 0, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Earth
    ctx.fillStyle = '#4a9eff';
    ctx.beginPath();
    ctx.arc(earthX, earthY, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#27ae60';
    ctx.beginPath();
    ctx.arc(earthX - 10, earthY - 5, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(earthX + 12, earthY + 8, 12, 0, Math.PI * 2);
    ctx.fill();
    
    // Saturn-Pipe-Earth portrait on back wall (pushed against back wall)
    const portraitX = 350;
    const portraitY = 0;

    // Use image's actual aspect ratio, no frame needed (frame already in image)
    let portraitWidth = 120;
    let portraitHeight = 90;
    if(ceoPortraitImg.complete && ceoPortraitImg.naturalWidth > 0) {
        const imgAspect = ceoPortraitImg.naturalWidth / ceoPortraitImg.naturalHeight;
        portraitWidth = 120;
        portraitHeight = portraitWidth / imgAspect;
    }

    // Draw photorealistic portrait (no frame - image has frame built in)
    if(ceoPortraitImg.complete && ceoPortraitImg.naturalWidth > 0) {
        ctx.drawImage(ceoPortraitImg, portraitX - portraitWidth/2, portraitY, portraitWidth, portraitHeight);
    } else {
        // Fallback while image loads
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(portraitX - portraitWidth/2, portraitY, portraitWidth, portraitHeight);
    }

    // Mahogany executive desk - proper 3D isometric view
    const deskX = 350;
    const deskY = 250; // Lower position for better visibility

    // Large shadow beneath entire desk (grounding it on floor)
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.ellipse(deskX, deskY + 50, 110, 30, 0, 0, Math.PI * 2);
    ctx.fill();

    // Desk legs - four sturdy 3D legs with proper depth
    const legWidth = 6;
    const legDepth = 4;
    const legHeight = 45;
    const legs = [
        {x: deskX - 75, y: deskY - 15}, // Back left
        {x: deskX + 75, y: deskY - 15}, // Back right
        {x: deskX - 75, y: deskY + 5},  // Front left
        {x: deskX + 75, y: deskY + 5}   // Front right
    ];

    legs.forEach((leg) => {
        // Leg left side (darker)
        ctx.fillStyle = '#3a1a00';
        ctx.beginPath();
        ctx.moveTo(leg.x - legDepth, leg.y);
        ctx.lineTo(leg.x, leg.y - 2);
        ctx.lineTo(leg.x, leg.y + legHeight - 2);
        ctx.lineTo(leg.x - legDepth, leg.y + legHeight);
        ctx.closePath();
        ctx.fill();

        // Leg front face
        ctx.fillStyle = '#4a2a0a';
        ctx.fillRect(leg.x - legDepth, leg.y, legWidth, legHeight);

        // Leg highlight
        ctx.fillStyle = '#5a3a1a';
        ctx.fillRect(leg.x - legDepth + 1, leg.y, 1, legHeight);
    });

    // Desk body/pedestal (back section, darker - recessed depth)
    ctx.fillStyle = '#2a1a00';
    ctx.beginPath();
    ctx.moveTo(deskX - 85, deskY - 20);
    ctx.lineTo(deskX + 85, deskY - 20);
    ctx.lineTo(deskX + 85, deskY + 40);
    ctx.lineTo(deskX - 85, deskY + 40);
    ctx.closePath();
    ctx.fill();

    // Left side panel (3D depth visible from angle)
    ctx.fillStyle = '#3a1a00';
    ctx.beginPath();
    ctx.moveTo(deskX - 85, deskY - 20);
    ctx.lineTo(deskX - 90, deskY - 25);
    ctx.lineTo(deskX - 90, deskY + 35);
    ctx.lineTo(deskX - 85, deskY + 40);
    ctx.closePath();
    ctx.fill();

    // Right side panel (3D depth, slightly lighter)
    ctx.fillStyle = '#4a2a0a';
    ctx.beginPath();
    ctx.moveTo(deskX + 85, deskY - 20);
    ctx.lineTo(deskX + 90, deskY - 25);
    ctx.lineTo(deskX + 90, deskY + 35);
    ctx.lineTo(deskX + 85, deskY + 40);
    ctx.closePath();
    ctx.fill();

    // Desk TOP surface - horizontal plane visible from above (key for 3D effect)
    // Back edge (darker depth)
    ctx.fillStyle = '#3a1a00';
    ctx.beginPath();
    ctx.moveTo(deskX - 90, deskY - 25);
    ctx.lineTo(deskX + 90, deskY - 25);
    ctx.lineTo(deskX + 85, deskY - 20);
    ctx.lineTo(deskX - 85, deskY - 20);
    ctx.closePath();
    ctx.fill();

    // Main top surface (mahogany, visible from above)
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath();
    ctx.moveTo(deskX - 85, deskY - 20);
    ctx.lineTo(deskX + 85, deskY - 20);
    ctx.lineTo(deskX + 80, deskY - 10);
    ctx.lineTo(deskX - 80, deskY - 10);
    ctx.closePath();
    ctx.fill();

    // Wood grain on top surface
    ctx.strokeStyle = '#6a4a2a';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.4;
    for(let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(deskX - 80 + i * 26, deskY - 20);
        ctx.lineTo(deskX - 80 + i * 26, deskY - 10);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Front edge lip (visible thickness)
    ctx.fillStyle = '#4a2a0a';
    ctx.fillRect(deskX - 80, deskY - 10, 160, 3);

    // Desk front face (drawers)
    ctx.fillStyle = '#5a3a1a';
    ctx.fillRect(deskX - 80, deskY - 7, 160, 66);

    // Drawer dividing lines
    ctx.strokeStyle = '#2a1a00';
    ctx.lineWidth = 2;
    for(let i = 1; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(deskX - 80, deskY - 7 + i * 22);
        ctx.lineTo(deskX + 80, deskY - 7 + i * 22);
        ctx.stroke();
    }

    // Drawer handles (golden brass)
    ctx.fillStyle = '#d4af37';
    for(let row = 0; row < 3; row++) {
        const handleY = deskY - 7 + row * 22 + 8;
        // Left handle
        ctx.fillRect(deskX - 25, handleY, 30, 4);
        // Right handle
        ctx.fillRect(deskX - 5, handleY, 30, 4);
    }

    // Safe positioned BELOW earth portrait on back wall - volumetric 3D, separated from desk
    const safeX = 350;
    const safeY = 140; // Positioned lower to avoid obscuring portrait
    const safeOpen = level6.safeUnlocked;

    // Safe shadow on floor
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(safeX - 32, safeY + 60, 64, 8);

    // Safe back panel (depth)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(safeX - 28, safeY - 4, 56, 62);

    // Safe left side (3D volume)
    ctx.fillStyle = '#252525';
    ctx.beginPath();
    ctx.moveTo(safeX - 25, safeY);
    ctx.lineTo(safeX - 28, safeY - 4);
    ctx.lineTo(safeX - 28, safeY + 54);
    ctx.lineTo(safeX - 25, safeY + 60);
    ctx.closePath();
    ctx.fill();

    // Safe right side (3D volume - lighter for depth)
    ctx.fillStyle = '#2f2f2f';
    ctx.beginPath();
    ctx.moveTo(safeX + 25, safeY);
    ctx.lineTo(safeX + 28, safeY - 4);
    ctx.lineTo(safeX + 28, safeY + 54);
    ctx.lineTo(safeX + 25, safeY + 60);
    ctx.closePath();
    ctx.fill();

    // Safe top (3D volume - visible from angle)
    ctx.fillStyle = '#303030';
    ctx.beginPath();
    ctx.moveTo(safeX - 25, safeY);
    ctx.lineTo(safeX - 28, safeY - 4);
    ctx.lineTo(safeX + 28, safeY - 4);
    ctx.lineTo(safeX + 25, safeY);
    ctx.closePath();
    ctx.fill();

    // Safe main body front (larger, solid)
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(safeX - 25, safeY, 50, 60);

    // Safe door/interior
    ctx.fillStyle = safeOpen ? '#1a1a1a' : '#0a0a0a';
    ctx.fillRect(safeX - 20, safeY + 5, 40, 35);

    // Safe door frame edge
    ctx.strokeStyle = '#404040';
    ctx.lineWidth = 1;
    ctx.strokeRect(safeX - 20, safeY + 5, 40, 35);

    if(!safeOpen) {
        // Keypad
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(safeX - 15, safeY + 10, 30, 25);

        // 4-color button keypad (2x2 grid matching UI)
        const buttonSize = 6;
        const buttonSpacing = 2;
        const panelStartX = safeX - 8;
        const panelStartY = safeY + 15;

        // RED button (top-left)
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(panelStartX, panelStartY, buttonSize, buttonSize);

        // GREEN button (top-right)
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(panelStartX + buttonSize + buttonSpacing, panelStartY, buttonSize, buttonSize);

        // BLUE button (bottom-left)
        ctx.fillStyle = '#005f99';
        ctx.fillRect(panelStartX, panelStartY + buttonSize + buttonSpacing, buttonSize, buttonSize);

        // YELLOW button (bottom-right)
        ctx.fillStyle = '#f39c12';
        ctx.fillRect(panelStartX + buttonSize + buttonSpacing, panelStartY + buttonSize + buttonSpacing, buttonSize, buttonSize);

        // Button panel frame
        ctx.strokeStyle = '#0a0a0a';
        ctx.lineWidth = 1;
        ctx.strokeRect(panelStartX - 1, panelStartY - 1, (buttonSize * 2) + buttonSpacing + 2, (buttonSize * 2) + buttonSpacing + 2);

        // Lock indicator (above buttons)
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(safeX, safeY + 11, 2, 0, Math.PI * 2);
        ctx.fill();

        // Hinges (left side)
        ctx.fillStyle = '#404040';
        ctx.fillRect(safeX - 22, safeY + 10, 3, 5);
        ctx.fillRect(safeX - 22, safeY + 30, 3, 5);
    } else {
        // Open safe showing contents
        if(!level6.hasRevolver) {
            // Revolver - exact match to player-held design pointing RIGHT (barrel right, handle down)
            // Centered horizontally in safe
            const revX = safeX;
            const revY = safeY + 22;
            const scale = 0.8;

            // Use mirroring to flip gun to point right
            ctx.save();
            ctx.translate(revX, revY);
            ctx.scale(-1, 1);
            ctx.translate(-revX, -revY);

            // Barrel (horizontal, pointing left in local coords, but will flip to right)
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(revX - 14*scale, revY - 2*scale, 18*scale, 5*scale);
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(revX - 14*scale, revY - scale, 18*scale, 2*scale);

            // Barrel tip/sight
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(revX - 15*scale, revY - 3*scale, 2*scale, 7*scale);

            // Cylinder
            ctx.fillStyle = '#5a5a5a';
            ctx.beginPath();
            ctx.arc(revX - 2*scale, revY + scale, 5*scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Cylinder chambers (6 chambers visible)
            ctx.fillStyle = '#2a2a2a';
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const cx = revX - 2*scale + Math.cos(angle) * 2.5*scale;
                const cy = revY + scale + Math.sin(angle) * 2.5*scale;
                ctx.beginPath();
                ctx.arc(cx, cy, 0.8*scale, 0, Math.PI * 2);
                ctx.fill();
            }

            // Frame
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(revX + 2*scale, revY - 2*scale, 4*scale, 8*scale);

            // Hammer
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(revX + 3*scale, revY - 5*scale, 2*scale, 4*scale);
            ctx.fillRect(revX + 2*scale, revY - 6*scale, 4*scale, 2*scale);

            // Wooden grip (matches player-held grip exactly)
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.moveTo(revX + 5*scale, revY + scale);
            ctx.lineTo(revX + 5*scale, revY + 10*scale);
            ctx.lineTo(revX + 9*scale, revY + 11*scale);
            ctx.lineTo(revX + 10*scale, revY + 6*scale);
            ctx.lineTo(revX + 9*scale, revY + scale);
            ctx.closePath();
            ctx.fill();

            // Grip texture (horizontal lines)
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 0.5*scale;
            for(let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(revX + 6*scale, revY + 3*scale + i*2*scale);
                ctx.lineTo(revX + 9*scale, revY + 3*scale + i*2*scale);
                ctx.stroke();
            }

            ctx.restore();

            // Clear any lingering paths to prevent stray lines
            ctx.beginPath();
        }
        if(level6.moneyLives < 3) {
            // Money sack visible - centered horizontally in safe
            ctx.fillStyle = '#27ae60';
            ctx.beginPath();
            ctx.arc(safeX, safeY + 32, 6, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Crystal brandy decanter (LEFT side of desk) - 3D solid object sitting ON desk top surface
    const brandyX = deskX - 55;
    const brandyY = deskY - 50; // Sitting on horizontal desk top, same level as monitor

    // Shadow beneath brandy decanter base (grounding it on desk top)
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.ellipse(brandyX, brandyY + 37, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Bottle back edge (3D depth)
    ctx.fillStyle = 'rgba(150,180,220,0.3)';
    ctx.fillRect(brandyX - 9, brandyY + 11, 18, 24);

    // Left side of bottle (3D depth)
    ctx.fillStyle = 'rgba(180,200,240,0.4)';
    ctx.beginPath();
    ctx.moveTo(brandyX - 8, brandyY + 12);
    ctx.lineTo(brandyX - 9, brandyY + 11);
    ctx.lineTo(brandyX - 9, brandyY + 35);
    ctx.lineTo(brandyX - 8, brandyY + 35);
    ctx.closePath();
    ctx.fill();

    // Right side of bottle (3D depth - lighter, catching light)
    ctx.fillStyle = 'rgba(220,235,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(brandyX + 8, brandyY + 12);
    ctx.lineTo(brandyX + 9, brandyY + 11);
    ctx.lineTo(brandyX + 9, brandyY + 35);
    ctx.lineTo(brandyX + 8, brandyY + 35);
    ctx.closePath();
    ctx.fill();

    // Square crystal bottle body front
    ctx.fillStyle = 'rgba(200,220,255,0.5)';
    ctx.fillRect(brandyX - 8, brandyY + 12, 16, 23);

    // Crystal facets/texture
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(brandyX - 7, brandyY + 14, 2, 18);
    ctx.fillRect(brandyX + 5, brandyY + 16, 2, 16);

    // Bottle outline for crystal effect
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(brandyX - 8, brandyY + 12, 16, 23);

    // Brandy liquid inside (3D - shows through glass)
    ctx.fillStyle = 'rgba(139,69,19,0.7)';
    ctx.fillRect(brandyX - 6, brandyY + 23, 12, 11);

    // Liquid depth on right side
    ctx.fillStyle = 'rgba(100,50,15,0.5)';
    ctx.fillRect(brandyX + 4, brandyY + 24, 2, 9);

    // Crystal highlights on liquid
    ctx.fillStyle = 'rgba(180,110,50,0.6)';
    ctx.fillRect(brandyX - 5, brandyY + 24, 3, 9);

    // Stopper neck (3D)
    ctx.fillStyle = 'rgba(180,200,240,0.5)';
    ctx.fillRect(brandyX - 4, brandyY + 7, 8, 5);

    ctx.fillStyle = 'rgba(200,220,255,0.6)';
    ctx.fillRect(brandyX - 3, brandyY + 8, 6, 4);
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 1;
    ctx.strokeRect(brandyX - 3, brandyY + 8, 6, 4);

    // Crystal stopper (RIGHT-SIDE UP) - 3D with depth
    // Stopper back
    ctx.fillStyle = 'rgba(180,200,240,0.5)';
    ctx.beginPath();
    ctx.moveTo(brandyX - 4.5, brandyY + 8);
    ctx.lineTo(brandyX + 4.5, brandyY + 8);
    ctx.lineTo(brandyX + 0.5, brandyY + 1);
    ctx.lineTo(brandyX - 0.5, brandyY + 1);
    ctx.closePath();
    ctx.fill();

    // Stopper front
    ctx.fillStyle = 'rgba(200,220,255,0.7)';
    ctx.beginPath();
    ctx.moveTo(brandyX - 4, brandyY + 8);
    ctx.lineTo(brandyX + 4, brandyY + 8);
    ctx.lineTo(brandyX, brandyY + 2);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.stroke();

    // Stopper highlight
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.moveTo(brandyX - 1, brandyY + 6);
    ctx.lineTo(brandyX + 1, brandyY + 6);
    ctx.lineTo(brandyX, brandyY + 3);
    ctx.closePath();
    ctx.fill();

    // Control console monitor - RIGHT side of desk, sitting ON desk top surface (3D solid)
    const monX = deskX + 40;
    const monY = deskY - 45; // Sitting on horizontal desk top

    // Shadow beneath monitor base (grounding it on desk)
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(monX + 7, monY + 33, 18, 2);

    // Monitor back panel (shows depth)
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(monX - 2, monY - 2, 36, 31);

    // Monitor left side (3D depth)
    ctx.fillStyle = '#151515';
    ctx.beginPath();
    ctx.moveTo(monX, monY);
    ctx.lineTo(monX - 2, monY - 2);
    ctx.lineTo(monX - 2, monY + 27);
    ctx.lineTo(monX, monY + 27);
    ctx.closePath();
    ctx.fill();

    // Monitor right side (3D depth - slightly lighter)
    ctx.fillStyle = '#202020';
    ctx.beginPath();
    ctx.moveTo(monX + 32, monY);
    ctx.lineTo(monX + 34, monY - 2);
    ctx.lineTo(monX + 34, monY + 27);
    ctx.lineTo(monX + 32, monY + 27);
    ctx.closePath();
    ctx.fill();

    // Monitor top (3D depth)
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.moveTo(monX, monY);
    ctx.lineTo(monX - 2, monY - 2);
    ctx.lineTo(monX + 34, monY - 2);
    ctx.lineTo(monX + 32, monY);
    ctx.closePath();
    ctx.fill();

    // Monitor frame front - sleeker design
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(monX, monY, 32, 27);

    // Inner bezel
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(monX + 1, monY + 1, 30, 24);

    // Screen - always visible once CEO defeated
    if(level6.ceoDefeated && !level6.computerUI) {
        // Active screen with cash green glow
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(monX + 2, monY + 2, 28, 21);

        // Glowing effect
        ctx.shadowColor = '#27ae60';
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(monX + 3, monY + 3, 26, 19);
        ctx.shadowBlur = 0;

        // Terminal-style text
        ctx.fillStyle = '#0a0a0a';
        ctx.font = 'bold 6px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('SYSTEM', monX + 16, monY + 10);
        ctx.fillText('READY', monX + 16, monY + 17);
    } else if(level6.ceoDefeated) {
        // Screen off but available
        ctx.fillStyle = '#1a3a1a';
        ctx.fillRect(monX + 2, monY + 2, 28, 21);
    } else {
        // Inactive/dark screen before CEO defeated
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(monX + 2, monY + 2, 28, 21);
    }

    // Monitor stand
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(monX + 13, monY + 27, 6, 4);
    ctx.fillRect(monX + 9, monY + 31, 14, 2);

    // === RED PHONE on desk (right side of desk top) ===
    const phoneX = deskX + 45, phoneY = deskY - 18;
    // Phone base
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(phoneX - 10, phoneY, 20, 8);
    ctx.fillStyle = '#aa0000';
    ctx.fillRect(phoneX - 9, phoneY + 1, 18, 6);
    // Dial pad holes
    ctx.fillStyle = '#880000';
    for(let pr = 0; pr < 2; pr++) {
        for(let pc = 0; pc < 3; pc++) {
            ctx.beginPath();
            ctx.arc(phoneX - 5 + pc * 5, phoneY + 3 + pr * 3, 1, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    // Handset cradle
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(phoneX - 12, phoneY - 3, 24, 4);
    // Handset on top
    const phoneRinging = level6.ceoDefeated && !level6.caseClosedCard;
    const ringBob = phoneRinging ? Math.sin(Date.now() / 80) * 2 : 0;
    const ringShake = phoneRinging ? Math.sin(Date.now() / 50) * 1.5 : 0;
    ctx.fillStyle = '#dd1111';
    // Earpiece
    ctx.fillRect(phoneX - 11 + ringShake, phoneY - 6 + ringBob, 7, 4);
    // Handle bar
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(phoneX - 7 + ringShake, phoneY - 4 + ringBob, 14, 2);
    // Mouthpiece
    ctx.fillStyle = '#dd1111';
    ctx.fillRect(phoneX + 4 + ringShake, phoneY - 6 + ringBob, 7, 4);
    // Ringing glow effect
    if(phoneRinging) {
        const ringGlow = 0.3 + Math.sin(Date.now() / 200) * 0.3;
        ctx.fillStyle = `rgba(255,50,50,${ringGlow})`;
        ctx.beginPath();
        ctx.arc(phoneX, phoneY - 2, 18, 0, Math.PI * 2);
        ctx.fill();
        // Ring lines (sound waves)
        ctx.strokeStyle = `rgba(255,100,100,${ringGlow})`;
        ctx.lineWidth = 1;
        for(let rw = 0; rw < 3; rw++) {
            const rwR = 20 + rw * 6 + Math.sin(Date.now() / 300) * 3;
            ctx.beginPath();
            ctx.arc(phoneX, phoneY - 2, rwR, -0.6, 0.6);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(phoneX, phoneY - 2, rwR, Math.PI - 0.6, Math.PI + 0.6);
            ctx.stroke();
        }
    }
    // Interaction prompt for phone
    if(level6.ceoDefeated && !level6.caseClosedCard && Math.abs(player.x - phoneX) < 50 && Math.abs(player.y - (deskY - 10)) < 60) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(phoneX - 75, phoneY - 30, 150, 20);
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ACTION: ANSWER PHONE', phoneX, phoneY - 14);
    }

    // Golden trophy cabinet (right back wall) - obstacle - LARGER to show photorealistic images clearly
    const cabinetX = 560;
    const cabinetY = 50;
    const cabinetWidth = 140;
    const cabinetHeight = 160;

    // Cabinet frame - golden wood (larger to fit photos properly)
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(cabinetX, cabinetY, cabinetWidth, cabinetHeight);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(cabinetX + 4, cabinetY + 4, cabinetWidth - 8, cabinetHeight - 8);

    // Glass shelves (adjusted for new cabinet size)
    ctx.strokeStyle = 'rgba(200,220,255,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cabinetX + 6, cabinetY + 40);
    ctx.lineTo(cabinetX + cabinetWidth - 6, cabinetY + 40);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cabinetX + 6, cabinetY + 85);
    ctx.lineTo(cabinetX + cabinetWidth - 6, cabinetY + 85);
    ctx.stroke();

    // Top shelf: Golden "CEO of the Year" trophy - centered in wider cabinet
    const trophyCenterX = cabinetX + cabinetWidth / 2;
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(trophyCenterX - 8, cabinetY + 32, 16, 5);
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(trophyCenterX, cabinetY + 22, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#0a0a0a';
    ctx.font = 'bold 6px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('CEO', trophyCenterX, cabinetY + 25);

    // Middle shelf: Billionaire Club crystal gift - centered in wider cabinet
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(trophyCenterX - 4, cabinetY + 77, 8, 4);
    // Crystal diamond shape
    ctx.fillStyle = 'rgba(100,200,255,0.8)';
    ctx.strokeStyle = '#4da6ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(trophyCenterX, cabinetY + 65);
    ctx.lineTo(trophyCenterX + 8, cabinetY + 73);
    ctx.lineTo(trophyCenterX, cabinetY + 77);
    ctx.lineTo(trophyCenterX - 8, cabinetY + 73);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Shine effect
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(trophyCenterX, cabinetY + 67);
    ctx.lineTo(trophyCenterX + 4, cabinetY + 71);
    ctx.lineTo(trophyCenterX, cabinetY + 73);
    ctx.lineTo(trophyCenterX - 4, cabinetY + 71);
    ctx.closePath();
    ctx.fill();

    // Bottom shelf: Three photorealistic pictures with PROPER aspect ratios (LARGER for visibility)
    // Picture dimensions based on actual image aspect ratios:
    // - trophy3 (CEO with general): 1024x1536 = 2:3 vertical portrait
    // - trophy1 (Freedom isn't free): 1536x1024 = 3:2 horizontal landscape
    // - trophy2 (CEO at PipeTech): 1536x1024 = 3:2 horizontal landscape

    const verticalWidth = 30;   // 2:3 aspect ratio (increased from 18 for better visibility)
    const verticalHeight = 45;
    const horizontalWidth = 45; // 3:2 aspect ratio (increased from 27 for better visibility)
    const horizontalHeight = 30;
    const picSpacing = 4;

    // Calculate starting position to center all three photos
    const totalWidth = verticalWidth + picSpacing + horizontalWidth + picSpacing + horizontalWidth;
    const startX = cabinetX + (cabinetWidth - totalWidth) / 2;

    // Bottom shelf position adjusted for taller photos
    const picY = cabinetY + 105;

    // Picture 1 (left): CEO with military general - VERTICAL PORTRAIT
    const pic1X = startX;
    const pic1Y = picY;
    // Frame - slightly thicker for photorealistic image
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(pic1X - 1.5, pic1Y - 1.5, verticalWidth + 3, verticalHeight + 3);
    ctx.fillStyle = '#6b5335';
    ctx.fillRect(pic1X - 1, pic1Y - 1, verticalWidth + 2, verticalHeight + 2);
    // Picture with proper aspect ratio
    if(trophy3Img.complete && trophy3Img.naturalWidth > 0) {
        ctx.drawImage(trophy3Img, pic1X, pic1Y, verticalWidth, verticalHeight);
    } else {
        ctx.fillStyle = '#4a9eff';
        ctx.fillRect(pic1X, pic1Y, verticalWidth, verticalHeight);
    }

    // Picture 2 (middle): Freedom isn't free memorial photo - HORIZONTAL LANDSCAPE
    const pic2X = pic1X + verticalWidth + picSpacing;
    const pic2Y = picY + (verticalHeight - horizontalHeight); // Align to bottom
    // Frame
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(pic2X - 1.5, pic2Y - 1.5, horizontalWidth + 3, horizontalHeight + 3);
    ctx.fillStyle = '#6b5335';
    ctx.fillRect(pic2X - 1, pic2Y - 1, horizontalWidth + 2, horizontalHeight + 2);
    // Picture with proper aspect ratio
    if(trophy1Img.complete && trophy1Img.naturalWidth > 0) {
        ctx.drawImage(trophy1Img, pic2X, pic2Y, horizontalWidth, horizontalHeight);
    } else {
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(pic2X, pic2Y, horizontalWidth, horizontalHeight);
    }

    // Picture 3 (right): CEO at PipeTech construction site - HORIZONTAL LANDSCAPE
    const pic3X = pic2X + horizontalWidth + picSpacing;
    const pic3Y = pic2Y; // Same Y as pic2 (both horizontal)
    // Frame
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(pic3X - 1.5, pic3Y - 1.5, horizontalWidth + 3, horizontalHeight + 3);
    ctx.fillStyle = '#6b5335';
    ctx.fillRect(pic3X - 1, pic3Y - 1, horizontalWidth + 2, horizontalHeight + 2);
    // Picture with proper aspect ratio
    if(trophy2Img.complete && trophy2Img.naturalWidth > 0) {
        ctx.drawImage(trophy2Img, pic3X, pic3Y, horizontalWidth, horizontalHeight);
    } else {
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(pic3X, pic3Y, horizontalWidth, horizontalHeight);
    }

    // "YOU WIN" mirror (left back wall) - pushed against wall
    const mirrorX = 100;
    const mirrorY = 50;
    
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(mirrorX, mirrorY, 90, 110);
    ctx.fillStyle = '#b8941e';
    ctx.fillRect(mirrorX + 5, mirrorY + 5, 80, 100);
    
    // Mirror surface
    ctx.fillStyle = '#c0c0c0';
    ctx.fillRect(mirrorX + 10, mirrorY + 10, 70, 90);
    
    // "YOU WIN" text etched in glass
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('YOU', mirrorX + 45, mirrorY + 50);
    ctx.fillText('WIN', mirrorX + 45, mirrorY + 75);
    
    // CEO reflection if admiring
    if(ceo.state === 'admiring') {
        ctx.fillStyle = 'rgba(245,200,154,0.4)';
        ctx.fillRect(mirrorX + 30, mirrorY + 30, 30, 60);
    }

    // Double-width office door at bottom (can't be opened once entered)
    ctx.fillStyle = '#4a2a0a';
    ctx.fillRect(300, 430, 100, 70);
    ctx.fillStyle = '#3a1a00';
    ctx.fillRect(305, 435, 45, 60);
    ctx.fillRect(350, 435, 45, 60);

    // Door handles
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(340, 465, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(360, 465, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Cash sacks dropped when CEO is hit
    for(let sack of level6.cashSacks) {
        if(!sack.claimed) {
            drawCashSack(sack.x, sack.y);
        }
    }
    
    // Interaction prompts
    if(!level6.safeUnlocked && Math.abs(player.x - safeX) < 60 && Math.abs(player.y - safeY) < 80) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION', safeX, safeY - 10);
    }

    if(level6.safeUnlocked && !level6.hasRevolver && Math.abs(player.x - safeX) < 60 && Math.abs(player.y - safeY) < 80) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION', safeX, safeY - 10);
    }

    if(level6.safeUnlocked && level6.moneyLives < 3 && Math.abs(player.x - safeX) < 60 && Math.abs(player.y - safeY) < 80 && level6.hasRevolver) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION FOR $ LIFE', safeX, safeY - 10);
    }

    if(level6.ceoDefeated && !level6.computerUI && Math.abs(player.x - monX) < 50 && Math.abs(player.y - monY) < 60) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS ACTION', monX + 16, monY - 15);
    }
}



// SECTION 11: UI Drawing Functions
function drawEmailUI(officeName) {
    const email = OFFICE_EMAILS[officeName];

    // Full-screen email for mobile readability
    ctx.fillStyle = '#f5f2ec';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    const office = level5.hallway.offices.find(o => o.name === officeName);
    ctx.fillStyle = office.color.hex;
    ctx.fillRect(-GX, -GY, CANVAS_W, 50 + GY);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Pmail', 20, 36);

    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Arial';
    ctx.fillText('From: ' + email.from, 20, 82);
    ctx.fillText('To: ' + email.to, 20, 108);
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Subject: ' + email.subject, 20, 140);

    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, 152);
    ctx.lineTo(680, 152);
    ctx.stroke();

    // Clip body text to scrollable area
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, 158, 700, 290);
    ctx.clip();

    ctx.fillStyle = '#000';
    ctx.font = '22px Arial';
    const lines = email.body.split('\n');
    let yPos = 185 - level5.emailScrollOffset;
    for(let line of lines) {
        ctx.fillText(line, 20, yPos);
        yPos += 32;
    }
    ctx.restore();

    // Instruction bar at bottom
    ctx.fillStyle = 'rgba(0,0,0,0.88)';
    ctx.fillRect(-GX, 450, CANVAS_W, CANVAS_H);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ACTION TO CLOSE    ▲▼ SCROLL', 350, 481);
}

function drawLetterUI() {
    // Full-screen dark overlay
    ctx.fillStyle = '#000';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Display letter image scaled to fill available canvas width
    if(letterImg.complete && letterImg.naturalWidth > 0) {
        const maxWidth = CANVAS_W;
        const viewportHeight = CANVAS_H - 45;
        const scale = maxWidth / letterImg.naturalWidth;
        const fullHeight = letterImg.naturalHeight * scale;

        const letterX = -GX;
        const viewportY = -GY;

        ctx.save();
        ctx.beginPath();
        ctx.rect(letterX, viewportY, maxWidth, viewportHeight);
        ctx.clip();

        const letterY = viewportY - level5.letterScrollOffset;
        ctx.drawImage(letterImg, letterX, letterY, maxWidth, fullHeight);

        ctx.restore();
    }

    // Instruction bar at bottom
    ctx.fillStyle = 'rgba(0,0,0,0.88)';
    ctx.fillRect(-GX, -GY + CANVAS_H - 45, CANVAS_W, 45);
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ACTION TO CLOSE    ▲▼ SCROLL', 350, -GY + CANVAS_H - 18);
}

function drawDetectiveNoteUI() {
    // Full-screen dark overlay
    ctx.fillStyle = '#000';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Display detective note image scaled to fill available canvas width
    if(detectiveNoteImg.complete && detectiveNoteImg.naturalWidth > 0) {
        const maxWidth = CANVAS_W;
        const viewportHeight = CANVAS_H - 45;
        const scale = maxWidth / detectiveNoteImg.naturalWidth;
        const fullHeight = detectiveNoteImg.naturalHeight * scale;

        const noteX = -GX;
        const viewportY = -GY;

        // Create clipping region for scrollable area
        ctx.save();
        ctx.beginPath();
        ctx.rect(noteX, viewportY, maxWidth, viewportHeight);
        ctx.clip();

        // Draw image offset by scroll amount
        const noteY = viewportY - level6.noteScrollOffset;
        ctx.drawImage(detectiveNoteImg, noteX, noteY, maxWidth, fullHeight);

        ctx.restore();
    }

    // Instruction bar at bottom
    ctx.fillStyle = 'rgba(0,0,0,0.88)';
    ctx.fillRect(-GX, -GY + CANVAS_H - 45, CANVAS_W, 45);
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ACTION TO CLOSE    ▲▼ SCROLL', 350, -GY + CANVAS_H - 18);
}

function drawSafeUI() {
    // If selecting item after unlock
    if(level6.selectingItem) {
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.fillRect(50, 50, 600, 400);

        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(60, 60, 580, 380);

        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(70, 70, 560, 360);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SELECT ITEM', 350, 110);

        // Revolver option
        const revolverSelected = level6.itemSelection === 0;
        ctx.fillStyle = '#666';
        ctx.fillRect(100, 160, 140, 120);
        ctx.strokeStyle = revolverSelected ? '#f5f2ec' : '#444';
        ctx.lineWidth = revolverSelected ? 5 : 2;
        ctx.strokeRect(100, 160, 140, 120);

        // Draw golden revolver icon (matches player-held design: barrel right, handle down)
        const revIconX = 170;
        const revIconY = 210;
        const iconScale = 1.2;

        // Use mirroring to flip gun to point right
        ctx.save();
        ctx.translate(revIconX, revIconY);
        ctx.scale(-1, 1);
        ctx.translate(-revIconX, -revIconY);

        // Barrel (horizontal, pointing left in local coords, but will flip to right)
        ctx.fillStyle = '#d4af37'; // Dark gold
        ctx.fillRect(revIconX - 14*iconScale, revIconY - 2*iconScale, 18*iconScale, 5*iconScale);
        ctx.fillStyle = '#ffd700'; // Bright gold highlight
        ctx.fillRect(revIconX - 14*iconScale, revIconY - iconScale, 18*iconScale, 2*iconScale);

        // Barrel tip/sight
        ctx.fillStyle = '#b8941e';
        ctx.fillRect(revIconX - 15*iconScale, revIconY - 3*iconScale, 2*iconScale, 7*iconScale);

        // Cylinder
        ctx.fillStyle = '#c9a637';
        ctx.beginPath();
        ctx.arc(revIconX - 2*iconScale, revIconY + iconScale, 5*iconScale, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#b8941e';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Cylinder chambers (6 chambers visible)
        ctx.fillStyle = '#b8941e';
        for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const cx = revIconX - 2*iconScale + Math.cos(angle) * 2.5*iconScale;
            const cy = revIconY + iconScale + Math.sin(angle) * 2.5*iconScale;
            ctx.beginPath();
            ctx.arc(cx, cy, 0.8*iconScale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Frame
        ctx.fillStyle = '#d4af37';
        ctx.fillRect(revIconX + 2*iconScale, revIconY - 2*iconScale, 4*iconScale, 8*iconScale);

        // Hammer
        ctx.fillStyle = '#b8941e';
        ctx.fillRect(revIconX + 3*iconScale, revIconY - 5*iconScale, 2*iconScale, 4*iconScale);
        ctx.fillRect(revIconX + 2*iconScale, revIconY - 6*iconScale, 4*iconScale, 2*iconScale);

        // Wooden grip (golden brown)
        ctx.fillStyle = '#c9a637';
        ctx.beginPath();
        ctx.moveTo(revIconX + 5*iconScale, revIconY + iconScale);
        ctx.lineTo(revIconX + 5*iconScale, revIconY + 10*iconScale);
        ctx.lineTo(revIconX + 9*iconScale, revIconY + 11*iconScale);
        ctx.lineTo(revIconX + 10*iconScale, revIconY + 6*iconScale);
        ctx.lineTo(revIconX + 9*iconScale, revIconY + iconScale);
        ctx.closePath();
        ctx.fill();

        // Grip texture (horizontal lines)
        ctx.strokeStyle = '#b8941e';
        ctx.lineWidth = 0.5*iconScale;
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(revIconX + 6*iconScale, revIconY + 3*iconScale + i*2*iconScale);
            ctx.lineTo(revIconX + 9*iconScale, revIconY + 3*iconScale + i*2*iconScale);
            ctx.stroke();
        }

        // Trigger
        ctx.fillStyle = '#b8941e';
        ctx.beginPath();
        ctx.arc(revIconX + 1*iconScale, revIconY + 3*iconScale, 1.5*iconScale, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('REVOLVER', 170, 270);
        if(level6.hasRevolver) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('TAKEN', 170, 255);
        }

        // Money life option
        const moneySelected = level6.itemSelection === 1;
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(280, 160, 140, 120);
        ctx.strokeStyle = moneySelected ? '#f5f2ec' : '#444';
        ctx.lineWidth = moneySelected ? 5 : 2;
        ctx.strokeRect(280, 160, 140, 120);

        // Draw money icon
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 56px Arial';
        ctx.fillText('$', 350, 230);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('$ LIFE', 350, 270);
        if(level6.moneyLives >= 3) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('MAX', 350, 255);
        }

        // Bullets option
        const bulletsSelected = level6.itemSelection === 2;
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(460, 160, 140, 120);
        ctx.strokeStyle = bulletsSelected ? '#f5f2ec' : '#444';
        ctx.lineWidth = bulletsSelected ? 5 : 2;
        ctx.strokeRect(460, 160, 140, 120);

        // Draw ammo box with label
        ctx.fillStyle = '#654321';
        ctx.fillRect(505, 190, 50, 35);
        ctx.strokeStyle = '#4a3a2a';
        ctx.lineWidth = 2;
        ctx.strokeRect(505, 190, 50, 35);

        // Ammo box label area
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(507, 192, 46, 12);

        // Lead bullets pictured on box
        for(let i = 0; i < 6; i++) {
            ctx.fillStyle = '#909090';
            const bx = 512 + (i % 3) * 13;
            const by = 207 + Math.floor(i / 3) * 8;
            ctx.fillRect(bx, by, 4, 7);
            ctx.fillStyle = '#606060';
            ctx.fillRect(bx, by, 4, 3);
        }

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('AMMO', 530, 270);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('Rounds (x6)', 530, 255);

        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.fillText('USE ◄► TO SELECT, ACTION TO TAKE', 350, 380);
        return;
    }

    // Standard code entry UI
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(50, 50, 600, 400);

    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(60, 60, 580, 380);

    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(70, 70, 560, 360);

    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ENTER ACCESS CODE', 350, 120);

    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(200, 150, 300, 60);

    for(let i = 0; i < 4; i++) {
        const boxX = 220 + i * 70;
        ctx.fillStyle = level6.codeInput[i] ? COLORS.find(c => c.name === level6.codeInput[i]).hex : '#1a1a1a';
        ctx.fillRect(boxX, 160, 50, 40);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(boxX, 160, 50, 40);
    }

    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 18px Arial';
    ctx.fillText('SELECT COLORS:', 350, 260);

    // 2x2 color button grid with white outline on selected
    for(let i = 0; i < 4; i++) {
        const row = Math.floor(i / 2);
        const col = i % 2;
        const btnX = 250 + col * 100;
        const btnY = 280 + row * 70;

        const isSelected = level6.selectedButton === i;

        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(btnX, btnY, 80, 50);

        // White outline when selected, dark when not
        ctx.strokeStyle = isSelected ? '#f5f2ec' : '#2b2b2b';
        ctx.lineWidth = isSelected ? 5 : 3;
        ctx.strokeRect(btnX, btnY, 80, 50);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(COLORS[i].name, btnX + 40, btnY + 32);
    }

    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('USE ◄►▲▼ TO SELECT, ACTION TO ENTER', 350, 440);

    if(level6.codeInput.length === 4) {
        const correct = level6.codeInput.every((color, i) => color === SAFE_CODE[i]);
        ctx.fillStyle = correct ? '#27ae60' : '#e74c3c';
        ctx.font = 'bold 24px Arial';
        ctx.fillText(correct ? 'ACCESS GRANTED!' : 'INCORRECT CODE', 350, 240);
    }
}

function drawElevatorUI() {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Elevator panel — 3 floors (descending order)
    const opts = ['EMPLOYEE LEVEL', 'SMARTWARE LEVEL', 'CEO LEVEL'];
    const pw = 280, ph = 320;
    const px = 350 - pw / 2, py = 90;
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(px, py, pw, ph);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);

    // Gold accent strip
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(px + 20, py + 10, pw - 40, 3);

    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 16px serif';
    ctx.textAlign = 'center';
    ctx.fillText('PRIVATE ELEVATOR', 350, py + 32);

    // Floor options
    for (let i = 0; i < opts.length; i++) {
        const oy = py + 50 + i * 72;
        const sel = level6.elevatorChoice === i;
        // Highlight current floor dimly
        const isCurrentFloor = (level6.room === 'pipeRoom' && i === 1) ||       // Smartware Level
                               (level6.room === 'entryway' && i === 2) ||      // CEO Level
                               (level6.room === 'employeeLobby' && i === 0);   // Employee Level
        ctx.fillStyle = sel ? '#d4af37' : (isCurrentFloor ? '#2a2a1a' : '#333');
        ctx.fillRect(px + 30, oy, pw - 60, 54);
        ctx.strokeStyle = sel ? '#ffd700' : (isCurrentFloor ? '#887722' : '#555');
        ctx.lineWidth = sel ? 3 : 1;
        ctx.strokeRect(px + 30, oy, pw - 60, 54);

        ctx.fillStyle = sel ? '#000' : (isCurrentFloor ? '#887722' : '#aaa');
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(opts[i], 350, oy + 33);
        if (isCurrentFloor) {
            ctx.fillStyle = '#555';
            ctx.font = '11px Arial';
            ctx.fillText('(YOU ARE HERE)', 350, oy + 48);
        }
    }

    ctx.fillStyle = '#666';
    ctx.font = '13px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('▲▼ SELECT   ACTION CONFIRM', 350, py + ph - 15);
}

function drawKeypadUI() {
    ctx.fillStyle = 'rgba(0,0,0,0.92)';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Keypad panel frame — dark steel
    const panelW = 320, panelH = 380;
    const px = 350 - panelW / 2, py = 60;
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(px, py, panelW, panelH);
    ctx.fillStyle = '#222';
    ctx.fillRect(px + 6, py + 6, panelW - 12, panelH - 12);

    // Cyan header LED strip
    ctx.fillStyle = '#00ccff';
    ctx.shadowColor = '#00ccff';
    ctx.shadowBlur = 10;
    ctx.fillRect(px + 20, py + 12, panelW - 40, 3);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#00ccff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('SECURITY ACCESS', 350, py + 40);

    // Code display — 4 digit slots
    const codeY = py + 60;
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(px + 40, codeY, panelW - 80, 50);
    ctx.strokeStyle = '#00ccff';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 40, codeY, panelW - 80, 50);

    for (let i = 0; i < 4; i++) {
        const slotX = px + 60 + i * 52;
        ctx.fillStyle = level6.keypadInput[i] !== undefined ? '#00ccff' : '#111';
        ctx.fillRect(slotX, codeY + 8, 36, 34);
        ctx.strokeStyle = '#00ccff';
        ctx.lineWidth = 1;
        ctx.strokeRect(slotX, codeY + 8, 36, 34);
        if (level6.keypadInput[i] !== undefined) {
            ctx.fillStyle = '#000';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(level6.keypadInput[i].toString(), slotX + 18, codeY + 34);
        }
    }

    // Result feedback
    if (level6.keypadResult !== null) {
        ctx.fillStyle = level6.keypadResult ? '#00ff88' : '#ff3333';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(level6.keypadResult ? 'ACCESS GRANTED' : 'ACCESS DENIED', 350, codeY + 70);
    }

    // 6 number buttons (3x2 grid)
    const gridX = px + 50, gridY = codeY + 90;
    const btnW = 70, btnH = 50, gap = 10;
    for (let i = 0; i < 6; i++) {
        const col = i % 3, row = Math.floor(i / 3);
        const bx = gridX + col * (btnW + gap);
        const by = gridY + row * (btnH + gap);
        const isSelected = level6.keypadSelected === i;

        ctx.fillStyle = isSelected ? '#00ccff' : '#2a2a2a';
        ctx.fillRect(bx, by, btnW, btnH);
        ctx.strokeStyle = isSelected ? '#fff' : '#444';
        ctx.lineWidth = isSelected ? 3 : 1;
        ctx.strokeRect(bx, by, btnW, btnH);

        ctx.fillStyle = isSelected ? '#000' : '#00ccff';
        ctx.font = 'bold 26px Arial';
        ctx.textAlign = 'center';
        ctx.fillText((i + 1).toString(), bx + btnW / 2, by + 34);
    }

    // Instructions
    ctx.fillStyle = '#888';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('◄►▲▼ SELECT   ACTION ENTER   DOWN CLEAR', 350, gridY + 2 * (btnH + gap) + 30);
}

function drawComputerUI() {
    // Skip the "collect sacks" screen - proceed directly to victory
    if(level6.computerCompleted) {
        return;
    }

    // Interactive selection UI
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(50, 50, 600, 400);

    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(60, 60, 580, 380);

    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH MAINFRAME', 350, 110);

    ctx.fillStyle = '#27ae60';
    ctx.font = 'bold 16px Arial';
    ctx.fillText('SYSTEM ACCESS: EXECUTIVE', 350, 150);

    // Self-destruct option (left)
    const destructSelected = level6.computerChoice === 0;
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(120, 200, 180, 110);

    // White outline if selected
    ctx.strokeStyle = destructSelected ? '#ffffff' : '#c0392b';
    ctx.lineWidth = destructSelected ? 6 : 3;
    ctx.strokeRect(120, 200, 180, 110);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px Arial';
    ctx.fillText('SELF', 210, 245);
    ctx.fillText('DESTRUCT', 210, 275);

    // Deliver means option (right)
    const deliverSelected = level6.computerChoice === 1;
    ctx.fillStyle = '#27ae60';
    ctx.fillRect(400, 200, 180, 110);

    // White outline if selected
    ctx.strokeStyle = deliverSelected ? '#ffffff' : '#1e8449';
    ctx.lineWidth = deliverSelected ? 6 : 3;
    ctx.strokeRect(400, 200, 180, 110);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.fillText('DELIVER MEANS', 490, 240);
    ctx.fillText('OF PRODUCTION', 490, 270);

    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 16px Arial';
    ctx.fillText('USE ◄► TO SELECT, ACTION TO CONFIRM', 350, 355);

    ctx.fillStyle = '#f39c12';
    ctx.font = '16px Arial';
    ctx.fillText('WARNING: CHOICE IS FINAL', 350, 380);
}


// SECTION 12: Main Drawing and Scene Management
function drawCEO(x, y, facing) {
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 14, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    const skinColor = ceo.blinkTimer > 0 ? '#cc0000' : '#d4a882';
    const weatheredSkin = '#c49872';

    if(facing === 'left') {
        // BODY - Dark charcoal suit
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 7*s, y + s, 14*s, 11*s);

        // Suit jacket shading
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x + 5*s, y + s, 2*s, 11*s);

        // Dark red tie
        ctx.fillStyle = '#8b0000';
        ctx.fillRect(x - 2*s, y + 2*s, 3*s, 9*s);

        // White shirt collar
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(x - 3*s, y + s, 6*s, 2*s);

        // Gold watch on left wrist
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(x - 10*s, y + 6*s, 2*s, 2*s);

        // ARMS
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 9*s, y + 2*s, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y + 2*s, 2*s, 7*s);

        // PANTS
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + 12*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 16*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 4*s, 8*s);

        // SHOES
        ctx.fillStyle = '#0a0a0a';
        const legL = (ceo.state === 'hunting' && ceo.moveTimer > 0) ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 24*s + legL, 5*s, 2*s);
        ctx.fillRect(x + s, y + 24*s - legL, 5*s, 2*s);

        // HEAD - weathered older skin
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 6*s, y - 13*s, 12*s, 13*s);

        // Gray slicked hair
        ctx.fillStyle = '#6b6b6b';
        ctx.fillRect(x - 6*s, y - 14*s, 12*s, 4*s);
        ctx.fillRect(x - 7*s, y - 12*s, 2*s, 3*s);

        // Darker gray hair shading
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x - 5*s, y - 14*s, 2*s, 2*s);

        // Wrinkled forehead
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x - 5*s, y - 10*s, 10*s, s);
        ctx.fillRect(x - 4*s, y - 8*s, 8*s, s);

        // Heavy brow
        ctx.fillStyle = '#a07852';
        ctx.fillRect(x - 5*s, y - 7*s, 8*s, 2*s);

        // Deep-set eye (left side view)
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 2*s, y - 5*s, 3*s, 2*s);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - s, y - 5*s, s, s);

        // Jowls and weathered cheeks
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 5*s, y - 3*s, 10*s, 4*s);
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x - 5*s, y - 2*s, 2*s, 2*s);

        // Nose
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 2*s, y - 4*s, 2*s, 3*s);

        // Jaw
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 4*s, y + s, 8*s, 2*s);

        // Cigar in mouth (properly held in corner, extending left)
        ctx.save();
        ctx.translate(x - 3*s, y + 0.5*s); // Left corner of mouth
        ctx.rotate(-0.2); // Slight downward angle to left
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(-8*s, -0.5*s, 8*s, 1.5*s); // Cigar body extending left
        ctx.fillStyle = '#654321';
        ctx.fillRect(-s, -0.5*s, s, 1.5*s); // End in mouth (darker)
        // Lit cigar tip (far left end)
        ctx.fillStyle = '#ff4500';
        ctx.fillRect(-8*s, -0.5*s, s, 1.5*s);
        ctx.fillStyle = '#ff6347';
        ctx.fillRect(-8.5*s, 0, 0.5*s, 0.5*s); // Glow
        ctx.restore();

        // Cigar smoke
        if(frame % 20 < 10) {
            ctx.fillStyle = 'rgba(200,200,200,0.4)';
            ctx.beginPath();
            ctx.arc(x - 12, y - 4, 3, 0, Math.PI * 2);
            ctx.fill();
        }

    } else if(facing === 'right') {
        // BODY - Dark charcoal suit
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 7*s, y + s, 14*s, 11*s);

        // Suit jacket shading
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + s, 2*s, 11*s);

        // Dark red tie
        ctx.fillStyle = '#8b0000';
        ctx.fillRect(x - s, y + 2*s, 3*s, 9*s);

        // White shirt collar
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(x - 3*s, y + s, 6*s, 2*s);

        // Gold ring on right hand
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(x + 8*s, y + 6*s, 2*s, 2*s);

        // ARMS
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 9*s, y + 2*s, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y + 2*s, 2*s, 7*s);

        // PANTS
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 7*s, y + 12*s, 14*s, 4*s);
        ctx.fillRect(x - 5*s, y + 16*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 4*s, 8*s);

        // SHOES
        ctx.fillStyle = '#0a0a0a';
        const legR = (ceo.state === 'hunting' && ceo.moveTimer > 0) ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 24*s + legR, 5*s, 2*s);
        ctx.fillRect(x + s, y + 24*s - legR, 5*s, 2*s);

        // HEAD - weathered older skin
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 6*s, y - 13*s, 12*s, 13*s);

        // Gray slicked hair
        ctx.fillStyle = '#6b6b6b';
        ctx.fillRect(x - 6*s, y - 14*s, 12*s, 4*s);
        ctx.fillRect(x + 5*s, y - 12*s, 2*s, 3*s);

        // Darker gray hair shading
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x + 3*s, y - 14*s, 2*s, 2*s);

        // Wrinkled forehead
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x - 5*s, y - 10*s, 10*s, s);
        ctx.fillRect(x - 4*s, y - 8*s, 8*s, s);

        // Heavy brow
        ctx.fillStyle = '#a07852';
        ctx.fillRect(x - 3*s, y - 7*s, 8*s, 2*s);

        // Deep-set eye (right side view)
        ctx.fillStyle = '#000';
        ctx.fillRect(x - s, y - 5*s, 3*s, 2*s);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x, y - 5*s, s, s);

        // Jowls and weathered cheeks
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 5*s, y - 3*s, 10*s, 4*s);
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x + 3*s, y - 2*s, 2*s, 2*s);

        // Nose
        ctx.fillStyle = skinColor;
        ctx.fillRect(x, y - 4*s, 2*s, 3*s);

        // Jaw
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 4*s, y + s, 8*s, 2*s);

        // Cigar in mouth (properly held in corner, extending right)
        ctx.save();
        ctx.translate(x + 3*s, y + 0.5*s); // Right corner of mouth
        ctx.rotate(0.2); // Slight downward angle to right
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(0, -0.5*s, 8*s, 1.5*s); // Cigar body extending right
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, -0.5*s, s, 1.5*s); // End in mouth (darker)
        // Lit cigar tip (far right end)
        ctx.fillStyle = '#ff4500';
        ctx.fillRect(7*s, -0.5*s, s, 1.5*s);
        ctx.fillStyle = '#ff6347';
        ctx.fillRect(8*s, 0, 0.5*s, 0.5*s); // Glow
        ctx.restore();

        // Cigar smoke
        if(frame % 20 < 10) {
            ctx.fillStyle = 'rgba(200,200,200,0.4)';
            ctx.beginPath();
            ctx.arc(x + 12, y - 4, 3, 0, Math.PI * 2);
            ctx.fill();
        }

    } else if(facing === 'forward' || facing === 'down') {
        // FORWARD/DOWN FACING
        // BODY - Dark charcoal suit
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 8*s, y + s, 16*s, 11*s);

        // White shirt front
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(x - 3*s, y + s, 6*s, 2*s);

        // Dark red tie
        ctx.fillStyle = '#8b0000';
        ctx.fillRect(x - 2*s, y + 2*s, 4*s, 9*s);
        ctx.fillStyle = '#6b0000';
        ctx.fillRect(x - s, y + 3*s, 2*s, 7*s);

        // American flag lapel pin
        ctx.fillStyle = '#003f87';
        ctx.fillRect(x - 6*s, y + 3*s, 2*s, s);
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(x - 6*s, y + 4*s, 2*s, s);

        // White pocket square
        ctx.fillStyle = '#fff';
        ctx.fillRect(x + 4*s, y + 3*s, 2*s, 2*s);

        // ARMS
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 10*s, y + 2*s, 2*s, 8*s);
        ctx.fillRect(x + 8*s, y + 2*s, 2*s, 8*s);

        // Hands visible
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 10*s, y + 9*s, 2*s, 2*s);
        ctx.fillRect(x + 8*s, y + 9*s, 2*s, 2*s);

        // Gold watch on left wrist
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(x - 10*s, y + 8*s, 2*s, s);

        // Gold ring on right hand
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(x + 18, y + 20, 2, 0, Math.PI * 2);
        ctx.fill();

        // PANTS
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 8*s, y + 12*s, 16*s, 4*s);
        ctx.fillRect(x - 6*s, y + 16*s, 5*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 5*s, 8*s);

        // SHOES
        ctx.fillStyle = '#0a0a0a';
        const leg = (ceo.state === 'hunting' && ceo.moveTimer > 0) ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 6*s, y + 24*s + leg, 5*s, 2*s);
        ctx.fillRect(x + s, y + 24*s - leg, 5*s, 2*s);

        // HEAD - weathered older skin
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 6*s, y - 13*s, 12*s, 14*s);

        // Gray slicked hair - parted
        ctx.fillStyle = '#6b6b6b';
        ctx.fillRect(x - 6*s, y - 15*s, 5*s, 4*s);
        ctx.fillRect(x + s, y - 15*s, 5*s, 4*s);
        ctx.fillRect(x - 7*s, y - 12*s, 2*s, 3*s);
        ctx.fillRect(x + 5*s, y - 12*s, 2*s, 3*s);

        // Dark hair part line
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x - s, y - 14*s, 2*s, 2*s);

        // Wrinkled forehead
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x - 5*s, y - 10*s, 10*s, s);
        ctx.fillRect(x - 4*s, y - 8*s, 8*s, s);

        // Heavy brow - menacing
        ctx.fillStyle = '#a07852';
        ctx.fillRect(x - 5*s, y - 7*s, 4*s, 2*s);
        ctx.fillRect(x + s, y - 7*s, 4*s, 2*s);

        // Deep-set eyes - stern expression
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 4*s, y - 5*s, 3*s, 2*s);
        ctx.fillRect(x + s, y - 5*s, 3*s, 2*s);

        // Eye whites
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 3*s, y - 5*s, s, s);
        ctx.fillRect(x + 2*s, y - 5*s, s, s);

        // Pupils - cold stare
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 5*s, s, s);
        ctx.fillRect(x + 2*s, y - 5*s, s, s);

        // Bags under eyes
        ctx.fillStyle = '#9a7252';
        ctx.fillRect(x - 4*s, y - 3*s, 3*s, s);
        ctx.fillRect(x + s, y - 3*s, 3*s, s);

        // Nose
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - s, y - 4*s, 2*s, 4*s);
        ctx.fillStyle = '#c49872';
        ctx.fillRect(x - 2*s, y - 2*s, s, 2*s);
        ctx.fillRect(x + s, y - 2*s, s, 2*s);

        // Jowls - heavy
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 5*s, y - s, 3*s, 3*s);
        ctx.fillRect(x + 2*s, y - s, 3*s, 3*s);

        // Cigar in mouth (properly held in right corner, extending right)
        ctx.save();
        ctx.translate(x + 2*s, y + 0.5*s); // Right corner of mouth
        ctx.rotate(0.15); // Slight downward angle to right
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(0, -0.5*s, 7*s, 1.5*s); // Cigar body extending right
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, -0.5*s, s, 1.5*s); // End in mouth (darker)
        // Lit tip on far right
        ctx.fillStyle = '#ff4500';
        ctx.fillRect(6*s, -0.5*s, s, 1.5*s);
        ctx.fillStyle = '#ff6347';
        ctx.fillRect(7*s, 0, 0.5*s, 0.5*s); // Glow
        ctx.restore();

        // Faint smoke visible from front
        if(frame % 20 < 10) {
            ctx.fillStyle = 'rgba(200,200,200,0.3)';
            ctx.beginPath();
            ctx.arc(x + 14, y - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Weathered jaw
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 4*s, y + 3*s, 8*s, 2*s);
        ctx.fillStyle = '#b88a62';
        ctx.fillRect(x - 3*s, y + 3*s, 6*s, s);
    } else if(facing === 'back') {
        // BACK VIEW - CEO facing mirror with back to player
        // BODY - Dark charcoal suit from behind
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 8*s, y + s, 16*s, 11*s);

        // Suit jacket back shading
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 6*s, y + 2*s, 12*s, 9*s);

        // Collar from behind
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(x - 4*s, y, 8*s, 2*s);

        // ARMS from behind - one holding drink
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 10*s, y + 2*s, 3*s, 8*s); // Left arm down
        ctx.fillRect(x + 7*s, y + 2*s, 3*s, 6*s); // Right arm raised

        // PANTS from behind
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 8*s, y + 12*s, 16*s, 4*s);
        ctx.fillRect(x - 6*s, y + 16*s, 5*s, 8*s);
        ctx.fillRect(x + s, y + 16*s, 5*s, 8*s);

        // SHOES from behind
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(x - 6*s, y + 24*s, 6*s, 2*s);
        ctx.fillRect(x + s, y + 24*s, 6*s, 2*s);

        // HEAD from behind - bald head (same size as front view)
        ctx.fillStyle = weatheredSkin;
        ctx.fillRect(x - 6*s, y - 13*s, 12*s, 14*s);

        // Gray hair on back/sides of head
        ctx.fillStyle = '#6b6b6b';
        ctx.fillRect(x - 6*s, y - 13*s, 12*s, 3*s);
        ctx.fillRect(x - 7*s, y - 11*s, 2*s, 4*s);
        ctx.fillRect(x + 5*s, y - 11*s, 2*s, 4*s);

        // Bald shine on top/back
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(x - 3*s, y - 11*s, 6*s, 3*s);

        // Drink in raised right hand
        if(ceo.hasDrink) {
            const glassX = x + 10*s;
            const glassY = y - 2*s;

            // Crystal glass
            ctx.fillStyle = 'rgba(200,220,255,0.4)';
            ctx.beginPath();
            ctx.moveTo(glassX - 3, glassY);
            ctx.lineTo(glassX + 3, glassY);
            ctx.lineTo(glassX + 2, glassY + 10);
            ctx.lineTo(glassX - 2, glassY + 10);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Brandy liquid
            ctx.fillStyle = 'rgba(139,69,19,0.7)';
            ctx.fillRect(glassX - 2, glassY + 5, 4, 4);
        }
    }

    if(ceo.hasDrink && ceo.state === 'offering') {
        const glassX = x + (facing === 'right' ? 20 : -20);
        const glassY = y;
        
        ctx.fillStyle = 'rgba(200,200,255,0.4)';
        ctx.beginPath();
        ctx.moveTo(glassX - 4, glassY);
        ctx.lineTo(glassX + 4, glassY);
        ctx.lineTo(glassX + 3, glassY + 12);
        ctx.lineTo(glassX - 3, glassY + 12);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(139,69,19,0.7)';
        ctx.fillRect(glassX - 3, glassY + 6, 6, 5);
    }
    
    if(ceo.state === 'offering') {
        const sackX = x + (facing === 'left' ? 20 : -20);
        const sackY = y + 5;
        
        ctx.fillStyle = '#27ae60';
        ctx.beginPath();
        ctx.arc(sackX, sackY, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#1e8449';
        ctx.fillRect(sackX - 3, sackY - 8, 6, 4);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('$', sackX, sackY + 3);
    }

    // CEO holding gun when in hunting mode
    if(ceo.state === 'hunting') {
        const s = 2;
        const armOffsetX = facing === 'left' ? -14 : facing === 'right' ? 14 : 0;
        const gunArmX = x + armOffsetX;
        const gunArmY = y - 5;

        // Outstretched arm
        ctx.fillStyle = '#2b2b2b';
        if(facing === 'left') {
            ctx.fillRect(gunArmX, gunArmY, 8, 4*s);
        } else if(facing === 'right') {
            ctx.fillRect(gunArmX - 8, gunArmY, 8, 4*s);
        } else {
            ctx.fillRect(gunArmX - 3, gunArmY, 6, 4*s);
        }

        // Hand holding gun
        ctx.fillStyle = '#d4a882';
        if(facing === 'left') {
            ctx.fillRect(gunArmX, gunArmY + 3, 5, 5);
        } else if(facing === 'right') {
            ctx.fillRect(gunArmX - 5, gunArmY + 3, 5, 5);
        } else {
            ctx.fillRect(gunArmX - 2, gunArmY + 5, 5, 5);
        }

        // Simple revolver in hand
        const gunOffsetX = facing === 'left' ? -20 : facing === 'right' ? 20 : 2;
        const rX = x + gunOffsetX;
        const rY = y - 2;

        // Gun barrel
        ctx.fillStyle = '#4a4a4a';
        if(facing === 'left') {
            ctx.fillRect(rX - 12, rY, 14, 4);
        } else if(facing === 'right') {
            ctx.fillRect(rX - 2, rY, 14, 4);
        } else {
            ctx.fillRect(rX, rY, 10, 3);
        }

        // Gun cylinder
        ctx.fillStyle = '#5a5a5a';
        ctx.beginPath();
        ctx.arc(facing === 'left' ? rX - 2 : facing === 'right' ? rX : rX + 4, rY + 2, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawDeadCEO(x, y) {
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 10, 30, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    const weatheredSkin = '#c49872';

    // Dead CEO lying on ground horizontally (similar to detective)
    // Body positioned horizontally, head to the left, feet to the right

    // Small blood pool
    ctx.fillStyle = '#6b0000';
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.ellipse(x, y + 2, 40, 18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Back/far leg
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 6*s, y - 2*s, 16*s, 4*s);
    ctx.fillRect(x + 20*s, y - 3*s, 14*s, 4*s);

    // Back shoe
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x + 33*s, y - 4*s, 5*s, 4*s);

    // Left arm along body
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x - 10*s, y - 8*s, 12*s, 3*s);
    ctx.fillStyle = weatheredSkin;
    ctx.fillRect(x - 11*s, y - 9*s, 3*s, 3*s);

    // HEAD lying flat
    ctx.fillStyle = weatheredSkin;
    ctx.fillRect(x - 18*s, y - 16*s, 10*s, 11*s);

    // Gray hair
    ctx.fillStyle = '#6b6b6b';
    ctx.fillRect(x - 18*s, y - 17*s, 10*s, 4*s);
    ctx.fillRect(x - 19*s, y - 14*s, 2*s, 6*s);
    ctx.fillRect(x - 8*s, y - 14*s, 2*s, 6*s);

    // Closed eyes (dead)
    ctx.fillStyle = '#000';
    ctx.fillRect(x - 16*s, y - 12*s, 2*s, 1);
    ctx.fillRect(x - 11*s, y - 12*s, 2*s, 1);

    // Nose
    ctx.fillStyle = '#b88a62';
    ctx.fillRect(x - 14*s, y - 10*s, 3*s, 2*s);

    // Cigar fallen from mouth
    ctx.save();
    ctx.translate(x - 12, y - 4);
    ctx.rotate(0.5);
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(0, 0, 14, 2);
    ctx.fillStyle = '#654321';
    ctx.fillRect(13, 0, 1, 2);
    ctx.restore();

    // Neck
    ctx.fillStyle = weatheredSkin;
    ctx.fillRect(x - 10*s, y - 8*s, 5*s, 4*s);

    // TORSO lying flat
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x - 8*s, y - 14*s, 20*s, 14*s);

    // Suit jacket details
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 8*s, y - 14*s, 4*s, 10*s);
    ctx.fillRect(x - 8*s, y - 14*s, 4*s, 10*s);

    // White shirt
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(x - 4*s, y - 12*s, 8*s, 3*s);

    // Dark red tie
    ctx.fillStyle = '#8b0000';
    ctx.fillRect(x - 2*s, y - 11*s, 4*s, 10*s);

    // Bullet holes in torso (6 holes)
    for(let i = 0; i < 6; i++) {
        const row = Math.floor(i / 3);
        const col = i % 3;
        const holeX = x - 4*s + col * 4*s;
        const holeY = y - 10*s + row * 5*s;

        ctx.fillStyle = '#660000';
        ctx.beginPath();
        ctx.arc(holeX, holeY, 2.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#330000';
        ctx.beginPath();
        ctx.arc(holeX, holeY, 1, 0, Math.PI * 2);
        ctx.fill();
    }

    // Front/near leg
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 6*s, y - 1*s, 16*s, 4*s);
    ctx.fillRect(x + 20*s, y - 2*s, 14*s, 4*s);

    // Front shoe
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x + 33*s, y - 2*s, 5*s, 4*s);

    // Right arm extended
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x + 10*s, y - 10*s, 3*s, 8*s);
    ctx.fillStyle = weatheredSkin;
    ctx.fillRect(x + 10*s, y - 12*s, 4*s, 4*s);
}

function drawPortraitUI() {
    // Full-screen dark overlay
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

    // Display the portrait image (already includes ornate frame)
    if(portraitImg.complete && portraitImg.naturalWidth > 0) {
        const portraitW = 560;
        const portraitH = 460;
        const portraitX = (700 - portraitW) / 2;
        const portraitY = (500 - portraitH) / 2 - 10;

        ctx.drawImage(portraitImg, portraitX, portraitY, portraitW, portraitH);
    }

    // Close instruction
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PRESS ACTION TO CLOSE', 350, 485);
}



function drawMuteIndicator() {
    // Position at top-right of canvas, just below HUD — outside game area in landscape
    const btnX = -GX + CANVAS_W - 90;
    const btnY = -GY + 5;
    const btnW = 80;
    const btnH = 50;
    const cx = btnX + btnW / 2;
    const cy = btnY + btnH / 2;

    // Background
    ctx.fillStyle = musicMuted ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(btnX, btnY, btnW, btnH);
    ctx.strokeStyle = musicMuted ? '#ff4444' : '#4a4a4a';
    ctx.lineWidth = 2;
    ctx.strokeRect(btnX, btnY, btnW, btnH);

    // Draw speaker body (works on all platforms, no emoji)
    const color = musicMuted ? '#ff4444' : '#27ae60';
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.rect(cx - 16, cy - 6, 10, 12);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(cx - 6, cy - 6);
    ctx.lineTo(cx + 4, cy - 14);
    ctx.lineTo(cx + 4, cy + 14);
    ctx.lineTo(cx - 6, cy + 6);
    ctx.closePath();
    ctx.fill();

    if(musicMuted) {
        // Draw X over speaker
        ctx.beginPath();
        ctx.moveTo(cx + 10, cy - 8);
        ctx.lineTo(cx + 24, cy + 8);
        ctx.moveTo(cx + 24, cy - 8);
        ctx.lineTo(cx + 10, cy + 8);
        ctx.stroke();
    } else {
        // Draw sound waves
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx + 8, cy, 8, -Math.PI / 4, Math.PI / 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx + 8, cy, 15, -Math.PI / 4, Math.PI / 4);
        ctx.stroke();
    }
}

function drawScene() {
    // Clear full expanded canvas and translate to center game area
    ctx.save();
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.translate(GX, GY);

    // RT Games Presents Screen
    if(state === 'rtPresents') {
        // Elegant black background
        ctx.fillStyle = '#000000';
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

        // Fade-in effect
        const alpha = Math.min(1, frame / 60); // Fade in over 1 second
        ctx.globalAlpha = alpha;

        // Draw mullet logo centered
        if(mulletLogoImg.complete && mulletLogoImg.naturalWidth > 0) {
            const logoSize = 200;
            const logoX = (700 - logoSize) / 2;
            const logoY = 120;
            ctx.drawImage(mulletLogoImg, logoX, logoY, logoSize, logoSize);
        }

        // "presents..." text with Playfair Display font
        ctx.fillStyle = '#ffffff';
        ctx.font = 'italic 36px "Playfair Display", serif';
        ctx.textAlign = 'center';
        ctx.fillText('presents...', 350, 370);

        ctx.globalAlpha = 1;

        // Blinking "Press any button" instruction with retro arcade font
        if(Math.floor(frame / 30) % 2 === 0 && frame > 60) {
            ctx.fillStyle = '#ffd700';
            ctx.font = '16px "Press Start 2P", monospace';
            ctx.fillText('PRESS ANY BUTTON', 350, 440);
        }

        ctx.restore(); return;
    }

    // Concept Art Screen
    if(state === 'conceptArt') {
        // Display the Mullet Pro concept art
        if(conceptArtImg.complete && conceptArtImg.naturalWidth > 0) {
            ctx.drawImage(conceptArtImg, 0, 0, 700, 500);
        } else {
            // Fallback gradient if image not loaded
            const bgGrad = ctx.createLinearGradient(0, 0, 0, 500);
            bgGrad.addColorStop(0, '#1a0a2e');
            bgGrad.addColorStop(0.5, '#ff6b35');
            bgGrad.addColorStop(1, '#1a0a2e');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

            // Fallback text
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 6;
            ctx.strokeText('MULLET PRO', 350, 250);
            ctx.fillText('MULLET PRO', 350, 250);
        }

        // Blinking continue instruction
        if(Math.floor(frame / 30) % 2 === 0) {
            // Semi-transparent bar for readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-GX, 430, CANVAS_W, CANVAS_H);

            ctx.fillStyle = '#ffd700';
            ctx.font = '14px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('ANY BUTTON TO CONTINUE', 350, 462);
            ctx.fillText('ANY BUTTON TO CONTINUE', 350, 462);
        }

        ctx.restore(); return;
    }

    if(state === 'menu') {
        // Photorealistic title screen - "Mullet Pro" cover art
        if(titleScreenImg.complete && titleScreenImg.naturalWidth > 0) {
            // Draw the image to fill the entire canvas
            ctx.drawImage(titleScreenImg, 0, 0, 700, 500);
        } else {
            // Noir industrial prison aesthetic - minimal and visual
            // Dark film noir gradient background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, 500);
            bgGrad.addColorStop(0, '#0a0a0a');
            bgGrad.addColorStop(0.5, '#1a1a1a');
            bgGrad.addColorStop(1, '#0f0f0f');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

            // Industrial pipe prison bars - vertical pipes creating dramatic prison aesthetic
            ctx.globalAlpha = 0.5;
            const pipeSpacing = 100;
            for(let i = 0; i < 8; i++) {
                const pipeX = i * pipeSpacing;
                const colorIndex = i % 4;

                // Dark metallic pipe body
                ctx.fillStyle = COLORS[colorIndex].hex;
                ctx.fillRect(pipeX, 0, 25, 500);

                // Metallic highlight on left edge
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.fillRect(pipeX, 0, 8, 500);

                // Deep shadow on right edge
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(pipeX + 20, 0, 5, 500);
            }
            ctx.globalAlpha = 1.0;

            // Dramatic title - centered
            const textGrad = ctx.createLinearGradient(200, 200, 500, 260);
            textGrad.addColorStop(0, '#ff6b35');
            textGrad.addColorStop(0.5, '#f7931e');
            textGrad.addColorStop(1, '#ffd700');

            ctx.font = 'bold 84px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 10;
            ctx.strokeText('MULLET PRO', 350, 250);
            ctx.fillStyle = textGrad;
            ctx.fillText('MULLET PRO', 350, 250);
        }

        // Blinking call-to-action overlay with retro arcade font
        if(Math.floor(frame / 30) % 2 === 0) {
            // Semi-transparent black bar behind text for better readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-GX, 430, CANVAS_W, CANVAS_H);

            // Blinking text with arcade font
            ctx.fillStyle = '#ffd700';
            ctx.font = '16px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('PRESS ANY BUTTON', 350, 462);
            ctx.fillText('PRESS ANY BUTTON', 350, 462);
        }

        // Draw mute indicator
        drawMuteIndicator();

        // Draw prominent "TAP TO START" overlay if audio not unlocked
        if(!audioUnlocked) {
            // Semi-transparent dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

            // Pulsing "TAP TO START" message with retro arcade font
            const pulseAlpha = 0.7 + Math.sin(Date.now() / 400) * 0.3;
            ctx.globalAlpha = pulseAlpha;

            // Outer glow
            ctx.fillStyle = '#ffd700';
            ctx.font = '32px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30;
            ctx.fillText('TAP TO START', 350, 220);
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;

            // Instruction text
            ctx.fillStyle = '#f5f2ec';
            ctx.font = '14px "Press Start 2P", monospace';
            ctx.fillText('CLICK OR TAP', 350, 280);
            ctx.fillText('TO ENABLE SOUND', 350, 310);

            // Speaker icon
            ctx.font = 'bold 72px Arial';
            ctx.fillText('🔊', 350, 400);
        }

        ctx.restore(); return;
    }

    if(state === 'levelCard') {
        ctx.fillStyle = '#000000';
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

        const lvlGrad = ctx.createLinearGradient(200, 150, 500, 250);
        lvlGrad.addColorStop(0, '#ff6b35');
        lvlGrad.addColorStop(1, '#ffd700');

        ctx.font = 'bold 80px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.strokeText('LEVEL ' + level, 350, 200);
        ctx.fillStyle = lvlGrad;
        ctx.fillText('LEVEL ' + level, 350, 200);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 32px Arial';
        const msgs = ['', 'TRAINING DAY', 'PRESSURE RISING!', 'MAXIMUM CHAOS!', '3D PRINTER UNLOCKED!', 'MANAGEMENT', 'THE CEO WANTS TO MEET YOU'];
        ctx.fillText(msgs[level], 350, 270);

        if(cardTimer > 60) {
            if(Math.floor(frame / 30) % 2 === 0) {
                ctx.fillStyle = '#ffd700';
                ctx.font = '20px "Press Start 2P", monospace';
                ctx.fillText('GET READY!', 350, 370);
            }
        }

        // Draw mute indicator on level cards
        drawMuteIndicator();
        ctx.restore(); return;
    }

    if(state === 'promotion') {
        ctx.fillStyle = '#000000';
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

        const promoGrad = ctx.createLinearGradient(200, 100, 500, 200);
        promoGrad.addColorStop(0, '#ffd700');
        promoGrad.addColorStop(1, '#ff6b35');

        ctx.font = 'bold 56px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.strokeText('CONGRATS!', 350, 150);
        ctx.fillStyle = promoGrad;
        ctx.fillText('CONGRATS!', 350, 150);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 36px Arial';
        ctx.fillText('YOU ARE THE NEW', 350, 220);

        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 48px Arial';
        ctx.fillText('PIPE BOSS', 350, 280);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = '32px Arial';
        ctx.fillText('FINAL SCORE: ' + score, 350, 340);

        if(Math.floor(frame / 30) % 2 === 0) {
            ctx.fillStyle = '#ffd700';
            ctx.font = '14px "Press Start 2P", monospace';
            ctx.fillText('PRESS ANY BUTTON TO CONTINUE', 350, 420);
        }

        // Draw mute indicator on promotion screen
        drawMuteIndicator();
        ctx.restore(); return;
    }

    if(state === 'over' || state === 'win' || state === 'theend' || state === 'victory' || state === 'fired' || state === 'gameover') {
        ctx.fillStyle = '#000000';
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);

        if(state === 'over') {
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("YOU'RE FIRED!", 350, 180);
        } else if(state === 'fired') {
            // Level 5: Killed yourself in furnace
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("YOU'RE FIRED!", 350, 180);
        } else if(state === 'gameover') {
            // Level 5: Didn't burn 6 documents in time
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("GAME OVER", 350, 180);
        } else if(state === 'win') {
            ctx.fillStyle = '#27ae60';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("YOU'RE HIRED!", 350, 180);
        } else if(state === 'theend') {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 8;
            ctx.strokeText('THE END', 350, 200);
            ctx.fillStyle = '#ffd700';
            ctx.fillText('THE END', 350, 200);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = '28px Arial';
            ctx.fillText('Documents Destroyed: ' + level5.docsCollected, 350, 270);
        } else if(state === 'victory') {
            // Simplified victory screen - less crowded
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 8;
            ctx.strokeText('YOU WIN!', 350, 220);
            ctx.fillStyle = '#27ae60';
            ctx.fillText('YOU WIN!', 350, 220);
        }
        
        if(state !== 'victory' && state !== 'theend' && state !== 'gameover' && state !== 'fired') {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('FINAL SCORE: ' + score, 350, 240);
        }

        ctx.font = '24px Arial';
        const yOffset = (state === 'theend' || state === 'victory' || state === 'gameover' || state === 'fired') ? 350 : 320;

        if(state === 'victory') {
            // Victory screen: only "Play again?"
            ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
            ctx.fillText('▶ Play again?', 350, yOffset);
        } else if(state === 'theend') {
            // The End screen: "Start over?" and "Visit Mullet.pro"
            ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
            ctx.fillText('▶ Start over?', 350, yOffset);
            ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
            ctx.fillText('▶ Visit Mullet.pro', 350, yOffset + 50);
        } else if(state === 'gameover' || state === 'fired') {
            // Level 5 failure screens: "Keep documenting!" and "Visit Mullet.pro"
            ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
            ctx.fillText('▶ Keep documenting!', 350, yOffset);
            ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
            ctx.fillText('▶ Visit Mullet.pro', 350, yOffset + 50);
        } else {
            // Regular end screens (over, win): "Keep documenting!" and "Visit Mullet.pro"
            ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
            ctx.fillText('▶ Keep documenting!', 350, yOffset);
            ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
            ctx.fillText('▶ Visit Mullet.pro', 350, yOffset + 50);
        }

        // Draw mute indicator on end screens
        drawMuteIndicator();
        ctx.restore(); return;
    }

    if(level === 5) {
    if(level5.room === 'pipeRoom') {
        drawLevel5PipeRoom();
    } else if(level5.room === 'hallway') {
        drawLevel5Hallway();
    } else if(level5.room === 'furnaceRoom') {
        drawLevel5FurnaceRoom();
    } else if(level5.currentOffice) {
        drawOfficeRoom(level5.currentOffice);
    }
    
    if(level5.viewingEmail && level5.currentOffice) {
        drawEmailUI(level5.currentOffice);
    } else if(level5.viewingLetter) {
        drawLetterUI();
    } else if(level5.viewingPortrait) {
        drawPortraitUI();
    }

    if(!level5.viewingEmail && !level5.viewingLetter && !level5.viewingPortrait) {
        drawBaldManager(player.x, player.y, player.facing, player.holding);

        if(player.holding) {
            drawHeldDoc(player.x, player.y, player.holding);
        }
    }
    
    if(fadeAlpha > 0) {
        ctx.fillStyle = `rgba(232,230,220,${fadeAlpha})`;
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    }

    // Draw mute indicator for level 5
    drawMuteIndicator();
    ctx.restore(); return;
    }

    if(level === 6) {
        const l6HasGun = level6.hasRevolver && level6.revolverAmmo > 0;
        if(level6.room === 'pipeRoom') {
            drawLevel6PipeRoom();

            // Draw player in pipe room
            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'megacomputer') {
            drawLevel6MegacomputerRoom();

            // Draw player in megacomputer room
            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'entryway') {
            drawLevel6Entryway();

            // Draw player in entryway
            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'employeeLobby') {
            drawLevel6EmployeeLobby();

            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'cloningRoom') {
            drawLevel6CloningRoom();

            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'l6Furnace') {
            drawL6FurnaceRoom();

            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'employeeHallway') {
            drawLevel5Hallway();

            // Direction prompts for L6 revisit — auto transitions
            if(player.x < 80) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, 310, 120, 20);
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('\u2190 PIPE ROOM', 70, 326);
            }
            if(player.x > 600) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(600, 310, 100, 20);
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('FURNACE \u2192', 650, 326);
            }

            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'employeePipeRoom') {
            drawLevel5PipeRoom();

            if(player.x > 600) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(600, 310, 100, 20);
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('HALLWAY \u2192', 650, 326);
            }

            drawBaldManager(player.x, player.y, player.facing, player.holding, l6HasGun);
            if(l6HasGun) { drawRevolver(player.x, player.y, player.facing); drawAmmoCounter(player.x, player.y, level6.revolverAmmo); }
        } else if(level6.room === 'ceoOffice') {
            drawLevel6CEOOffice();

            if(ceo.state !== 'dead') {
                drawCEO(ceo.x, ceo.y, ceo.facing);
            } else {
                // Draw dead CEO body on ground
                drawDeadCEO(ceo.x, ceo.y);
            }

            for(let npc of level6.exitingNPCs) {
                if(npc.isMulletPro) {
                    drawMulletPro(npc.x, npc.y, npc.facing, false);
                } else {
                    const tempNPC = {
                        x: npc.x,
                        y: npc.y,
                        color: npc.color,
                        state: 'happy',
                        needsDoc: false
                    };
                    drawNPC(tempNPC);
                }
            }

            // Draw player in CEO office (unless in UI mode, but always during exit sequence)
            const shouldDrawPlayer = (!level6.safeUI && !level6.computerUI) || level6.npcExitSequence;
            if(shouldDrawPlayer && !level6.endingTriggered) {
                const hasGun = level6.hasRevolver && level6.revolverAmmo > 0;
                drawBaldManager(player.x, player.y, player.facing, player.holding, hasGun);

                if(hasGun) {
                    drawRevolver(player.x, player.y, player.facing);
                    drawAmmoCounter(player.x, player.y, level6.revolverAmmo);
                }
            }
        }

        if(level6.safeUI) {
            drawSafeUI();
        }

        if(level6.keypadUI) {
            drawKeypadUI();
        }

        if(level6.elevatorUI) {
            drawElevatorUI();
        }

        // Elevator fade-to-black transition (both fade-out and fade-in)
        if(level6.elevatorTransition || level6.elevatorFadeIn) {
            ctx.fillStyle = `rgba(0,0,0,${level6.elevatorFadeAlpha})`;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
        }

        // Detective hat dissolve transition + title card
        if(level6.detectiveTransition || level6.detectiveFadeIn) {
            ctx.fillStyle = `rgba(0,0,0,${level6.detectiveTransAlpha})`;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
        }
        if(level6.detectiveTitleCard) {
            ctx.fillStyle = '#000';
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
            // Title card text
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('You are now', 350, 200);
            ctx.fillText('the detective!', 350, 260);
            // Fedora icon
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.ellipse(350, 330, 40, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.moveTo(320, 330);
            ctx.lineTo(330, 305);
            ctx.lineTo(345, 315);
            ctx.lineTo(355, 315);
            ctx.lineTo(370, 305);
            ctx.lineTo(380, 330);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(325, 327, 50, 4);
        }

        // Case Closed dissolve transition + title card
        if(level6.caseClosedCard === 'fading') {
            ctx.fillStyle = `rgba(0,0,0,${level6.detectiveTransAlpha})`;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
        }
        if(level6.caseClosedCard === true) {
            ctx.fillStyle = '#000';
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
            // "Case Closed." title
            ctx.fillStyle = '#cc0000';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Case Closed.', 350, 230);
            // Subtle gold underline
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(200, 248, 300, 3);
            // Fedora silhouette
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(350, 320, 35, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.moveTo(325, 320);
            ctx.lineTo(332, 298);
            ctx.lineTo(345, 308);
            ctx.lineTo(355, 308);
            ctx.lineTo(368, 298);
            ctx.lineTo(375, 320);
            ctx.closePath();
            ctx.fill();
            // Score
            if(level6.caseClosedTimer > 60) {
                ctx.fillStyle = '#888';
                ctx.font = '24px Arial';
                ctx.fillText('FINAL SCORE: ' + score, 350, 380);
            }
        }

        if(level6.computerUI) {
            drawComputerUI();
        }

        if(level6.viewingDetectiveNote) {
            drawDetectiveNoteUI();
        }

        for(let bullet of bullets) {
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        if(fadeAlpha > 0) {
            ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
            ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
        }

        // Draw mute indicator for level 6
        drawMuteIndicator();
        ctx.restore(); return;
    }


    // Levels 1-4 standard pipe room
    ctx.fillStyle = '#e8e6dc';
    ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    
    ctx.fillStyle = '#808080';
    ctx.fillRect(-GX, 400, CANVAS_W, CANVAS_H);
    
    for(let i = -4; i < 24; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }
    
    ctx.fillStyle = '#f5f5dc';
    ctx.globalAlpha = 0.3;
    ctx.fillRect(100, 20, 80, 10);
    ctx.fillRect(300, 20, 80, 10);
    ctx.fillRect(500, 20, 80, 10);
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#7a7a7a';
    ctx.fillRect(20, 30, 220, 110);
    ctx.fillStyle = '#6a6a6a';
    ctx.fillRect(25, 35, 210, 100);
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(28, 38, 204, 94);
    
    for(let bx = 0; bx < 2; bx++) {
        for(let by = 0; by < 2; by++) {
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.arc(35 + bx * 190, 45 + by * 80, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8a8a8a';
            ctx.beginPath();
            ctx.arc(34 + bx * 190, 44 + by * 80, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 130, 75);
    
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(50, 82, 160, 1);
    
    ctx.fillStyle = '#d0d0d0';
    ctx.font = '10px Arial';
    ctx.fillText('GLOBAL LEADER IN PIPE DREAMS', 130, 97);
    
    for(let i = 0; i < 4; i++) {
        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(50, 105 + i * 5, 160, 3);
    }
    
    ctx.fillStyle = '#c4bfad';
    ctx.fillRect(-GX, 410, CANVAS_W, CANVAS_H);
    
    drawComputer(computer.x, computer.y);
    
    if(level === 4) {
        draw3DPrinter(printer3d.x, printer3d.y);
    }

    // Right wall gasket + boss door BEFORE pipes so gasket renders behind
    drawPipeRoomRightWall(265);

    for(let npc of npcs) {
        const pipeY = 240;

        // Wall gasket at top - curved mount with round bolted bevel (matching level 6)
        // Outer bevel ring (mounted in wall)
        ctx.fillStyle = '#999';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 18, 0, Math.PI * 2);
        ctx.fill();

        // Inner gasket plate (recessed)
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 14, 0, Math.PI * 2);
        ctx.fill();

        // Center pipe opening
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(npc.x, 54, 8, 0, Math.PI * 2);
        ctx.fill();

        // Round bolts around the bevel (6 bolts evenly spaced)
        for(let b = 0; b < 6; b++) {
            const angle = (b / 6) * Math.PI * 2;
            const boltX = npc.x + Math.cos(angle) * 12;
            const boltY = 54 + Math.sin(angle) * 12;

            // Bolt head
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Bolt shadow/depth
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(boltX, boltY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pipe starts from inner gasket opening (56) not outer edge (58)
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(npc.x, 56);
        ctx.lineTo(npc.x, pipeY);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(npc.x - 4, 56);
        ctx.lineTo(npc.x - 4, pipeY);
        ctx.stroke();

        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(npc.x, pipeY);
        ctx.quadraticCurveTo(npc.x, pipeY + 25, npc.x + 25, pipeY + 25);
        ctx.lineTo(694, pipeY + 25);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(npc.x + 21, pipeY + 25);
        ctx.lineTo(694, pipeY + 25);
        ctx.stroke();

        const crack = cracks.find(c => c.npc === npc);
        if(crack && !resetting) {
            const pct = (Date.now() - crack.time) / crack.max;
            ctx.fillStyle = npc.color.hex;
            ctx.globalAlpha = 0.4 + pct * 0.6;
            const sz = 18 + pct * 28;
            for(let i = 0; i < 3; i++) {
                ctx.fillRect(npc.x - sz / 2 + (i - 1) * 5, pipeY - 40 + i * 8, sz, 8);
            }
            ctx.globalAlpha = 1;
        }
        
        drawNPC(npc);
    }

    for(let exp of explosions) {
        ctx.fillStyle = `rgba(255,100,0,${exp.alpha})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255,200,0,${exp.alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        for(let p of exp.particles) {
            ctx.fillStyle = `rgba(100,100,100,${p.life})`;
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        }
    }
    
    for(let mf of muzzleFlashes) {
        const flashX = mf.facing === 'left' ? mf.x - 30 : mf.x + 30;
        ctx.fillStyle = `rgba(255,200,0,${mf.life / 10})`;
        ctx.beginPath();
        ctx.arc(flashX, mf.y, 8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255,255,100,${mf.life / 10})`;
        ctx.beginPath();
        ctx.arc(flashX, mf.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    for(let bullet of bullets) {
        ctx.fillStyle = '#ffff00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    
    if(boss.active) {
        drawBoss(boss.x, boss.y, boss.facing);
    }

    const hasGhostGun = ghostGun.hasGun && ghostGun.ammo > 0;
    drawMulletPro(player.x, player.y, player.facing, player.holding, hasGhostGun);

    if(player.holding) {
        drawHeldDoc(player.x, player.y, player.holding);
    }

    if(hasGhostGun) {
        drawGhostGun(player.x, player.y, player.facing);
        drawAmmoCounter(player.x, player.y, ghostGun.ammo);
    }

    if(ui.show) {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(-GX, 340, CANVAS_W, CANVAS_H);
        
        if(!ui.confirming) {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('SELECT COLOR:', 30, 375);
            
            for(let i = 0; i < 4; i++) {
                const selected = i === ui.selectedColor;
                ctx.strokeStyle = selected ? '#f5f2ec' : '#666';
                ctx.lineWidth = selected ? 4 : 2;
                ctx.fillStyle = COLORS[i].hex;
                ctx.fillRect(30 + i * 160, 390, 140, 70);
                ctx.strokeRect(30 + i * 160, 390, 140, 70);
                ctx.fillStyle = '#2b2b2b';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(COLORS[i].name, 100 + i * 160, 430);
            }
        } else {
            const col = COLORS[ui.selectedColor];
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PRINT ' + col.name + ' DOC?', 350, 385);
            ctx.fillStyle = col.hex;
            ctx.fillRect(270, 410, 160, 60);
            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('CONFIRM', 350, 445);
        }
    }
    
    if(ui.gunUI) {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(-GX, 340, CANVAS_W, CANVAS_H);
        
        if(!ui.confirming) {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('SELECT ITEM:', 30, 375);
            
            const gunSelected = ui.gunChoice === 0;
            ctx.strokeStyle = gunSelected ? '#f5f2ec' : '#666';
            ctx.lineWidth = gunSelected ? 4 : 2;
            ctx.fillStyle = '#888';
            ctx.fillRect(30, 390, 140, 70);
            ctx.strokeRect(30, 390, 140, 70);
            
            // Ghost gun with handle down and barrel right
            ctx.fillStyle = '#666';
            // Barrel pointing right
            ctx.fillRect(68, 410, 30, 8);
            // Slide/top
            ctx.fillStyle = '#555';
            ctx.fillRect(68, 408, 30, 2);
            // Handle pointing down
            ctx.fillStyle = '#666';
            ctx.fillRect(70, 418, 8, 16);
            // Trigger guard and trigger
            ctx.fillStyle = '#555';
            ctx.fillRect(78, 418, 6, 2);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GHOST GUN', 100, 455);
            
            const heartSelected = ui.gunChoice === 1;
            ctx.strokeStyle = heartSelected ? '#f5f2ec' : '#666';
            ctx.lineWidth = heartSelected ? 4 : 2;
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(190, 390, 140, 70);
            ctx.strokeRect(190, 390, 140, 70);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('♥', 260, 435);
            
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('HEART', 260, 455);
            
        } else {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            const itemName = ui.gunChoice === 0 ? 'GHOST GUN' : 'HEART';
            ctx.fillText('PRINT ' + itemName + '?', 350, 385);
            ctx.fillStyle = ui.gunChoice === 0 ? '#888' : '#e74c3c';
            ctx.fillRect(270, 410, 160, 60);
            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('CONFIRM', 350, 445);
        }
    }
    
    if(fadeAlpha > 0) {
        ctx.fillStyle = `rgba(232,230,220,${fadeAlpha})`;
        ctx.fillRect(-GX, -GY, CANVAS_W, CANVAS_H);
    }

    // Draw mute indicator (always on top during gameplay)
    if(state === 'playing') {
        drawMuteIndicator();
    }
    ctx.restore();
}


// SECTION 13: Update Function - Level 5 Logic
function update() {
    // RT Games presents screen - audio is now handled in event handlers for proper autoplay support
    if(state === 'rtPresents') {
        // State transition is now handled in handleRTPresentsInteraction() called from event handlers
        // This ensures audio plays in the synchronous user gesture context
        return;
    }

    // Concept Art screen
    if(state === 'conceptArt') {
        if(keys[' '] || keys['action'] || keys['ArrowUp'] || keys['ArrowDown'] ||
           keys['ArrowLeft'] || keys['ArrowRight'] || keys['up'] || keys['down'] ||
           keys['left'] || keys['right']) {
            state = 'menu';
            frame = 0; // Reset frame counter for menu animations
            keys = {};
        }
        return;
    }

    // Main menu screen - audio is now handled in event handlers for proper autoplay support
    if(state === 'menu') {
        // State transition is now handled in handleMenuInteraction() called from event handlers
        // This ensures audio plays in the synchronous user gesture context
        return;
    }
    
    if(state === 'levelCard') {
        cardTimer++;
        if(cardTimer > 120) {
            state = 'playing';
            if(level !== 5 && level !== 6) {
                spawnCracks();
            }
            // Music is already playing for each level - started when levelCard was shown
            // by startGame() for level 1 or nextLevel() for levels 2-4
            // Resume pending music in case initial playMusic() call failed
            // This won't cause double-play because resumePendingMusic() only plays if pendingMusicKey is set
            resumePendingMusic();
        }
        return;
    }
    
        if(state === 'promotion') {
        if(keys[' '] || keys['action'] || keys['ArrowUp'] || keys['ArrowDown'] ||
           keys['ArrowLeft'] || keys['ArrowRight'] || keys['up'] || keys['down'] ||
           keys['left'] || keys['right']) {
            
            // FIX: Play Level 5 music IMMEDIATELY upon user interaction
            playMusic('level5');

            keys = {};
            level = 5;
            timer = 120; // Level 5 gets 120 seconds
            state = 'levelCard';
            cardTimer = 0;
            initLevel(5);
        }
        return;
    }


    if(state === 'over' || state === 'win' || state === 'theend' || state === 'victory' || state === 'fired' || state === 'gameover') {
        // Victory screen only has one option, limit menuChoice to 0
        const maxChoice = state === 'victory' ? 0 : 1;

        if((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
            menuChoice = 0;
            keys.upProcessed = true;
        }
        if((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
            menuChoice = Math.min(1, maxChoice);
            keys.downProcessed = true;
        }
        if(!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
        if(!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;

        if(keys[' '] || keys['action']) {
            keys[' '] = false;
            keys['action'] = false;
            if(menuChoice === 0) {
                // Option 0: Keep documenting! / Play again? / Start over?
                startGame();
            } else {
                // Option 1: Visit Mullet.pro
                window.location.href = 'https://mullet.pro';
            }
        }
        return;
    }
    
    if(state !== 'playing') return;
    
    if(resetting) {
        if(fadeOut) {
            fadeAlpha += 0.08;
            if(fadeAlpha >= 1) {
                fadeOut = false;
                fadeIn = true;
                initLevel(level);
            }
        }
        if(fadeIn) {
            fadeAlpha -= 0.08;
            if(fadeAlpha <= 0) {
                fadeAlpha = 0;
                fadeIn = false;
                resetting = false;
            }
        }
        return;
    }
    
    // LEVEL 5 LOGIC
    if(level === 5) {
        // Mullet Pro AI
        if(level5.mulletPro.state === 'walkingToComputer') {
            if(Math.abs(level5.mulletPro.x - level5.computer.x) > 5) {
                const direction = level5.mulletPro.x < level5.computer.x ? 1 : -1;
                level5.mulletPro.x += direction * 2;
                level5.mulletPro.facing = direction > 0 ? 'right' : 'left';
            } else {
                level5.mulletPro.hasDoc = true;
                level5.mulletPro.docColor = COLORS[Math.floor(Math.random() * 4)];
                level5.mulletPro.state = 'walkingToNPC';
                const targetNPC = level5.npcPipes.find(n => n.color.name === level5.mulletPro.docColor.name);
                level5.mulletPro.walkTarget = targetNPC;
                level5.mulletPro.facing = 'forward';
            }
        }
        
        if(level5.mulletPro.state === 'walkingToNPC' && level5.mulletPro.walkTarget) {
            if(Math.abs(level5.mulletPro.x - level5.mulletPro.walkTarget.x) > 5) {
                const direction = level5.mulletPro.x < level5.mulletPro.walkTarget.x ? 1 : -1;
                level5.mulletPro.x += direction * 2;
                level5.mulletPro.facing = direction > 0 ? 'right' : 'left';
            } else {
                const targetNPC = level5.mulletPro.walkTarget;
                targetNPC.needsDoc = false;
                targetNPC.crackStartTime = null;
                
                level5.mulletPro.hasDoc = false;
                level5.mulletPro.docColor = null;
                level5.mulletPro.state = 'walkingToComputer';
                level5.mulletPro.walkTarget = null;
                level5.mulletPro.facing = 'forward';
            }
        }
        
        // NPC crack spawning
        for(let npc of level5.npcPipes) {
            if(!npc.needsDoc && Math.random() < 0.0003) {
                npc.needsDoc = true;
                npc.crackStartTime = Date.now();
            }
            
            if(npc.needsDoc && npc.crackStartTime) {
                if(Date.now() - npc.crackStartTime > 15000) {
                    createExplosion(npc.x, 240);
                    npc.needsDoc = false;
                    npc.state = 'happy';
                    npc.crackStartTime = null;
                }
            }
        }
        
                // Handle email scrolling
        if(level5.viewingEmail) {
            if((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
                level5.emailScrollOffset = Math.max(0, level5.emailScrollOffset - 32);
                keys.upProcessed = true;
            }
            if((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
                level5.emailScrollOffset = Math.min(500, level5.emailScrollOffset + 32);
                keys.downProcessed = true;
            }
            if(!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
            if(!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;
    
            if(keys[' '] || keys['action']) {
                level5.viewingEmail = false;
                level5.emailScrollOffset = 0;
                keys[' '] = false;
                keys['action'] = false;
            }
            return;
        }

        if(level5.viewingLetter) {
            // Handle letter scrolling
            if((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
                level5.letterScrollOffset = Math.max(0, level5.letterScrollOffset - 30);
                keys.upProcessed = true;
            }
            if((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
                // Calculate max scroll based on image height (matches drawLetterUI using CANVAS_W/CANVAS_H)
                if(letterImg.complete && letterImg.naturalWidth > 0) {
                    const maxWidth = CANVAS_W;
                    const viewportHeight = CANVAS_H - 45;
                    const scale = maxWidth / letterImg.naturalWidth;
                    const fullHeight = letterImg.naturalHeight * scale;
                    const maxScroll = Math.max(0, fullHeight - viewportHeight);
                    level5.letterScrollOffset = Math.min(maxScroll, level5.letterScrollOffset + 30);
                }
                keys.downProcessed = true;
            }
            if(!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
            if(!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;

            if(keys[' '] || keys['action']) {
                level5.viewingLetter = false;
                level5.letterScrollOffset = 0;
                keys[' '] = false;
                keys['action'] = false;
            }
            return;
        }

        if(level5.viewingPortrait) {
            if(keys[' '] || keys['action']) {
                level5.viewingPortrait = false;
                keys[' '] = false;
                keys['action'] = false;
            }
            return;
        }

        // PIPE ROOM
        if(level5.room === 'pipeRoom') {
            player.y = 380;
            const atMulletPro = Math.abs(player.x - level5.mulletPro.x) < 50;

            // Steal doc from Mullet Pro directly
            if((keys[' '] || keys['action']) && atMulletPro && level5.mulletPro.hasDoc && !player.holding) {
                player.holding = level5.mulletPro.docColor.name;
                level5.mulletPro.hasDoc = false;
                level5.mulletPro.docColor = null;
                level5.mulletPro.state = 'walkingToComputer';
                level5.mulletPro.walkTarget = null;
                level5.mulletPro.facing = 'forward';
                keys[' '] = false;
                keys['action'] = false;
            }

            // Transition to hallway — auto when revisiting from level 6, action-based in normal level 5
            if(level6.cloningDoorUnlocked ? player.x > 660 : (player.x >= 630 && (keys[' '] || keys['action']))) {
                level5.room = 'hallway';
                player.x = 80;
                keys[' '] = false;
                keys['action'] = false;
            }
        }

        // HALLWAY
        else if(level5.room === 'hallway') {
            player.y = 380;

            // Door transitions — auto when revisiting from level 6, action-based in normal level 5
            const fromL6 = level6.cloningDoorUnlocked;
            if(fromL6 ? player.x < 40 : (player.x < 80 && (keys[' '] || keys['action']))) {
                level5.room = 'pipeRoom';
                player.x = 620;
                player.y = 380;
                keys[' '] = false;
                keys['action'] = false;
            }

            if(fromL6 ? player.x > 660 : (player.x > 620 && (keys[' '] || keys['action']))) {
                level5.room = 'furnaceRoom';
                player.x = 80;
                player.y = 380;
                keys[' '] = false;
                keys['action'] = false;
            }

            // Office door interactions - press action in front of door at y=380
            for(let office of level5.hallway.offices) {
                const atOfficeDoor = Math.abs(player.x - office.x) < 40;
                if(atOfficeDoor && (keys[' '] || keys['action'])) {
                    // RED door lock mechanic
                    if(office.name === 'RED' && level5.redDoorLocked) {
                        if(level5.hasRedKey) {
                            // Unlock the door (player must press action again to enter)
                            level5.redDoorLocked = false;
                        }
                        // Don't enter — just show prompt / unlock
                        keys[' '] = false;
                        keys['action'] = false;
                        break;
                    }
                    level5.currentOffice = office.name;
                    level5.room = 'office';
                    player.x = 350;
                    player.y = 400;
                    keys[' '] = false;
                    keys['action'] = false;
                    break;
                }
            }

            // Portrait interaction - press action near portrait (center x=350, top of hallway)
            const nearPortrait = Math.abs(player.x - 350) < 80 && player.y < 320;
            if(nearPortrait && (keys[' '] || keys['action'])) {
                level5.viewingPortrait = true;
                keys[' '] = false;
                keys['action'] = false;
            }
        }

        // OFFICE
        else if(level5.room === 'office' && level5.currentOffice) {
            // Exit office
            if(player.y > 420 && Math.abs(player.x - 350) < 70 && (keys[' '] || keys['action'])) {
                level5.room = 'hallway';
                const office = level5.hallway.offices.find(o => o.name === level5.currentOffice);
                player.x = office.x;
                player.y = 380;
                level5.currentOffice = null;
                keys[' '] = false;
                keys['action'] = false;
            }
    
            // Interact with monitor - expanded range for easier access (center/right position)
            const deskX = 350;
            const deskY = 250;
            const monitorX = deskX + 10;
            if(Math.abs(player.x - monitorX) < 40 && player.y > deskY + 30 && player.y < deskY + 70) {
                if(keys[' '] || keys['action']) {
                    level5.viewingEmail = true;
                    level5.emailScrollOffset = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                }
            }

            // Interact with letter (RED only) - on LEFT side of desk
            const letterX = deskX - 25;
            if(level5.currentOffice === 'RED' && Math.abs(player.x - letterX) < 35 && player.y > deskY + 30 && player.y < deskY + 70) {
                if(keys[' '] || keys['action']) {
                    level5.viewingLetter = true;
                    level5.letterScrollOffset = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                }
            }
    
            // Full 2D movement in office
            const prevX = player.x;
            const prevY = player.y;
    
            if(keys['ArrowLeft'] || keys['left']) {
                player.x = Math.max(40, player.x - 5);
                if(player.x !== prevX) {
                    player.facing = 'left';
                    player.lastMove = Date.now();
                }
            }
            if(keys['ArrowRight'] || keys['right']) {
                player.x = Math.min(660, player.x + 5);
                if(player.x !== prevX) {
                    player.facing = 'right';
                    player.lastMove = Date.now();
                }
            }
            if(keys['ArrowUp'] || keys['up']) {
                player.y = Math.max(100, player.y - 5);
                if(player.y !== prevY) player.lastMove = Date.now();
            }
            if(keys['ArrowDown'] || keys['down']) {
                player.y = Math.min(480, player.y + 5);
                if(player.y !== prevY) player.lastMove = Date.now();
            }

            // Collision with window (top wall)
            if(player.x > 160 && player.x < 540 && player.y < 260) {
                player.x = prevX;
                player.y = prevY;
            }

            // Collision with desk - allow approach from bottom for monitor access
            // Desk top blocking (can't walk through from sides/top)
            if(player.y < deskY + 45) {
                if(player.x > deskX - 70 && player.x < deskX + 70 && player.y > deskY - 30 && player.y < deskY + 45) {
                    player.x = prevX;
                    player.y = prevY;
                }
            }

            // Chair collision - narrower to allow monitor access from sides
            if(player.x > deskX - 20 && player.x < deskX + 20 && player.y > deskY + 50 && player.y < deskY + 100) {
                player.x = prevX;
                player.y = prevY;
            }
    
            if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right'] &&
               !keys['ArrowUp'] && !keys['up'] && !keys['ArrowDown'] && !keys['down']) {
                if(Date.now() - player.lastMove > 200) {
                    player.facing = 'down';
                }
            }
        }


                // FURNACE ROOM
                else if(level5.room === 'furnaceRoom') {
                    player.y = 380;
            
                    const furnace = level5.furnaceRoom.furnace;
                    const leftDoor = level5.furnaceRoom.leftDoor;
            
                    const atFurnace = Math.abs(player.x - furnace.x) < 80;

                    // Pick up golden key from ground
                    const atKey = level5.redKeyOnGround && Math.abs(player.x - furnace.x) < 60;
                    if((keys[' '] || keys['action']) && atKey && !player.holding) {
                        level5.hasRedKey = true;
                        level5.redKeyOnGround = false;
                        keys[' '] = false;
                        keys['action'] = false;
                    }

                    else if((keys[' '] || keys['action']) && atFurnace) {
            if(player.holding) {
                const wasRed = player.holding === 'RED';
                player.holding = null;
                furnace.flameTime = Date.now();
                level5.docsCollected++;

                // Drop golden key on first RED doc burn
                if(wasRed && !level5.redKeyEverDropped) {
                    level5.redKeyEverDropped = true;
                    level5.redKeyOnGround = true;
                }

                if(level5.docsCollected >= 6) {
                    playMusic('level6');

                    level = 6;
                    timer = 180;
                    state = 'levelCard';
                    cardTimer = 0;
                    initLevel(6);

                    keys[' '] = false;
                    keys['action'] = false;
                    return;
                }
            } else {
                // Player walked into furnace without holding document
                furnace.flameTime = Date.now();
                createExplosion(player.x, player.y);
                state = 'fired';
                menuChoice = 0;
            }
            keys[' '] = false;
            keys['action'] = false;
        }

            
                    // Left door to hallway — auto when revisiting from level 6, action-based in normal level 5
                    const atDoor = Math.abs(player.x - (leftDoor.x + 25)) < 50;
                    if(level6.cloningDoorUnlocked ? player.x < 40 : ((keys[' '] || keys['action']) && atDoor)) {
                        level5.room = 'hallway';
                        player.x = 620;
                        player.y = 380;
                        keys[' '] = false;
                        keys['action'] = false;
                    }

                    // Right door — concealed passage to cloning room (once unlocked from other side)
                    const rightDoor = level5.furnaceRoom.rightDoor;
                    const atRightDoor = Math.abs(player.x - (rightDoor.x - 25)) < 50;
                    if(level6.cloningDoorUnlocked && level6.cloningDoorOpen >= 0.8 && atRightDoor && player.x > 600) {
                        level = 6;
                        level6.room = 'cloningRoom';
                        player.x = 80;
                        player.y = 380;
                    }
                }
        
                // Horizontal movement for pipe room, hallway, and furnace room
                if(level5.room === 'pipeRoom' || level5.room === 'hallway' || level5.room === 'furnaceRoom') {
                    player.y = 380;
                    const prevX = player.x;
                    if(keys['ArrowLeft'] || keys['left']) {
                        player.x = Math.max(20, player.x - 5);
                        if(player.x !== prevX) {
                            player.facing = 'left';
                            player.lastMove = Date.now();
                        }
                    }
                    if(keys['ArrowRight'] || keys['right']) {
                        player.x = Math.min(680, player.x + 5);
                        if(player.x !== prevX) {
                            player.facing = 'right';
                            player.lastMove = Date.now();
                        }
                    }
                    if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right']) {
                if(Date.now() - player.lastMove > 200) {
                    player.facing = 'down';
                }
            }
        }

        return;
    }

    // LEVEL 6 LOGIC
    if(level === 6) {
            // Run Mullet Pro AI when revisiting employee pipe room
            if(level6.room === 'employeePipeRoom') {
                if(level5.mulletPro.state === 'walkingToComputer') {
                    if(Math.abs(level5.mulletPro.x - level5.computer.x) > 5) {
                        const direction = level5.mulletPro.x < level5.computer.x ? 1 : -1;
                        level5.mulletPro.x += direction * 2;
                        level5.mulletPro.facing = direction > 0 ? 'right' : 'left';
                    } else {
                        level5.mulletPro.hasDoc = true;
                        level5.mulletPro.docColor = COLORS[Math.floor(Math.random() * 4)];
                        level5.mulletPro.state = 'walkingToNPC';
                        const targetNPC = level5.npcPipes.find(n => n.color.name === level5.mulletPro.docColor.name);
                        level5.mulletPro.walkTarget = targetNPC;
                        level5.mulletPro.facing = 'forward';
                    }
                }
                if(level5.mulletPro.state === 'walkingToNPC' && level5.mulletPro.walkTarget) {
                    if(Math.abs(level5.mulletPro.x - level5.mulletPro.walkTarget.x) > 5) {
                        const direction = level5.mulletPro.x < level5.mulletPro.walkTarget.x ? 1 : -1;
                        level5.mulletPro.x += direction * 2;
                        level5.mulletPro.facing = direction > 0 ? 'right' : 'left';
                    } else {
                        level5.mulletPro.hasDoc = false;
                        level5.mulletPro.docColor = null;
                        level5.mulletPro.state = 'walkingToComputer';
                        level5.mulletPro.walkTarget = null;
                        level5.mulletPro.facing = 'forward';
                    }
                }
            }

            // Handle viewing detective note
            if(level6.viewingDetectiveNote) {
                // Handle note scrolling
                if((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
                    level6.noteScrollOffset = Math.max(0, level6.noteScrollOffset - 30);
                    keys.upProcessed = true;
                }
                if((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
                    // Calculate max scroll based on image height (matches drawDetectiveNoteUI using CANVAS_W/CANVAS_H)
                    if(detectiveNoteImg.complete && detectiveNoteImg.naturalWidth > 0) {
                        const maxWidth = CANVAS_W;
                        const viewportHeight = CANVAS_H - 45;
                        const scale = maxWidth / detectiveNoteImg.naturalWidth;
                        const fullHeight = detectiveNoteImg.naturalHeight * scale;
                        const maxScroll = Math.max(0, fullHeight - viewportHeight);
                        level6.noteScrollOffset = Math.min(maxScroll, level6.noteScrollOffset + 30);
                    }
                    keys.downProcessed = true;
                }
                if(!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
                if(!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;

                if(keys[' '] || keys['action']) {
                    level6.viewingDetectiveNote = false;
                    level6.noteScrollOffset = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                    // Drop pistol near detective after reading note
                    if(!level6.pistol.dropped && !level6.pistol.pickedUp) {
                        level6.pistol.dropped = true;
                        level6.pistol.x = 540;
                        level6.pistol.y = 370;
                    }
                }
                return;
            }

            // Helper function to check if CEO position collides with obstacles
            const ceoCollidesWithObstacle = (x, y) => {
                const deskX = 350, deskY = 250;
                const safeX = 350, safeY = 100;
                const mirrorX = 100, mirrorY = 50;
                const cabinetX = 600, cabinetY = 50;

                // Check desk collision
                if(x > deskX - 90 && x < deskX + 90 && y > deskY - 60 && y < deskY + 50) return true;
                // Check safe collision
                if(x > safeX - 30 && x < safeX + 30 && y > safeY - 10 && y < safeY + 80) return true;
                // Check mirror collision
                if(x > mirrorX - 10 && x < mirrorX + 100 && y < mirrorY + 120) return true;
                // Check trophy collision
                if(x > cabinetX - 10 && x < cabinetX + 110 && y < cabinetY + 130) return true;
                // Check back wall
                if(y < 40) return true;
                return false;
            };

            // CEO AI logic
            if(ceo.state === 'offering') {
                // First walk to middle rug if not there yet
                if(ceo.walkTarget) {
                    const dx = ceo.walkTarget.x - ceo.x;
                    const dy = ceo.walkTarget.y - ceo.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if(dist > 5) {
                        const newX = ceo.x + (dx / dist) * 2;
                        const newY = ceo.y + (dy / dist) * 2;
                        // Only move if not colliding with obstacles
                        if(!ceoCollidesWithObstacle(newX, newY)) {
                            ceo.x = newX;
                            ceo.y = newY;
                        } else {
                            // Try moving around obstacle (prefer horizontal first)
                            const altX = ceo.x + (dx / dist) * 2;
                            if(!ceoCollidesWithObstacle(altX, ceo.y)) {
                                ceo.x = altX;
                            } else {
                                const altY = ceo.y + (dy / dist) * 2;
                                if(!ceoCollidesWithObstacle(ceo.x, altY)) {
                                    ceo.y = altY;
                                }
                            }
                        }
                        ceo.facing = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : 'forward';
                    } else {
                        ceo.walkTarget = null;
                        ceo.facing = 'forward';
                    }
                } else {
                    // Once at rug, follow player horizontally
                    if(Math.abs(ceo.x - player.x) > 60) {
                        const direction = ceo.x < player.x ? 1 : -1;
                        const newX = ceo.x + direction * 1.5;
                        if(!ceoCollidesWithObstacle(newX, ceo.y)) {
                            ceo.x = newX;
                        }
                        ceo.facing = direction > 0 ? 'right' : 'left';
                    } else {
                        ceo.facing = 'forward';
                    }
                }
            }
        
            if(ceo.state === 'admiring') {
                const mirrorX = 100;
                const mirrorTargetX = mirrorX + 50; // Position in front of mirror
                const mirrorTargetY = 180;

                const dx = mirrorTargetX - ceo.x;
                const dy = mirrorTargetY - ceo.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if(dist > 5) {
                    const newX = ceo.x + (dx / dist) * 2;
                    const newY = ceo.y + (dy / dist) * 2;
                    // Navigate around obstacles
                    if(!ceoCollidesWithObstacle(newX, newY)) {
                        ceo.x = newX;
                        ceo.y = newY;
                    } else {
                        // Try moving around obstacle
                        const altX = ceo.x + (dx / dist) * 2;
                        if(!ceoCollidesWithObstacle(altX, ceo.y)) {
                            ceo.x = altX;
                        } else {
                            const altY = ceo.y + (dy / dist) * 2;
                            if(!ceoCollidesWithObstacle(ceo.x, altY)) {
                                ceo.y = altY;
                            }
                        }
                    }
                    ceo.facing = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : 'forward';
                } else {
                    ceo.x = mirrorTargetX;
                    ceo.y = mirrorTargetY;
                    ceo.facing = 'back'; // Face mirror with back to player
                }
            }
        
            if(ceo.state === 'hunting') {
                ceo.moveTimer++;
                const angryMult = level6.ceoAngryMode ? 2 : 1; // 2x speed/aggression as detective

                const dx = player.x - ceo.x;
                const dy = player.y - ceo.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Stop at a safe distance to avoid trapping player (collision range is 40x50)
                if(dist > 60) {
                    const moveSpeed = 2 * angryMult;
                    const newX = ceo.x + (dx / dist) * moveSpeed;
                    const newY = ceo.y + (dy / dist) * moveSpeed;

                    // Navigate around obstacles while chasing
                    if(!ceoCollidesWithObstacle(newX, newY)) {
                        ceo.x = newX;
                        ceo.y = newY;
                    } else {
                        // Try moving around obstacle - prefer direction toward player
                        const altX = ceo.x + (dx / dist) * moveSpeed;
                        if(!ceoCollidesWithObstacle(altX, ceo.y)) {
                            ceo.x = altX;
                        } else {
                            const altY = ceo.y + (dy / dist) * moveSpeed;
                            if(!ceoCollidesWithObstacle(ceo.x, altY)) {
                                ceo.y = altY;
                            }
                        }
                    }

                    if(Math.abs(dx) > Math.abs(dy)) {
                        ceo.facing = dx > 0 ? 'right' : 'left';
                    } else {
                        ceo.facing = 'forward';
                    }
                }

                ceo.shootTimer++;
                const shootThreshold = level6.ceoAngryMode ? 60 : 120;
                const shootCooldown = level6.ceoAngryMode ? 1000 : 2000;
                const bulletSpeed = level6.ceoAngryMode ? 10 : 8;
                if(ceo.shootTimer > shootThreshold && Date.now() - ceo.lastShot > shootCooldown) {
                    const angle = Math.atan2(player.y - ceo.y, player.x - ceo.x);
                    bullets.push({
                        x: ceo.x,
                        y: ceo.y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        fromCEO: true
                    });
                    ceo.lastShot = Date.now();
                    ceo.shootTimer = 0;
                }
            }
        
            if(ceo.blinkTimer > 0) {
                ceo.blinkTimer--;
            }


            // NPC exit sequence
            if(level6.npcExitSequence) {
                level6.npcExitTimer++;
            
                for(let npc of level6.exitingNPCs) {
                    if(!npc.hasSack && !npc.exiting) {
                        let nearestSack = null;
                        let nearestDist = Infinity;

                        for(let sack of level6.cashSacks) {
                            if(!sack.claimed) {
                                const dist = Math.sqrt((npc.x - sack.x)**2 + (npc.y - sack.y)**2);
                                if(dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestSack = sack;
                                }
                            }
                        }

                        if(nearestSack) {
                            const dx = nearestSack.x - npc.x;
                            const dy = nearestSack.y - npc.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // Stuck detection: if not making progress, increment timer
                            if(dist >= npc.lastDist - 0.5) {
                                npc.stuckTimer++;
                            } else {
                                npc.stuckTimer = 0;
                            }
                            npc.lastDist = dist;

                            // If stuck too long, force-claim the sack
                            if(npc.stuckTimer > 180) {
                                npc.hasSack = true;
                                nearestSack.claimed = true;
                                npc.stuckTimer = 0;
                                npc.lastDist = Infinity;
                            } else if(dist > 5) {
                                const speed = 2;
                                const newX = npc.x + (dx / dist) * speed;
                                const newY = npc.y + (dy / dist) * speed;
                                // Navigate around obstacles
                                if(!ceoCollidesWithObstacle(newX, newY)) {
                                    npc.x = newX;
                                    npc.y = newY;
                                } else {
                                    // Try horizontal first
                                    if(!ceoCollidesWithObstacle(newX, npc.y)) {
                                        npc.x = newX;
                                    } else if(!ceoCollidesWithObstacle(npc.x, newY)) {
                                        npc.y = newY;
                                    } else {
                                        // Try perpendicular sidestep to escape
                                        const perpX = npc.x + (dy > 0 ? speed : -speed);
                                        const perpY = npc.y + (dx > 0 ? -speed : speed);
                                        if(!ceoCollidesWithObstacle(perpX, npc.y)) {
                                            npc.x = perpX;
                                        } else if(!ceoCollidesWithObstacle(npc.x, perpY)) {
                                            npc.y = perpY;
                                        }
                                    }
                                }
                                npc.facing = dx > 0 ? 'right' : dx < 0 ? 'left' : 'forward';
                            } else {
                                npc.hasSack = true;
                                nearestSack.claimed = true;
                                npc.stuckTimer = 0;
                                npc.lastDist = Infinity;
                            }
                        }
                    } else if(npc.hasSack && !npc.exiting) {
                        const exitY = 460;
                        const dy = exitY - npc.y;

                        // Stuck detection for exiting phase
                        const exitDist = Math.abs(dy);
                        if(exitDist >= npc.lastDist - 0.5) {
                            npc.stuckTimer++;
                        } else {
                            npc.stuckTimer = 0;
                        }
                        npc.lastDist = exitDist;

                        if(npc.stuckTimer > 120) {
                            // Force exit if stuck
                            npc.exiting = true;
                            npc.stuckTimer = 0;
                        } else if(Math.abs(dy) > 5) {
                            const newY = npc.y + (dy > 0 ? 2 : -2);
                            if(!ceoCollidesWithObstacle(npc.x, newY)) {
                                npc.y = newY;
                            } else {
                                // Sidestep horizontally to get around obstacle
                                const sideDir = npc.x < 350 ? -2 : 2;
                                if(!ceoCollidesWithObstacle(npc.x + sideDir, npc.y)) {
                                    npc.x += sideDir;
                                } else {
                                    npc.x -= sideDir;
                                }
                            }
                            npc.facing = 'forward';
                        } else {
                            npc.exiting = true;
                        }
                    }
                }
            
                const allExited = level6.exitingNPCs.every(npc => npc.exiting);
                if(allExited && level6.npcExitTimer > 180) {
                    const unclaimedSack = level6.cashSacks.find(s => !s.claimed);
                    if(unclaimedSack && !level6.endingTriggered) {
                        if(Math.abs(player.x - unclaimedSack.x) < 30 && Math.abs(player.y - unclaimedSack.y) < 30) {
                            if(keys[' '] || keys['action']) {
                                level6.endingTriggered = true;
                                state = 'victory';
                                menuChoice = 0;
                                playMusic('menu'); // Play menu music on victory
                                keys[' '] = false;
                                keys['action'] = false;
                            }
                        }
                    }
                }
            }

            // Keypad UI input handling
            if(level6.keypadUI) {
                if(keys['ArrowLeft'] || keys['left']) {
                    const col = level6.keypadSelected % 3;
                    if(col > 0) level6.keypadSelected--;
                    keys['ArrowLeft'] = false; keys['left'] = false;
                }
                if(keys['ArrowRight'] || keys['right']) {
                    const col = level6.keypadSelected % 3;
                    if(col < 2) level6.keypadSelected++;
                    keys['ArrowRight'] = false; keys['right'] = false;
                }
                if(keys['ArrowUp'] || keys['up']) {
                    if(level6.keypadSelected >= 3) level6.keypadSelected -= 3;
                    keys['ArrowUp'] = false; keys['up'] = false;
                }
                if(keys['ArrowDown'] || keys['down']) {
                    if(level6.keypadSelected < 3) {
                        if(level6.keypadSelected + 3 < 6) level6.keypadSelected += 3;
                    } else {
                        // Down from bottom row = clear last digit
                        if(level6.keypadInput.length > 0) level6.keypadInput.pop();
                        level6.keypadResult = null;
                    }
                    keys['ArrowDown'] = false; keys['down'] = false;
                }
                if(keys[' '] || keys['action']) {
                    keys[' '] = false; keys['action'] = false;
                    if(level6.keypadInput.length < 4) {
                        level6.keypadInput.push(level6.keypadSelected + 1);
                        if(level6.keypadInput.length === 4) {
                            const code = level6.keypadInput.join('');
                            if(code === '3546') {
                                level6.keypadResult = true;
                                level6.keypadResultTime = Date.now();
                                setTimeout(() => {
                                    level6.supercomputerUnlocked = true;
                                    level6.keypadUI = false;
                                }, 800);
                            } else {
                                level6.keypadResult = false;
                                level6.keypadResultTime = Date.now();
                                setTimeout(() => {
                                    level6.keypadInput = [];
                                    level6.keypadResult = null;
                                }, 1000);
                            }
                        }
                    }
                }
                // Block all other input while keypad is open
                return;
            }

            // Elevator UI input handling
            if(level6.elevatorUI) {
                if(keys['ArrowUp'] || keys['up']) {
                    level6.elevatorChoice = Math.max(0, level6.elevatorChoice - 1);
                    keys['ArrowUp'] = false; keys['up'] = false;
                }
                if(keys['ArrowDown'] || keys['down']) {
                    level6.elevatorChoice = Math.min(2, level6.elevatorChoice + 1);
                    keys['ArrowDown'] = false; keys['down'] = false;
                }
                if(keys[' '] || keys['action']) {
                    keys[' '] = false; keys['action'] = false;
                    // Determine if we're already on selected floor
                    const onFloor = (level6.elevatorChoice === 1 && level6.room === 'pipeRoom') ||
                                    (level6.elevatorChoice === 2 && level6.room === 'entryway') ||
                                    (level6.elevatorChoice === 0 && level6.room === 'employeeLobby');
                    if (onFloor) {
                        level6.elevatorUI = false;
                    } else {
                        // All floor changes use dissolve fade
                        level6.elevatorUI = false;
                        level6.elevatorTransition = true;
                        level6.elevatorFadeAlpha = 0;
                        level6.elevatorTarget = level6.elevatorChoice;
                    }
                }
                return;
            }

            // Elevator fade transition — dissolve to destination
            if(level6.elevatorTransition) {
                level6.elevatorFadeAlpha += 0.03;
                if(level6.elevatorFadeAlpha >= 1) {
                    level6.elevatorTransition = false;
                    const target = level6.elevatorTarget;
                    if (target === 2) {
                        // CEO Level → entryway
                        level6.room = 'entryway';
                        player.x = 350;
                        player.y = 400;
                    } else if (target === 1) {
                        // Smartware Level → pipe room
                        level6.room = 'pipeRoom';
                        player.x = 80;
                        player.y = 380;
                    } else if (target === 0) {
                        // Employee Level → employee lobby
                        level6.room = 'employeeLobby';
                        player.x = 580;
                        player.y = 380;
                    }
                    level6.elevatorTarget = null;
                    // Fade back in
                    level6.elevatorFadeIn = true;
                }
                return;
            }
            // Elevator fade-in after arriving
            if(level6.elevatorFadeIn) {
                level6.elevatorFadeAlpha -= 0.04;
                if(level6.elevatorFadeAlpha <= 0) {
                    level6.elevatorFadeAlpha = 0;
                    level6.elevatorFadeIn = false;
                }
                return;
            }

            // Detective hat dissolve transition — fade out
            if(level6.detectiveTransition) {
                level6.detectiveTransAlpha += 0.03;
                if(level6.detectiveTransAlpha >= 1) {
                    level6.detectiveTransition = false;
                    level6.detectiveTitleCard = true;
                    level6.detectiveTitleTimer = 0;
                    level6.hasDetectiveHat = true;
                    timer = (level === 4 ? 120 : 60) + 60; // Reset timer + extra minute for detective phase
                    document.getElementById('timer').textContent = timer;
                    updateLives(); // Switch $ to ?
                }
                return;
            }
            // Detective title card display
            if(level6.detectiveTitleCard) {
                level6.detectiveTitleTimer++;
                if(level6.detectiveTitleTimer > 180) { // 3 seconds
                    level6.detectiveTitleCard = false;
                    level6.detectiveFadeIn = true;
                }
                return;
            }
            // Detective fade back in
            if(level6.detectiveFadeIn) {
                level6.detectiveTransAlpha -= 0.04;
                if(level6.detectiveTransAlpha <= 0) {
                    level6.detectiveTransAlpha = 0;
                    level6.detectiveFadeIn = false;
                }
                return;
            }

            // Case Closed dissolve transition — fade out
            if(level6.caseClosedCard === 'fading') {
                level6.detectiveTransAlpha += 0.03;
                if(level6.detectiveTransAlpha >= 1) {
                    level6.caseClosedCard = true;
                    level6.caseClosedTimer = 0;
                }
                return;
            }
            // Case Closed title card display — stays forever
            if(level6.caseClosedCard === true) {
                level6.caseClosedTimer++;
                return;
            }

            // Movement for horizontal-only rooms (1D)
            if(level6.room === 'pipeRoom' || level6.room === 'megacomputer' || level6.room === 'entryway' || level6.room === 'employeeLobby' || level6.room === 'cloningRoom' || level6.room === 'l6Furnace' || level6.room === 'employeeHallway' || level6.room === 'employeePipeRoom') {
                const prevX = player.x;
                if(keys['ArrowLeft'] || keys['left']) {
                    player.x = Math.max(10, player.x - 5);
                    if(player.x !== prevX) {
                        player.facing = 'left';
                        player.lastMove = Date.now();
                    }
                }
                if(keys['ArrowRight'] || keys['right']) {
                    player.x = Math.min(690, player.x + 5);
                    if(player.x !== prevX) {
                        player.facing = 'right';
                        player.lastMove = Date.now();
                    }
                }
                if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right']) {
                    if(Date.now() - player.lastMove > 200) {
                        player.facing = 'down';
                    }
                }
            }

            // Room transitions
            if(level6.room === 'pipeRoom') {
                player.y = 380;

                if(player.x < 130 && !level6.elevatorUI && (keys[' '] || keys['action'])) {
                    level6.elevatorUI = true;
                    level6.elevatorChoice = 0;
                    level6.elevatorDoorOpen = 1;
                    keys[' '] = false;
                    keys['action'] = false;
                }

                if(player.x > 620 && !level6.supercomputerUnlocked && !level6.keypadUI && (keys[' '] || keys['action'])) {
                    level6.keypadUI = true;
                    level6.keypadInput = [];
                    level6.keypadSelected = 0;
                    level6.keypadResult = null;
                    keys[' '] = false;
                    keys['action'] = false;
                }

                if(level6.supercomputerUnlocked && player.x > 660 && level6.bladeDoor.openPct > 0.7) {
                    level6.room = 'megacomputer';
                    player.x = 80;
                    player.y = 380;
                }
                // Action button entry when standing near open door
                if(level6.supercomputerUnlocked && player.x > 580 && level6.bladeDoor.openPct > 0.5 && (keys[' '] || keys['action'])) {
                    level6.room = 'megacomputer';
                    player.x = 80;
                    player.y = 380;
                    keys[' '] = false;
                    keys['action'] = false;
                }
            }

            else if(level6.room === 'megacomputer') {
                player.y = 380;

                if(player.x < 40 && level6.bladeDoorMega.openPct > 0.7) {
                    level6.room = 'pipeRoom';
                    player.x = 640;
                    player.y = 380;
                }

                // Detective note interaction - aligned with actual note position
                const detectiveX = 540;
                const detectiveY = 445;
                const s = 2;
                const noteInteractX = detectiveX + 10*s + 9; // Note center: 569
                const noteInteractY = detectiveY - 30*s + 12; // Note center: 397
                if(!level6.viewingDetectiveNote && Math.abs(player.x - noteInteractX) < 50 && Math.abs(player.y - noteInteractY) < 50 && (keys[' '] || keys['action'])) {
                    level6.viewingDetectiveNote = true;
                    level6.noteScrollOffset = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                }

                // Pistol pickup — grants revolver with 7 bullets
                if(level6.pistol.dropped && !level6.pistol.pickedUp && Math.abs(player.x - level6.pistol.x) < 55 && (keys[' '] || keys['action'])) {
                    level6.pistol.pickedUp = true;
                    level6.pistol.dropped = false;
                    level6.hasRevolver = true;
                    level6.revolverAmmo = 7;
                    level6.detectiveHatOnGround = true; // Hat becomes available
                    keys[' '] = false;
                    keys['action'] = false;
                }

                // Detective hat pickup — after pistol is picked up
                if(level6.pistol.pickedUp && !level6.hasDetectiveHat && !level6.detectiveTransition && !level6.detectiveTitleCard) {
                    const detectiveX = 540, detectiveY = 445, s = 2;
                    const hatX = detectiveX - 24*s;
                    const hatY = detectiveY - 8*s;
                    if(Math.abs(player.x - hatX) < 50 && Math.abs(player.y - hatY) < 60 && (keys[' '] || keys['action'])) {
                        // Start dissolve transition
                        level6.detectiveTransition = true;
                        level6.detectiveTransAlpha = 0;
                        keys[' '] = false;
                        keys['action'] = false;
                    }
                }

                // Radiation damage - lose 1 money life every 2 seconds in center zone
                if(player.x > 233 && player.x < 467) {
                    level6.radiationTimer++;
                    // 60 frames per second * 2 seconds = 120 frames
                    if(level6.radiationTimer >= 120) {
                        if(level6.moneyLives > 0) {
                            level6.moneyLives--;
                            updateLives();
                        }
                        level6.radiationTimer = 0;
                    }
                } else {
                    level6.radiationTimer = 0;
                }
            } 
        
            else if(level6.room === 'employeeLobby') {
                player.y = 380;

                // Elevator interaction on right side
                if(player.x > 560 && !level6.elevatorUI && (keys[' '] || keys['action'])) {
                    level6.elevatorUI = true;
                    level6.elevatorChoice = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                }
                // Go left to cloning room
                if(player.x < 40) {
                    level6.room = 'cloningRoom';
                    player.x = 640;
                    player.y = 380;
                }
            }

            else if(level6.room === 'cloningRoom') {
                player.y = 380;

                // Go right to employee lobby
                if(player.x > 660) {
                    level6.room = 'employeeLobby';
                    player.x = 80;
                    player.y = 380;
                }

                // Concealed door to furnace room (left side) — keycard reader interaction
                if(player.x < 60 && !level6.cloningDoorUnlocked && level6.hasKeycard && (keys[' '] || keys['action'])) {
                    level6.cloningDoorUnlocked = true;
                    keys[' '] = false;
                    keys['action'] = false;
                }
                // Auto-transition through concealed door once open
                if(level6.cloningDoorUnlocked && level6.cloningDoorOpen >= 0.8 && player.x < 30) {
                    level6.room = 'l6Furnace';
                    player.x = 620;
                    player.y = 380;
                }

                // Shoot cloning boss — ALWAYS check bullet collision (independent of action key)
                if(level6.cloningBoss && level6.cloningBoss.alive && bullets.length > 0) {
                    const cb = level6.cloningBoss;
                    for(let i = bullets.length - 1; i >= 0; i--) {
                        const b = bullets[i];
                        if(Math.abs(b.x - cb.x) < 50 && Math.abs(b.y - cb.y) < 60) {
                            cb.alive = false;
                            cb.deathTime = Date.now();
                            bullets.splice(i, 1);
                            // Drop keycard
                            level6.keycardOnGround = true;
                            level6.keycardX = cb.x;
                            level6.keycardY = 385;
                            score += 2000;
                            break;
                        }
                    }
                }

                // Track whether action was consumed this frame
                let actionConsumed = false;

                // Keycard pickup
                if(level6.keycardOnGround && !level6.hasKeycard && Math.abs(player.x - level6.keycardX) < 50 && (keys[' '] || keys['action'])) {
                    level6.hasKeycard = true;
                    level6.keycardOnGround = false;
                    keys[' '] = false;
                    keys['action'] = false;
                    actionConsumed = true;
                }

                // Fire revolver in cloning room (action key when not near interactables)
                if(!actionConsumed && level6.hasRevolver && level6.revolverAmmo > 0 && (keys[' '] || keys['action'])) {
                    // Don't fire if near keycard, left door, right exit, or concealed door
                    const nearKeycard = level6.keycardOnGround && Math.abs(player.x - level6.keycardX) < 50;
                    const nearLeftDoor = player.x < 100;
                    const nearRightExit = player.x > 580;
                    if(!nearKeycard && !nearLeftDoor && !nearRightExit) {
                        keys[' '] = false;
                        keys['action'] = false;
                        let vx = 0;
                        if(player.facing === 'left') vx = -12;
                        else if(player.facing === 'right') vx = 12;
                        else vx = player.x < 350 ? 12 : -12; // Default toward boss
                        if(vx !== 0) {
                            bullets.push({ x: player.x, y: player.y - 25, vx: vx, vy: 0, fromCEO: false });
                            level6.revolverAmmo--;
                            muzzleFlashes.push({ x: player.x + (vx > 0 ? 12 : -12), y: player.y - 25, life: 3 });
                        }
                    }
                }
            }

            // === Level 6 Furnace Room (accessed from cloning room concealed door) ===
            else if(level6.room === 'l6Furnace') {
                player.y = 380;

                // Left door to Employee Level hallway — action-based (trigger aligned with door highlight at x<100)
                if(player.x < 100 && (keys[' '] || keys['action'])) {
                    level6.room = 'employeeHallway';
                    player.x = 620;
                    player.y = 380;
                    keys[' '] = false;
                    keys['action'] = false;
                }

                // Right exit — back to cloning room (auto)
                if(player.x > 660) {
                    level6.room = 'cloningRoom';
                    player.x = 80;
                    player.y = 380;
                }
            }

            // === Employee Hallway (original Level 5 hallway revisited from Level 6) ===
            else if(level6.room === 'employeeHallway') {
                player.y = 380;

                // Left — to original pipe room (auto)
                if(player.x < 40) {
                    level6.room = 'employeePipeRoom';
                    player.x = 620;
                    player.y = 380;
                }

                // Right — back to l6 furnace room (auto)
                if(player.x > 660) {
                    level6.room = 'l6Furnace';
                    player.x = 80;
                    player.y = 380;
                }
            }

            // === Employee Pipe Room (original Level 5 pipe room revisited from Level 6) ===
            else if(level6.room === 'employeePipeRoom') {
                player.y = 380;

                // Right — back to Employee hallway (auto)
                if(player.x > 660) {
                    level6.room = 'employeeHallway';
                    player.x = 80;
                    player.y = 380;
                }
            }

            else if(level6.room === 'entryway') {
                player.y = 400;

                // Elevator interaction — use the entryway elevator to go back
                if(player.x > 580 && !level6.elevatorUI && (keys[' '] || keys['action'])) {
                    level6.elevatorUI = true;
                    level6.elevatorChoice = 0;
                    keys[' '] = false;
                    keys['action'] = false;
                }

                if(Math.abs(player.x - 350) < 100 && (keys[' '] || keys['action'])) {
                    level6.room = 'ceoOffice';
                    player.x = 350;
                    player.y = 420;
                    keys[' '] = false;
                    keys['action'] = false;

                    if(level6.hasDetectiveHat && ceo.state !== 'dead') {
                        // Detective entering! CEO immediately goes into murder mode
                        ceo.state = 'hunting';
                        ceo.walkTarget = null;
                        level6.ceoAngryMode = true;
                        ceo.shootTimer = 100; // Start shooting almost immediately
                        ceo.health = 6; // Full health still
                    } else {
                        // Normal entry — Set CEO to walk to middle rug on entry
                        ceo.walkTarget = {x: 350, y: 340};
                    }
                }
            } 
        
            else if(level6.room === 'ceoOffice') {
                // Handle safe UI
                if(level6.safeUI) {
                    // Item selection mode (after unlock)
                    if(level6.selectingItem) {
                        if(keys['ArrowLeft'] || keys['left']) {
                            level6.itemSelection = Math.max(0, level6.itemSelection - 1);
                            keys['ArrowLeft'] = false;
                            keys['left'] = false;
                        }
                        if(keys['ArrowRight'] || keys['right']) {
                            level6.itemSelection = Math.min(2, level6.itemSelection + 1);
                            keys['ArrowRight'] = false;
                            keys['right'] = false;
                        }
                        if(keys[' '] || keys['action']) {
                            keys[' '] = false;
                            keys['action'] = false;

                            if(level6.itemSelection === 0 && !level6.hasRevolver) {
                                // Take revolver
                                level6.hasRevolver = true;
                                level6.revolverAmmo = 6;
                                level6.selectingItem = false;
                                level6.safeUI = false;
                            } else if(level6.itemSelection === 1 && level6.moneyLives < 3) {
                                // Take $ life
                                level6.moneyLives++;
                                updateLives();
                                level6.selectingItem = false;
                                level6.safeUI = false;
                            } else if(level6.itemSelection === 2) {
                                // Take bullets (unlimited, adds 6 bullets)
                                level6.revolverAmmo = Math.min(level6.revolverAmmo + 6, 99);
                                level6.selectingItem = false;
                                level6.safeUI = false;
                            }
                        }
                        return;
                    }

                    // Code entry mode
                    if(keys['ArrowLeft'] || keys['left']) {
                        const row = Math.floor(level6.selectedButton / 2);
                        const col = level6.selectedButton % 2;
                        if(col > 0) {
                            level6.selectedButton--;
                        }
                        keys['ArrowLeft'] = false;
                        keys['left'] = false;
                    }
                    if(keys['ArrowRight'] || keys['right']) {
                        const row = Math.floor(level6.selectedButton / 2);
                        const col = level6.selectedButton % 2;
                        if(col < 1) {
                            level6.selectedButton++;
                        }
                        keys['ArrowRight'] = false;
                        keys['right'] = false;
                    }
                    if(keys['ArrowUp'] || keys['up']) {
                        const row = Math.floor(level6.selectedButton / 2);
                        if(row > 0) {
                            level6.selectedButton -= 2;
                        }
                        keys['ArrowUp'] = false;
                        keys['up'] = false;
                    }
                    if(keys['ArrowDown'] || keys['down']) {
                        const row = Math.floor(level6.selectedButton / 2);
                        if(row < 1) {
                            level6.selectedButton += 2;
                        }
                        keys['ArrowDown'] = false;
                        keys['down'] = false;
                    }
                    if(keys[' '] || keys['action']) {
                        keys[' '] = false;
                        keys['action'] = false;

                        if(level6.codeInput.length < 4) {
                            const selectedColor = COLORS[level6.selectedButton].name;
                            level6.codeInput.push(selectedColor);

                            if(level6.codeInput.length === 4) {
                                const correct = level6.codeInput.every((color, i) => color === SAFE_CODE[i]);
                                if(correct) {
                                    setTimeout(() => {
                                        level6.safeUnlocked = true;
                                        level6.safeUI = false;
                                        level6.codeInput = [];
                                        level6.selectedButton = 0;
                                    }, 1000);
                                } else {
                                    setTimeout(() => {
                                        level6.codeInput = [];
                                        level6.selectedButton = 0;
                                    }, 1000);
                                }
                            }
                        }
                    }
                    return;
                }
            
                // Handle computer UI
                if(level6.computerUI) {
                    // Arrow navigation - directly reset keys after reading
                    if(keys['ArrowLeft'] || keys['left']) {
                        level6.computerChoice = 0; // Self-destruct
                        keys['ArrowLeft'] = false;
                        keys['left'] = false;
                    }

                    if(keys['ArrowRight'] || keys['right']) {
                        level6.computerChoice = 1; // Deliver means
                        keys['ArrowRight'] = false;
                        keys['right'] = false;
                    }

                    // Allow closing with Escape key
                    if(keys['Escape']) {
                        level6.computerUI = false;
                        keys['Escape'] = false;
                    }

                    // Confirm selection
                    if(keys[' '] || keys['action']) {
                        if(level6.computerChoice === 0) {
                            // Self-destruct - "The End"
                            level6.computerUI = false;
                            state = 'theend';
                            menuChoice = 0;
                        } else {
                            // Deliver means of production - leads to "You Win!"
                            level6.computerCompleted = true;
                            level6.computerUI = false;
                            level6.npcExitSequence = true;

                            level6.exitingNPCs = [
                                {x: 350, y: 460, color: COLORS[0], facing: 'forward', hasSack: false, exiting: false, isMulletPro: false, stuckTimer: 0, lastDist: Infinity},
                                {x: 370, y: 460, color: COLORS[1], facing: 'forward', hasSack: false, exiting: false, isMulletPro: false, stuckTimer: 0, lastDist: Infinity},
                                {x: 330, y: 460, color: COLORS[2], facing: 'forward', hasSack: false, exiting: false, isMulletPro: false, stuckTimer: 0, lastDist: Infinity},
                                {x: 390, y: 460, color: COLORS[3], facing: 'forward', hasSack: false, exiting: false, isMulletPro: false, stuckTimer: 0, lastDist: Infinity},
                                {x: 410, y: 460, color: null, facing: 'forward', hasSack: false, exiting: false, isMulletPro: true, stuckTimer: 0, lastDist: Infinity}
                            ];
                        }
                        keys[' '] = false;
                        keys['action'] = false;
                    }
                    return;
                }
            
                // CEO office interactions
if (keys[' '] || keys['action']) {
    keys[' '] = false;
    keys['action'] = false;

    // 1. CEO Interaction (Giving Drink)
    if (ceo.state === 'offering' && Math.abs(player.x - ceo.x) < 60 && Math.abs(player.y - ceo.y) < 60) {
        level6.moneyLives++;
        updateLives();
        ceo.hasDrink = true;
        ceo.state = 'admiring';
        return; // Return to prevent triggering other objects
    }

    // 1.5. Red Phone Interaction — answer to end the case
    const phoneX = 350 + 45, phoneDeskY = 250 - 10;
    if (level6.ceoDefeated && !level6.caseClosedCard &&
        Math.abs(player.x - phoneX) < 50 && Math.abs(player.y - phoneDeskY) < 60) {
        // Start Case Closed transition
        level6.caseClosedCard = 'fading';
        level6.detectiveTransAlpha = 0;
        return;
    }

    // 2. Monitor/Computer Interaction (PRIORITY: CHECK THIS BEFORE SAFE)
    // The monitor is on the desk at Y ~ 205.
    const monX = 390;
    const monY = 205;

    // We strictly check player.y > 180 to ensure they are at the DESK, not the wall
    if (level6.ceoDefeated && !level6.computerUI &&
        Math.abs(player.x - monX) < 50 &&
        Math.abs(player.y - monY) < 60 &&
        player.y > 180) { // Added strict Y check
            level6.computerUI = true;
            return; // Stop checking other interactions
    }

    // 3. Safe Interaction
    // Safe is at Y = 140 (Back Wall). 
    const safeX = 350;
    const safeY = 140; 
    
    // Tightened Y-range (reduced from 90 to 50) so you must walk UP to the wall
    const nearSafe = Math.abs(player.x - safeX) < 70 && Math.abs(player.y - safeY) < 60;

    if (!level6.safeUnlocked && nearSafe) {
        level6.safeUI = true;
        level6.selectedButton = 0;
        return;
    }

    if (level6.safeUnlocked && nearSafe) {
        level6.safeUI = true;
        level6.selectingItem = true;
        level6.itemSelection = 0;
        return;
    }

    // 4. Gun Firing Logic (only triggers if nothing else was interacted with)
    if (level6.hasRevolver && level6.revolverAmmo > 0) {
        let vx = 0, vy = 0;
        if (player.facing === 'left') vx = -12;
        else if (player.facing === 'right') vx = 12;
        else if (player.facing === 'up') vy = -12;
        else if (player.facing === 'down') vy = 12;

        if (vx !== 0 || vy !== 0) {
            bullets.push({
                x: player.x,
                y: player.y - 25,
                vx: vx,
                vy: vy,
                fromCEO: false
            });
            level6.revolverAmmo--;

            // Bullet collision with CEO
            if (ceo.state !== 'dead' && Math.abs(bullets[bullets.length - 1].x - ceo.x) < 50 && Math.abs(bullets[bullets.length - 1].y - ceo.y) < 50) {
                ceo.health--;
                ceo.blinkTimer = 10;

                // Drop cash sacks
                let sackX, sackY;
                if (ceo.state === 'admiring') {
                    sackX = ceo.x + 10;
                    sackY = ceo.y + 50;
                } else {
                    const sackIndex = 6 - ceo.health;
                    const angle = (sackIndex / 6) * Math.PI * 2;
                    const radius = 40;
                    sackX = ceo.x + Math.cos(angle) * radius;
                    sackY = ceo.y + Math.sin(angle) * radius;
                }
                level6.cashSacks.push({
                    x: sackX,
                    y: sackY,
                    claimed: false
                });

                if (ceo.health <= 0) {
                    ceo.state = 'dead';
                    level6.ceoDefeated = true;
                } else if (ceo.state === 'admiring' || ceo.state === 'offering') {
                    ceo.state = 'hunting';
                }
            }
        }
    }
}


                // Full 2D movement in CEO office (only if not in UI mode)
                if(!level6.safeUI && !level6.computerUI) {
                    const prevX = player.x;
                    const prevY = player.y;

                    if(keys['ArrowLeft'] || keys['left']) {
                    player.x = Math.max(60, player.x - 5);
                    if(player.x !== prevX) {
                        player.facing = 'left';
                        player.lastMove = Date.now();
                    }
                }
                if(keys['ArrowRight'] || keys['right']) {
                    player.x = Math.min(640, player.x + 5);
                    if(player.x !== prevX) {
                        player.facing = 'right';
                        player.lastMove = Date.now();
                    }
                }
                if(keys['ArrowUp'] || keys['up']) {
                    player.y = Math.max(80, player.y - 5);
                    if(player.y !== prevY) {
                        player.facing = 'up';
                        player.lastMove = Date.now();
                    }
                }
                if(keys['ArrowDown'] || keys['down']) {
                    player.y = Math.min(450, player.y + 5);
                    if(player.y !== prevY) {
                        player.facing = 'down';
                        player.lastMove = Date.now();
                    }
                }
            
                // Collision with desk - adjusted for front-facing perspective
                const deskX = 350;
                const deskY = 250; // Matches actual drawn position
                // Desk collision covers entire desk including top surface (prevents walking on desk)
                // Desk extends from Y=195 (top) to Y=295 (bottom including legs/shadow)
                if(player.x > deskX - 90 && player.x < deskX + 90 && player.y > deskY - 60 && player.y < deskY + 50) {
                    player.x = prevX;
                    player.y = prevY;
                }
            
                // Collision with trophy cabinet (100px wide, 120px tall, against back wall)
                const cabinetX = 600;
                const cabinetY = 50;
                if(player.x > cabinetX - 10 && player.x < cabinetX + 110 && player.y < cabinetY + 130) {
                    player.x = prevX;
                    player.y = prevY;
                }
            
                // Collision with mirror (against back wall)
                const mirrorX = 100;
                const mirrorY = 50;
                if(player.x > mirrorX - 10 && player.x < mirrorX + 100 && player.y < mirrorY + 120) {
                    player.x = prevX;
                    player.y = prevY;
                }

                // Collision with CEO character (when not dead)
                if(ceo.state !== 'dead') {
                    if(Math.abs(player.x - ceo.x) < 40 && Math.abs(player.y - ceo.y) < 50) {
                        player.x = prevX;
                        player.y = prevY;
                    }
                }

                // Collision with portrait wall (center back, pushed against wall)
                const portraitX = 350;
                const portraitY = 0;
                // Portrait is 120px wide, 90px tall
                if(player.x > portraitX - 60 && player.x < portraitX + 60 && player.y < portraitY + 100) {
                    player.x = prevX;
                    player.y = prevY;
                }

                // Collision with safe (separated from desk, no walkover allowed)
                const safeCollisionX = 350;
                const safeCollisionY = 100;
                // Safe is 50px wide, 70px tall - full collision box
                if(player.x > safeCollisionX - 30 && player.x < safeCollisionX + 30 &&
                   player.y > safeCollisionY - 10 && player.y < safeCollisionY + 80) {
                    player.x = prevX;
                    player.y = prevY;
                }

                // Back wall collision - prevent walking behind/above wall-mounted objects
                // This creates a barrier along the entire back wall (y < 40)
                if(player.y < 40) {
                    player.x = prevX;
                    player.y = prevY;
                }

                if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right'] &&
                   !keys['ArrowUp'] && !keys['up'] && !keys['ArrowDown'] && !keys['down']) {
                    if(Date.now() - player.lastMove > 200) {
                        player.facing = 'down';
                    }
                }
                }
            }
        
            // Bullet collision
            for(let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].vx;
                bullets[i].y += bullets[i].vy;
            
                if(bullets[i].x < 0 || bullets[i].x > 700 || bullets[i].y < 0 || bullets[i].y > 500) {
                    bullets.splice(i, 1);
                    continue;
                }
            
                if(bullets[i].fromCEO && Math.abs(bullets[i].x - player.x) < 30 && Math.abs(bullets[i].y - player.y) < 30) {
                    level6.moneyLives--;
                    updateLives();
                    bullets.splice(i, 1);
                
                    if(level6.moneyLives <= 0) {
                        state = 'over';
                        menuChoice = 0;
                    }
                    continue;
                }
            
                // Cloning boss collision — belt-and-suspenders check after bullet movement
                if(!bullets[i].fromCEO && level6.room === 'cloningRoom' && level6.cloningBoss && level6.cloningBoss.alive) {
                    const cb = level6.cloningBoss;
                    if(Math.abs(bullets[i].x - cb.x) < 50 && Math.abs(bullets[i].y - cb.y) < 60) {
                        cb.alive = false;
                        cb.deathTime = Date.now();
                        bullets.splice(i, 1);
                        level6.keycardOnGround = true;
                        level6.keycardX = cb.x;
                        level6.keycardY = 385;
                        score += 2000;
                        continue;
                    }
                }

                if(!bullets[i].fromCEO && ceo.state !== 'dead' && Math.abs(bullets[i].x - ceo.x) < 40 && Math.abs(bullets[i].y - ceo.y) < 40) {
                    ceo.health--;
                    ceo.blinkTimer = 10;

                    // Drop cash sacks - behind CEO if at mirror, otherwise in circle pattern
                    let sackX, sackY;
                    if(ceo.state === 'admiring') {
                        // Drop behind CEO at mirror for accessibility
                        sackX = ceo.x + 10;
                        sackY = ceo.y + 50; // Behind and below
                    } else {
                        // Spread in circle pattern
                        const sackIndex = 6 - ceo.health;
                        const angle = (sackIndex / 6) * Math.PI * 2;
                        const radius = 40;
                        sackX = ceo.x + Math.cos(angle) * radius;
                        sackY = ceo.y + Math.sin(angle) * radius;
                    }
                    level6.cashSacks.push({
                        x: sackX,
                        y: sackY,
                        claimed: false
                    });

                    bullets.splice(i, 1);

                    if(ceo.health <= 0) {
                        ceo.state = 'dead';
                        level6.ceoDefeated = true;
                    } else if(ceo.state === 'admiring') {
                        ceo.state = 'hunting';
                    }
                    continue;
                }
            }

            // Supercomputer blade door animations
            if (level6.bladeDoor) {
                if (level6.bladeDoor.state === 'opening') {
                    level6.bladeDoor.openPct = Math.min(1, level6.bladeDoor.openPct + 0.06);
                    if (level6.bladeDoor.openPct >= 1) level6.bladeDoor.state = 'open';
                } else if (level6.bladeDoor.state === 'closing') {
                    level6.bladeDoor.openPct = Math.max(0, level6.bladeDoor.openPct - 0.06);
                    if (level6.bladeDoor.openPct <= 0) level6.bladeDoor.state = 'closed';
                }
                // Auto-open when unlocked and player is near
                if (level6.supercomputerUnlocked && level6.room === 'pipeRoom' && player.x > 480) {
                    if (level6.bladeDoor.state === 'closed' || level6.bladeDoor.state === 'closing') level6.bladeDoor.state = 'opening';
                } else if (level6.room === 'pipeRoom' && player.x <= 480 && level6.bladeDoor.state === 'open') {
                    level6.bladeDoor.state = 'closing';
                }
                // Megacomputer side — always open when in megacomputer room, close when leaving
                if (level6.bladeDoorMega) {
                    if (level6.bladeDoorMega.state === 'opening') {
                        level6.bladeDoorMega.openPct = Math.min(1, level6.bladeDoorMega.openPct + 0.04);
                        if (level6.bladeDoorMega.openPct >= 1) level6.bladeDoorMega.state = 'open';
                    } else if (level6.bladeDoorMega.state === 'closing') {
                        level6.bladeDoorMega.openPct = Math.max(0, level6.bladeDoorMega.openPct - 0.06);
                        if (level6.bladeDoorMega.openPct <= 0) level6.bladeDoorMega.state = 'closed';
                    }
                    if (level6.room === 'megacomputer' && player.x < 120) {
                        if (level6.bladeDoorMega.state === 'closed') level6.bladeDoorMega.state = 'opening';
                    } else if (level6.room === 'megacomputer' && player.x >= 120 && level6.bladeDoorMega.state === 'open') {
                        level6.bladeDoorMega.state = 'closing';
                    }
                }
            }

            // Cloning room concealed door slide animation
            if (level6.cloningDoorUnlocked && level6.cloningDoorOpen < 1) {
                level6.cloningDoorOpen = Math.min(1, level6.cloningDoorOpen + 0.03);
            }

            // Cloning room boss AI — patrol back and forth examining cloning unit
            if (level6.room === 'cloningRoom' && level6.cloningBoss && level6.cloningBoss.alive) {
                const cb = level6.cloningBoss;
                if (cb.paused) {
                    cb.facing = cb.x > 360 ? 'left' : cb.x < 340 ? 'right' : 'left';
                    cb.pauseTimer--;
                    if (cb.pauseTimer <= 0) {
                        cb.paused = false;
                        cb.walkDir *= -1;
                    }
                } else {
                    cb.x += cb.walkDir * 0.8;
                    cb.facing = cb.walkDir > 0 ? 'right' : 'left';
                    if (cb.x > 480 || cb.x < 220) {
                        cb.paused = true;
                        cb.pauseTimer = 90 + Math.random() * 90;
                    }
                }
            }

            return;
        }


    // LEVELS 1-4 LOGIC
    if(!ui.show && !ui.gunUI) {
        const prevX = player.x;
        if(keys['ArrowLeft'] || keys['left']) {
            player.x = Math.max(20, player.x - 5);
            if(player.x !== prevX) {
                player.facing = 'left';
                player.lastMove = Date.now();
            }
        }
        if(keys['ArrowRight'] || keys['right']) {
            player.x = Math.min(680, player.x + 5);
            if(player.x !== prevX) {
                player.facing = 'right';
                player.lastMove = Date.now();
            }
        }
        if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right']) {
            if(Date.now() - player.lastMove > 200) {
                player.facing = 'down';
            }
        }
    }

    if(boss.active && boss.walking) {
        if(boss.angry) {
            boss.x += 5;
            boss.facing = 'right';
            if(boss.x > 720) {
                boss.active = false;
                boss.needsColor = null;
                boss.angry = false;
            }
        } else if(boss.needsColor === null) {
            boss.x += 3;
            boss.facing = 'right';
            if(boss.x > 720) {
                boss.active = false;
            }
        } else {
            boss.x -= 2;
            boss.facing = 'left';
            if(boss.x <= 200) {
                boss.walking = false;
                boss.spawnTime = Date.now();
            }
        }
    }
    
    if(boss.active && !boss.walking && !boss.angry && boss.needsColor) {
        if(Date.now() - boss.spawnTime > 6000) {
            boss.angry = true;
            boss.walking = true;
            boss.needsColor = null;
            lives--;
            score = Math.floor(score / 2);
            updateLives();
            if(lives <= 0) {
                state = 'over';
                menuChoice = 0;
            }
        }
    }

    // Boss door animation
    if (bossDoor.state === 'opening') {
        bossDoor.openPct = Math.min(1, bossDoor.openPct + 0.08);
        if (bossDoor.openPct >= 1) bossDoor.state = 'open';
    } else if (bossDoor.state === 'closing') {
        bossDoor.openPct = Math.max(0, bossDoor.openPct - 0.15);
        if (bossDoor.openPct <= 0) bossDoor.state = 'closed';
    }
    // Slam door shut when boss exits past x=700
    if (!boss.active && bossDoor.state === 'open') {
        bossDoor.state = 'closing';
    }

    if(ghostGun.printing) {
        ghostGun.printProgress += 0.02;
        if(ghostGun.printProgress >= 1) {
            ghostGun.printing = false;
            ghostGun.printProgress = 0;
            if(ghostGun.printingHeart) {
                lives = Math.min(3, lives + 1);
                updateLives();
                ghostGun.printingHeart = false;
            } else {
                ghostGun.hasGun = true;
                ghostGun.ammo = 1;
            }
        }
    }

    for(let i = explosions.length - 1; i >= 0; i--) {
        let exp = explosions[i];
        exp.radius += 3;
        exp.alpha -= 0.03;
        for(let p of exp.particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.3;
            p.life -= 0.02;
        }
        if(exp.alpha <= 0) {
            explosions.splice(i, 1);
        }
    }
    
    for(let i = muzzleFlashes.length - 1; i >= 0; i--) {
        muzzleFlashes[i].life--;
        if(muzzleFlashes[i].life <= 0) {
            muzzleFlashes.splice(i, 1);
        }
    }
    
    for(let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].x += bullets[i].vx;
        if(bullets[i].x > 750 || bullets[i].x < 0) {
            bullets.splice(i, 1);
            continue;
        }
        if(boss.active && Math.abs(bullets[i].x - boss.x) < 50 && Math.abs(bullets[i].y - boss.y) < 50) {
            boss.active = false;
            boss.needsColor = null;
            boss.walking = false;
            boss.angry = false;
            boss.bossKills++;
            score += 500 * level;
            bullets.splice(i, 1);
            createExplosion(boss.x, boss.y);
            lives = Math.min(3, lives + 1);
            updateLives();
            checkPromotion();
        }
    }

    if(keys[' '] || keys['action']) {
        keys[' '] = false;
        keys['action'] = false;
        
        const atComputer = Math.abs(player.x - computer.x) < 60;
        const at3DPrinter = level === 4 && Math.abs(player.x - printer3d.x) < 60;
        
        if(ghostGun.hasGun && ghostGun.ammo > 0 && !ui.show && !ui.gunUI) {
            const direction = player.facing === 'left' ? -1 : player.facing === 'right' ? 1 : 0;
            if(direction !== 0) {
                bullets.push({x: player.x, y: player.y - 25, vx: direction * 12});
                createMuzzleFlash(player.x, player.y - 25, player.facing);
                ghostGun.ammo = 0;
                ghostGun.hasGun = false;
            }
            return;
        }
        
        if(at3DPrinter && !player.holding && !ui.show && !ui.gunUI && !ghostGun.hasGun && !ghostGun.printing) {
            ui.gunUI = true;
            return;
        }
        
        if(atComputer && !player.holding && !ui.show && !ui.gunUI && !ghostGun.hasGun) {
            ui.show = true;
            return;
        }
        
        if(ui.show && !ui.confirming) {
            ui.confirming = true;
            return;
        }
        
        if(ui.show && ui.confirming) {
            player.holding = COLORS[ui.selectedColor].name;
            ui.show = false;
            ui.confirming = false;
            ui.selectedColor = 0;
            return;
        }
        
        if(ui.gunUI && !ui.confirming) {
            ui.confirming = true;
            return;
        }
        
        if(ui.gunUI && ui.confirming) {
            ui.gunUI = false;
            ui.confirming = false;
            ghostGun.printing = true;
            ghostGun.printProgress = 0;
            ghostGun.printingHeart = (ui.gunChoice === 1);
            ui.gunChoice = 0;
            return;
        }
        
        if(player.holding) {
            if(boss.active && !boss.angry && Math.abs(player.x - boss.x) < 50 && boss.needsColor === player.holding) {
                score += 300 * level;
                boss.needsColor = null;
                boss.walking = true;
                boss.angry = false;
                player.holding = null;
                return;
            }
            
            for(let npc of npcs) {
                if(Math.abs(player.x - npc.x) < 45 && npc.needsDoc && npc.color.name === player.holding) {
                    npc.needsDoc = false;
                    npc.state = 'fixing';
                    npc.fixAnim = 0;
                    player.holding = null;
                    score += 150 * level;
                    
                    const fixInterval = setInterval(() => {
                        npc.fixAnim += 0.3;
                    }, 50);
                    
                    setTimeout(() => {
                        clearInterval(fixInterval);
                        cracks = cracks.filter(c => c.npc !== npc);
                        npc.state = 'happy';
                    }, 2000);
                    break;
                }
            }
        }
    }
    
    if(ui.show && !ui.confirming) {
        if((keys['ArrowLeft'] || keys['left']) && !keys.leftProcessed) {
            ui.selectedColor = Math.max(0, ui.selectedColor - 1);
            keys.leftProcessed = true;
        }
        if((keys['ArrowRight'] || keys['right']) && !keys.rightProcessed) {
            ui.selectedColor = Math.min(3, ui.selectedColor + 1);
            keys.rightProcessed = true;
        }
        if(!keys['ArrowLeft'] && !keys['left']) keys.leftProcessed = false;
        if(!keys['ArrowRight'] && !keys['right']) keys.rightProcessed = false;
    }

    if(ui.gunUI && !ui.confirming) {
        if((keys['ArrowLeft'] || keys['left']) && !keys.leftProcessed) {
            ui.gunChoice = Math.max(0, ui.gunChoice - 1);
            keys.leftProcessed = true;
        }
        if((keys['ArrowRight'] || keys['right']) && !keys.rightProcessed) {
            ui.gunChoice = Math.min(1, ui.gunChoice + 1);
            keys.rightProcessed = true;
        }
        if(!keys['ArrowLeft'] && !keys['left']) keys.leftProcessed = false;
        if(!keys['ArrowRight'] && !keys['right']) keys.rightProcessed = false;
    }
    
    for(let i = cracks.length - 1; i >= 0; i--) {
        let crack = cracks[i];
        if(Date.now() - crack.time > crack.max) {
            createExplosion(crack.npc.x, 240);
            cracks.splice(i, 1);
            lives--;
            updateLives();
            resetting = true;
            fadeOut = true;
            fadeAlpha = 0;
            if(lives <= 0) {
                state = 'over';
                menuChoice = 0;
            }
            return;
        }
    }
}


// SECTION 14: Game Loop and Event Handlers
function winGame() {
    state = 'win';
    menuChoice = 0;
    playMusic('menu'); // Play menu music on win
}

function nextLevel() {
    if(level < 4) {
        level++;
        timer = level === 4 ? 120 : 60; // Level 4 gets 120 seconds
        state = 'levelCard';
        cardTimer = 0;
        initLevel(level);

        // Play music for new level
        playMusic('level' + level);
    } else {
        winGame();
    }
}

let lastTime = Date.now();
let counter = 0;

function gameLoop() {
    if(state !== 'playing' && state !== 'levelCard' && state !== 'over' &&
       state !== 'win' && state !== 'menu' && state !== 'promotion' &&
       state !== 'theend' && state !== 'victory' && state !== 'rtPresents' &&
       state !== 'conceptArt' && state !== 'fired' && state !== 'gameover') return;

    // Retry pending music every ~2 seconds if audio is unlocked but music didn't start
    if(audioUnlocked && pendingMusicKey && frame % 120 === 0) {
        resumePendingMusic();
    }

    frame++;
    const now = Date.now();
    counter += now - lastTime;
    lastTime = now;
    
    if(state === 'playing' && !resetting && counter >= 1000) {
        timer--;
        counter = 0;
        document.getElementById('timer').textContent = timer;
        if(timer <= 0) {
            if(level === 5) {
                state = 'gameover'; // Didn't burn 6 documents in time
                menuChoice = 0;
            } else if(level === 6) {
                state = 'over';
                menuChoice = 0;
            } else {
                nextLevel();
            }
        }
    }
    
    update();
    drawScene();
    document.getElementById('level').textContent = level;
    document.getElementById('score').textContent = score;
    requestAnimationFrame(gameLoop);
}

// Don't play music on page load - let RT Presents screen handle first interaction
drawScene();
gameLoop();

// --- NEW HELPER: PRE-TRIGGER MUSIC ON INTERACTION ---
// This function checks if a tap/click IS ABOUT TO trigger a level change
// and starts the music immediately while we are still in the event handler.
function tryTriggerMusicOnInput() {
    // 1. Level 5 Trigger (Promotion Screen)
    if (state === 'promotion') {
        playMusic('level5');
        return;
    }

    // 2. Level 6 Trigger (Furnace Logic ONLY)
    if (level === 5 && level5.room === 'furnaceRoom' && player.holding) {
        const furnace = level5.furnaceRoom.furnace;
        // Check distance (must match update() logic range of < 80)
        if (Math.abs(player.x - furnace.x) < 80) {
            // We are holding a doc. If we have 5 collected, this current one is the 6th.
            // This is the EXACT moment of transition.
            if (level5.docsCollected >= 5) {
                playMusic('level6');
                return;
            }
        }
    }
}

// --- UPDATED INPUT HANDLERS ---

document.addEventListener('keydown', e => {
    // Prevent arrow keys and space from scrolling the page
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
        e.preventDefault();
    }

    // Handle RT Presents screen FIRST
    if(handleRTPresentsInteraction()) {
        keys = {};
        return;
    }
    // Handle Menu screen
    if(handleMenuInteraction()) {
        keys = {};
        return;
    }

    keys[e.key] = true;

    // Unlock audio on first interaction
    if(!audioUnlocked) {
        audioUnlocked = true;
        resumePendingMusic();
    }

    // Try to pre-trigger music for level transitions
    tryTriggerMusicOnInput();

    if(e.key === 'm' || e.key === 'M') {
        toggleMute();
    }
});

document.addEventListener('keyup', e => {
    keys[e.key] = false;
});

// Touch/click support for mute button
function handleMuteClick(e) {
    if(!audioUnlocked) {
        audioUnlocked = true;
        resumePendingMusic();
    }

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    let clientX, clientY;
    if(e.type.startsWith('touch')) {
        if(e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else if(e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            return;
        }
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    const x = (clientX - rect.left) * scaleX - GX;
    const y = (clientY - rect.top) * scaleY - GY;

    // Mute button position matches drawMuteIndicator: top-right of canvas
    const muteBtnX = -GX + CANVAS_W - 90;
    const muteBtnY = -GY + 5;
    if(x >= muteBtnX && x <= muteBtnX + 80 && y >= muteBtnY && y <= muteBtnY + 50) {
        toggleMute();
        if(e.cancelable) e.preventDefault();
    }
}

canvas.addEventListener('click', handleMuteClick);
canvas.addEventListener('touchstart', handleMuteClick, {passive: false});

// D-pad: zone-based touch detection for reliable taps and smooth gliding
const dpadContainer = document.getElementById('dpad-container');
const dpadBtnMap = {};
document.querySelectorAll('.control-btn').forEach(btn => { dpadBtnMap[btn.dataset.dir] = btn; });
let activeDpadDir = null;

// Zone-based: divide d-pad rect into quadrants — no dead zones
function dpadDirFromPoint(clientX, clientY) {
    const r = dpadContainer.getBoundingClientRect();
    if (clientX < r.left || clientX > r.right || clientY < r.top || clientY > r.bottom) return null;
    const rx = (clientX - r.left) / r.width;   // 0..1
    const ry = (clientY - r.top) / r.height;    // 0..1
    // Center dead zone (avoids accidental input)
    const cx = Math.abs(rx - 0.5), cy = Math.abs(ry - 0.5);
    if (cx < 0.12 && cy < 0.12) return null;
    // Which axis is dominant?
    const dx = rx - 0.5, dy = ry - 0.5;
    if (Math.abs(dx) > Math.abs(dy)) {
        return dx > 0 ? 'right' : 'left';
    } else {
        return dy > 0 ? 'down' : 'up';
    }
}

function setDpadDir(dir) {
    if (dir === activeDpadDir) return;
    // Remove visual highlight from old button
    if (activeDpadDir && dpadBtnMap[activeDpadDir]) dpadBtnMap[activeDpadDir].classList.remove('active');
    if (activeDpadDir) keys[activeDpadDir] = false;
    activeDpadDir = dir;
    if (dir) keys[dir] = true;
    // Add visual highlight to new button
    if (dir && dpadBtnMap[dir]) dpadBtnMap[dir].classList.add('active');
}

function dpadTouchHandler(e) {
    if(e.cancelable) e.preventDefault();
    const t = e.touches[0];
    if (!t) { setDpadDir(null); return; }
    if (e.type === 'touchstart') {
        if(handleRTPresentsInteraction()) return;
        if(handleMenuInteraction()) return;
        if(!audioUnlocked) { audioUnlocked = true; }
        resumePendingMusic();
        tryTriggerMusicOnInput();
    }
    setDpadDir(dpadDirFromPoint(t.clientX, t.clientY));
}

dpadContainer.addEventListener('touchstart', dpadTouchHandler, {passive: false});
dpadContainer.addEventListener('touchmove', dpadTouchHandler, {passive: false});
dpadContainer.addEventListener('touchend', e => { if(e.cancelable) e.preventDefault(); setDpadDir(null); }, {passive: false});
dpadContainer.addEventListener('touchcancel', () => setDpadDir(null));

// Global safety net: clear controls only when NO remaining fingers are on them
document.addEventListener('touchend', (e) => {
    const remaining = e.touches;
    // Check dpad: only clear if no remaining finger is on it
    if (activeDpadDir) {
        const r = dpadContainer.getBoundingClientRect();
        let dpadHeld = false;
        for (let i = 0; i < remaining.length; i++) {
            const t = remaining[i];
            if (t.clientX >= r.left && t.clientX <= r.right && t.clientY >= r.top && t.clientY <= r.bottom) {
                dpadHeld = true;
                break;
            }
        }
        if (!dpadHeld) setDpadDir(null);
    }
    // Check action: only clear if no remaining finger is on it
    if (keys['action']) {
        const r = actionBtn.getBoundingClientRect();
        let actionHeld = false;
        for (let i = 0; i < remaining.length; i++) {
            const t = remaining[i];
            if (t.clientX >= r.left && t.clientX <= r.right && t.clientY >= r.top && t.clientY <= r.bottom) {
                actionHeld = true;
                break;
            }
        }
        if (!actionHeld) {
            keys['action'] = false;
            actionBtn.classList.remove('active');
        }
    }
});
document.addEventListener('touchcancel', () => {
    setDpadDir(null);
    keys['action'] = false;
    actionBtn.classList.remove('active');
});

// Mouse fallback for d-pad buttons (desktop) — use setDpadDir for consistency
document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('mousedown', e => {
        if(e.cancelable) e.preventDefault();
        if(handleRTPresentsInteraction()) return;
        if(handleMenuInteraction()) return;
        if(!audioUnlocked) { audioUnlocked = true; }
        resumePendingMusic();
        tryTriggerMusicOnInput();
        setDpadDir(btn.dataset.dir);
    });
    btn.addEventListener('mouseup', e => {
        if(e.cancelable) e.preventDefault();
        setDpadDir(null);
    });
});

const actionBtn = document.getElementById('action-btn');
actionBtn.addEventListener('touchstart', e => {
    if(e.cancelable) e.preventDefault();
    if(handleRTPresentsInteraction()) return;
    if(handleMenuInteraction()) return;
    if(!audioUnlocked) { audioUnlocked = true; }
    resumePendingMusic();
    tryTriggerMusicOnInput();
    keys['action'] = true;
    actionBtn.classList.add('active');
}, {passive: false});

actionBtn.addEventListener('touchend', e => {
    if(e.cancelable) e.preventDefault();
    keys['action'] = false;
    actionBtn.classList.remove('active');
}, {passive: false});

actionBtn.addEventListener('touchcancel', () => {
    keys['action'] = false;
    actionBtn.classList.remove('active');
});

document.getElementById('action-btn').addEventListener('mousedown', e => {
    if(e.cancelable) e.preventDefault();
    
    if(handleRTPresentsInteraction()) return;
    if(handleMenuInteraction()) return;
    
    if(!audioUnlocked) {
        audioUnlocked = true;
    }
    
    resumePendingMusic();
    tryTriggerMusicOnInput();
    
    keys['action'] = true;
});

document.getElementById('action-btn').addEventListener('mouseup', e => {
    if(e.cancelable) e.preventDefault();
    keys['action'] = false;
});

// Prevent mobile scroll, bounce, and pinch-zoom on the game page
document.addEventListener('touchmove', e => { if(e.cancelable) e.preventDefault(); }, {passive: false});

</script>
</body>
</html>


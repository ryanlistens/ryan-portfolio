<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mullet Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background: #f5f2ec;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            padding: 20px;
        }
        #game-frame {
            background: #4d443d;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 750px;
            width: 100%;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            padding: 12px 20px;
            background: #2b2b2b;
            color: #f5f2ec;
            font-size: 18px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .heart { color: #e74c3c; font-size: 20px; }
        canvas {
            display: block;
            border: 4px solid #2b2b2b;
            border-radius: 6px;
            width: 100%;
            background: #e8e6dc;
        }
        #controls-section {
            margin-top: 20px;
            padding: 20px;
            background: #fffdf6;
            border-radius: 8px;
            border: 2px solid #e8e6dc;
        }
        #controls-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 30px;
            align-items: center;
            justify-items: center;
        }
        #dpad-container {
            display: grid;
            grid-template: repeat(3, 65px) / repeat(3, 65px);
            gap: 8px;
        }
        .control-btn {
            background: linear-gradient(145deg, #005f99, #004a7c);
            border: 3px solid #2b2b2b;
            border-radius: 8px;
            color: #f5f2ec;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            transition: all 0.1s;
        }
        .control-btn:active {
            background: linear-gradient(145deg, #004a7c, #003d66);
            transform: translateY(2px);
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }
        #action-btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4d443d, #3a342f);
            border: 5px solid #2b2b2b;
            color: #f5f2ec;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        #action-btn:active {
            background: linear-gradient(145deg, #3a342f, #2b2520);
            transform: scale(0.95);
        }
        #start-btn {
            display: block;
            margin: 20px auto 0;
            padding: 18px 60px;
            background: linear-gradient(145deg, #005f99, #004a7c);
            color: #f5f2ec;
            border: 3px solid #2b2b2b;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        #start-btn:hover {
            background: linear-gradient(145deg, #004a7c, #003d66);
            transform: translateY(-2px);
        }
        .empty { background: none; border: none; }
        @media (max-width: 600px) {
            #controls-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="game-frame">
        <div id="hud">
            <span>LEVEL <span id="level">1</span></span>
            <span>SCORE <span id="score">0</span></span>
            <span><span id="timer">60</span>s</span>
            <span id="lives"></span>
        </div>
        <canvas id="game" width="700" height="500"></canvas>
        <div id="controls-section">
            <div id="controls-grid">
                <div id="dpad-container">
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="up">▲</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="left">◄</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="right">►</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="down">▼</button>
                    <div class="empty"></div>
                </div>
                <button id="action-btn">ACTION</button>
            </div>
        </div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
    </div>

<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    let state = 'menu', level = 1, score = 0, timer = 60, lives = 2, frame = 0, cardTimer = 0, menuChoice = 0;
    let player = { x: 350, y: 380, holding: null };
    let computer = { x: 120, y: 320 };
    let ui = { show: false, selectedColor: 0, confirming: false };
    let npcs = [], cracks = [], keys = {};
    
    const COLORS = [
        { name: 'RED', hex: '#e74c3c' },
        { name: 'GREEN', hex: '#27ae60' },
        { name: 'BLUE', hex: '#005f99' },
        { name: 'YELLOW', hex: '#f39c12' }
    ];
    
    function updateLives() {
        let html = '';
        for (let i = 0; i < lives; i++) html += '<span class="heart">♥</span>';
        for (let i = lives; i < 2; i++) html += '<span class="heart" style="opacity:0.3">♥</span>';
        document.getElementById('lives').innerHTML = html;
    }
    
    function initLevel(lv) {
        level = lv;
        npcs = [];
        cracks = [];
        player.holding = null;
        ui = { show: false, selectedColor: 0, confirming: false };
        const count = level >= 2 ? 4 : 3;
        const positions = level >= 2 ? [180, 300, 420, 540] : [230, 390, 550];
        for (let i = 0; i < count; i++) {
            npcs.push({
                x: positions[i], y: 340, color: COLORS[i], state: 'happy', needsDoc: false, fixAnim: 0
            });
        }
    }
    
    function startGame() {
        state = 'levelCard';
        level = 1;
        score = 0;
        timer = 60;
        lives = 2;
        cardTimer = 0;
        player = { x: 350, y: 380, holding: null };
        initLevel(1);
        document.getElementById('start-btn').style.display = 'none';
        updateLives();
        gameLoop();
    }
    
    function spawnCracks() {
        if (state !== 'playing') return;
        const delay = level === 1 ? 5000 : level === 2 ? 4000 : 3000;
        setTimeout(() => {
            if (state === 'playing') {
                const available = npcs.filter(n => n.state === 'happy');
                if (available.length > 0) {
                    const npc = available[Math.floor(Math.random() * available.length)];
                    cracks.push({ npc, time: Date.now(), max: 12000 });
                    npc.state = 'stressed';
                    npc.needsDoc = true;
                }
            }
            spawnCracks();
        }, delay);
    }
    
    function drawMulletPro(x, y) {
        const s = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x-7*s, y-16*s, 14*s, 4*s);
        ctx.fillRect(x-8*s, y-12*s, 16*s, 10*s);
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-5*s, y-12*s, 10*s, 10*s);
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3*s, y-9*s, 2*s, 2*s);
        ctx.fillRect(x+s, y-9*s, 2*s, 2*s);
        ctx.fillRect(x-2*s, y-5*s, 4*s, s);
        ctx.fillStyle = '#800020';
        ctx.fillRect(x-7*s, y-2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x-7*s, y-2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x-3*s, y-2*s, 6*s, 4*s);
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-9*s, y, 2*s, 7*s);
        ctx.fillRect(x+7*s, y, 2*s, 7*s);
        ctx.fillStyle = '#a4c2db';
        const legAnim = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x-5*s, y+8*s, 4*s, 8*s);
        ctx.fillRect(x+s, y+8*s, 4*s, 8*s);
        ctx.fillStyle = '#654321';
        ctx.fillRect(x-5*s, y+16*s + legAnim, 4*s, 2*s);
        ctx.fillRect(x+s, y+16*s - legAnim, 4*s, 2*s);
    }
    
    function drawNPC(npc) {
        const x = npc.x, y = npc.y, s = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = npc.color.hex;
        ctx.fillRect(x-6*s, y-16*s, 12*s, 4*s);
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x-4*s, y-13*s, 8*s, 8*s);
        ctx.fillStyle = '#000';
        if (npc.state === 'stressed') {
            ctx.fillRect(x-3*s, y-10*s, 2*s, 3*s);
            ctx.fillRect(x+s, y-10*s, 2*s, 3*s);
            ctx.fillRect(x-s, y-7*s, 2*s, s);
            ctx.fillStyle = '#f5c89a';
            ctx.fillRect(x-8*s, y-9*s, 3*s, 4*s);
        } else {
            ctx.fillRect(x-3*s, y-10*s, 2*s, 2*s);
            ctx.fillRect(x+s, y-10*s, 2*s, 2*s);
            ctx.fillRect(x-2*s, y-7*s, 4*s, s);
        }
        ctx.fillStyle = npc.color.hex;
        ctx.fillRect(x-6*s, y-5*s, 12*s, 11*s);
        ctx.fillRect(x-8*s, y-3*s, 2*s, 7*s);
        ctx.fillRect(x+6*s, y-3*s, 2*s, 7*s);
        ctx.fillRect(x-5*s, y+6*s, 4*s, 7*s);
        ctx.fillRect(x+s, y+6*s, 4*s, 7*s);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x-5*s, y+13*s, 4*s, 3*s);
        ctx.fillRect(x+s, y+13*s, 4*s, 3*s);
        if (npc.needsDoc) {
            ctx.fillStyle = '#f39c12';
            ctx.font = 'bold 28px monospace';
            ctx.fillText('!', x + 20, y - 24);
        }
        if (npc.state === 'fixing') {
            ctx.save();
            ctx.translate(x, 220);
            ctx.rotate(npc.fixAnim);
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(-8*s, -2*s, 16*s, 4*s);
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(-7*s, -s, 14*s, 2*s);
            ctx.restore();
        }
    }function drawScene() {
if (state === ‘menu’) {
ctx.fillStyle = ‘#1a1a2e’;
ctx.fillRect(0, 0, 700, 500);
const textGrad = ctx.createLinearGradient(200, 100, 500, 200);
textGrad.addColorStop(0, ‘#ff6b35’);
textGrad.addColorStop(0.5, ‘#f7931e’);
textGrad.addColorStop(1, ‘#ffd700’);
ctx.font = ‘bold 72px Arial’;
ctx.textAlign = ‘center’;
ctx.strokeStyle = ‘#000’;
ctx.lineWidth = 8;
ctx.strokeText(‘MULLET PRO’, 350, 150);
ctx.fillStyle = textGrad;
ctx.fillText(‘MULLET PRO’, 350, 150);
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘22px Arial’;
ctx.fillText(‘DELIVER THE DOCUMENTS’, 350, 200);
ctx.fillStyle = ‘#e74c3c’;
ctx.font = ‘bold 24px Arial’;
ctx.fillText(‘STOP THE CATASTROPHE!’, 350, 230);
drawMulletPro(350, 340);
if (Math.floor(frame / 30) % 2 === 0) {
ctx.fillStyle = ‘#ffd700’;
ctx.font = ‘bold 28px Arial’;
ctx.fillText(‘PRESS START’, 350, 430);
}
return;
}
if (state === ‘levelCard’) {
ctx.fillStyle = ‘#1a1a2e’;
ctx.fillRect(0, 0, 700, 500);
const lvlGrad = ctx.createLinearGradient(200, 150, 500, 250);
lvlGrad.addColorStop(0, ‘#ff6b35’);
lvlGrad.addColorStop(1, ‘#ffd700’);
ctx.font = ‘bold 80px Arial’;
ctx.textAlign = ‘center’;
ctx.strokeStyle = ‘#000’;
ctx.lineWidth = 8;
ctx.strokeText(‘LEVEL ’ + level, 350, 200);
ctx.fillStyle = lvlGrad;
ctx.fillText(‘LEVEL ’ + level, 350, 200);
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘bold 32px Arial’;
const msgs = [’’, ‘TRAINING DAY’, ‘PRESSURE RISING!’, ‘MAXIMUM CHAOS!’];
ctx.fillText(msgs[level], 350, 270);
if (cardTimer > 60 && Math.floor(frame / 30) % 2 === 0) {
ctx.fillStyle = ‘#ffd700’;
ctx.font = ‘bold 32px Arial’;
ctx.fillText(‘GET READY!’, 350, 370);
}
return;
}
if (state === ‘over’ || state === ‘win’) {
ctx.fillStyle = ‘#1a1a2e’;
ctx.fillRect(0, 0, 700, 500);
ctx.fillStyle = state === ‘win’ ? ‘#27ae60’ : ‘#e74c3c’;
ctx.font = ‘bold 56px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(state === ‘win’ ? “YOU’RE HIRED!” : “YOU’RE FIRED!”, 350, 180);
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘32px Arial’;
ctx.fillText(’FINAL SCORE: ’ + score, 350, 240);
ctx.font = ‘24px Arial’;
ctx.fillStyle = menuChoice === 0 ? ‘#ffd700’ : ‘#999’;
ctx.fillText(‘▶ Return to Mullet.pro’, 350, 320);
ctx.fillStyle = menuChoice === 1 ? ‘#ffd700’ : ‘#999’;
ctx.fillText(‘▶ Keep documenting!’, 350, 370);
return;
}
ctx.fillStyle = ‘#e8e6dc’;
ctx.fillRect(0, 0, 700, 500);
ctx.fillStyle = ‘#808080’;
ctx.fillRect(0, 400, 700, 100);
for (let i = 0; i < 20; i++) {
for (let j = 0; j < 3; j++) {
ctx.strokeStyle = ‘#666’;
ctx.lineWidth = 1;
ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
}
}
ctx.fillStyle = ‘#f5f5dc’;
ctx.globalAlpha = 0.3;
ctx.fillRect(100, 20, 80, 10);
ctx.fillRect(300, 20, 80, 10);
ctx.fillRect(500, 20, 80, 10);
ctx.globalAlpha = 1;
ctx.fillStyle = ‘#2b2b2b’;
ctx.fillRect(20, 200, 180, 70);
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘bold 24px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(‘PIPETECH’, 110, 230);
ctx.font = ‘9px Arial’;
ctx.fillText(‘Global manufacturer’, 110, 248);
ctx.fillText(‘of pipe dreams’, 110, 258);
for (let i = 0; i < 4; i++) {
ctx.strokeStyle = COLORS[i].hex;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(45 + i * 30, 265);
ctx.lineTo(45 + i * 30, 268);
ctx.stroke();
}
ctx.fillStyle = ‘#c4bfad’;
ctx.fillRect(0, 410, 700, 90);
ctx.fillStyle = ‘#4d443d’;
ctx.fillRect(computer.x - 25, computer.y + 10, 50, 50);
ctx.fillStyle = ‘#2b2b2b’;
ctx.fillRect(computer.x - 22, computer.y - 50, 44, 58);
ctx.fillStyle = ‘#004a7c’;
ctx.fillRect(computer.x - 18, computer.y - 46, 36, 50);
ctx.fillStyle = ‘rgba(255,255,255,0.2)’;
ctx.fillRect(computer.x - 18, computer.y - 46, 36, 10);
ctx.fillStyle = ‘#2b2b2b’;
ctx.font = ‘bold 9px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(‘PRINT DOC’, computer.x, computer.y + 35);
for (let npc of npcs) {
ctx.strokeStyle = npc.color.hex;
ctx.lineWidth = 14;
ctx.beginPath();
ctx.moveTo(npc.x, 60);
ctx.lineTo(npc.x, npc.y - 60);
ctx.stroke();
ctx.strokeStyle = ‘rgba(255,255,255,0.3)’;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(npc.x - 4, 60);
ctx.lineTo(npc.x - 4, npc.y - 60);
ctx.stroke();
const crack = cracks.find(c => c.npc === npc);
if (crack) {
const pct = (Date.now() - crack.time) / crack.max;
ctx.fillStyle = npc.color.hex;
ctx.globalAlpha = 0.4 + pct * 0.6;
const sz = 18 + pct * 28;
for (let i = 0; i < 3; i++) {
ctx.fillRect(npc.x - sz/2 + (i-1)*5, 210 + i*8, sz, 8);
}
ctx.globalAlpha = 1;
}
drawNPC(npc);
}
drawMulletPro(player.x, player.y);
if (player.holding) {
const col = COLORS.find(c => c.name === player.holding);
ctx.fillStyle = col.hex;
ctx.fillRect(player.x - 20, player.y - 65, 40, 28);
ctx.fillStyle = ‘#2b2b2b’;
ctx.font = ‘bold 14px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(col.name, player.x, player.y - 45);
}
if (ui.show) {
ctx.fillStyle = ‘rgba(0,0,0,0.85)’;
ctx.fillRect(0, 340, 700, 160);
if (!ui.confirming) {
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘bold 22px Arial’;
ctx.textAlign = ‘left’;
ctx.fillText(‘SELECT COLOR:’, 30, 375);
for (let i = 0; i < 4; i++) {
const selected = i === ui.selectedColor;
ctx.strokeStyle = selected ? ‘#f5f2ec’ : ‘#666’;
ctx.lineWidth = selected ? 4 : 2;
ctx.fillStyle = COLORS[i].hex;
ctx.fillRect(30 + i * 160, 390, 140, 70);
ctx.strokeRect(30 + i * 160, 390, 140, 70);
ctx.fillStyle = ‘#2b2b2b’;
ctx.font = ‘bold 16px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(COLORS[i].name, 100 + i * 160, 430);
}
} else {
const col = COLORS[ui.selectedColor];
ctx.fillStyle = ‘#f5f2ec’;
ctx.font = ‘bold 28px Arial’;
ctx.textAlign = ‘center’;
ctx.fillText(‘PRINT ’ + col.name + ’ DOC?’, 350, 385);
ctx.fillStyle = col.hex;
ctx.fillRect(270, 410, 160, 60);
ctx.fillStyle = ‘#2b2b2b’;
ctx.font = ‘bold 20px Arial’;
ctx.fillText(‘CONFIRM’, 350, 445);
}
}
}

```
function update() {
    if (state === 'levelCard') {
        cardTimer++;
        if (cardTimer > 120) {
            state = 'playing';
            spawnCracks();
        }
        return;
    }
    if (state === 'over' || state === 'win') {
        if ((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
            menuChoice = 0;
            keys.upProcessed = true;
        }
        if ((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
            menuChoice = 1;
            keys.downProcessed = true;
        }
        if (!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
        if (!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;
        if (keys[' '] || keys['action']) {
            keys[' '] = false;
            keys['action'] = false;
            if (menuChoice === 0) {
                window.location.href = '/';
            } else {
                state = 'menu';
                document.getElementById('start-btn').style.display = 'block';
                document.getElementById('start-btn').textContent = 'START GAME';
            }
        }
        return;
    }
    if (state !== 'playing') return;
    if (keys['ArrowLeft'] || keys['left']) player.x = Math.max(60, player.x - 4);
    if (keys['ArrowRight'] || keys['right']) player.x = Math.min(640, player.x + 4);
    if (keys[' '] || keys['action']) {
        keys[' '] = false;
        keys['action'] = false;
        const atComputer = Math.abs(player.x - computer.x) < 60;
        if (atComputer && !player.holding && !ui.show) {
            ui.show = true;
            return;
        }
        if (ui.show && !ui.confirming) {
            ui.confirming = true;
            return;
        }
        if (ui.show && ui.confirming) {
            player.holding = COLORS[ui.selectedColor].name;
            ui.show = false;
            ui.confirming = false;
            ui.selectedColor = 0;
            return;
        }
        if (player.holding) {
            for (let npc of npcs) {
                if (Math.abs(player.x - npc.x) < 45 && npc.needsDoc && npc.color.name === player.holding) {
                    npc.needsDoc = false;
                    npc.state = 'fixing';
                    npc.fixAnim = 0;
                    player.holding = null;
                    score += 150 * level;
                    const fixInterval = setInterval(() => { npc.fixAnim += 0.3; }, 50);
                    setTimeout(() => {
                        clearInterval(fixInterval);
                        cracks = cracks.filter(c => c.npc !== npc);
                        npc.state = 'happy';
                    }, 2000);
                    break;
                }
            }
        }
    }
    if (ui.show && !ui.confirming) {
        if ((keys['ArrowLeft'] || keys['left']) && !keys.leftProcessed) {
            ui.selectedColor = Math.max(0, ui.selectedColor - 1);
            keys.leftProcessed = true;
        }
        if ((keys['ArrowRight'] || keys['right']) && !keys.rightProcessed) {
            ui.selectedColor = Math.min(3, ui.selectedColor + 1);
            keys.rightProcessed = true;
        }
        if (!keys['ArrowLeft'] && !keys['left']) keys.leftProcessed = false;
        if (!keys['ArrowRight'] && !keys['right']) keys.rightProcessed = false;
    }
    for (let crack of cracks) {
        if (Date.now() - crack.time > crack.max) {
            lives--;
            updateLives();
            if (lives <= 0) {
                state = 'over';
                menuChoice = 0;
            } else {
                initLevel(level);
            }
            return;
        }
    }
}

function nextLevel() {
    if (level < 3) {
        level++;
        timer = 60;
        state = 'levelCard';
        cardTimer = 0;
        initLevel(level);
    } else {
        state = 'win';
        menuChoice = 0;
    }
}

let lastTime = Date.now(), counter = 0;

function gameLoop() {
    if (state !== 'playing' && state !== 'levelCard' && state !== 'over' && state !== 'win') return;
    frame++;
    const now = Date.now();
    counter += now - lastTime;
    lastTime = now;
    if (state === 'playing' && counter >= 1000) {
        timer--;
        counter = 0;
        document.getElementById('timer').textContent = timer;
        if (timer <= 0) nextLevel();
    }
    update();
    drawScene();
    document.getElementById('level').textContent = level;
    document.getElementById('score').textContent = score;
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => { keys[e.key] = true; });
document.addEventListener('keyup', e => { keys[e.key] = false; });
document.querySelectorAll('.control-btn').forEach(btn => {
    ['touchstart', 'mousedown'].forEach(evt => {
        btn.addEventListener(evt, e => {
            e.preventDefault();
            keys[btn.dataset.dir] = true;
        });
    });
    ['touchend', 'mouseup'].forEach(evt => {
        btn.addEventListener(evt, e => {
            e.preventDefault();
            keys[btn.dataset.dir] = false;
        });
    });
});
['touchstart', 'mousedown'].forEach(evt => {
    document.getElementById('action-btn').addEventListener(evt, e => {
        e.preventDefault();
        keys['action'] = true;
    });
});
drawScene();
```

</script>
</body>
</html>

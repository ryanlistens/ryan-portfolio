<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2b2b2b">
    <title>Mullet Pro - Refined Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }
        #game-frame {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #2b2520 0%, #1a1a1a 100%);
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 12px 20px;
            background: linear-gradient(180deg, rgba(27,27,27,0.85) 0%, rgba(27,27,27,0) 100%);
            color: #f5f2ec;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }
        .heart {
            color: #e74c3c;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(231,76,60,0.6);
        }
        #game-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #e8e6dc;
            image-rendering: auto;
        }
        #controls-section {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(0deg, rgba(27,27,27,0.7) 0%, rgba(27,27,27,0) 100%);
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }
        #controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            align-items: center;
            max-width: 650px;
            margin: 0 auto;
            pointer-events: all;
        }
        #dpad-container {
            display: grid;
            grid-template: repeat(3, 75px) / repeat(3, 75px);
            gap: 12px;
            justify-self: start;
        }
        .control-btn {
            background: linear-gradient(145deg, #005f99, #004a7c);
            border: 3px solid rgba(43,43,43,0.9);
            border-radius: 14px;
            color: #f5f2ec;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.25);
            transition: all 0.1s;
            position: relative;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .control-btn::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 15%;
            right: 15%;
            height: 35%;
            background: linear-gradient(180deg, rgba(255,255,255,0.35) 0%, transparent 100%);
            border-radius: 10px 10px 0 0;
            pointer-events: none;
        }
        .control-btn:active {
            background: linear-gradient(145deg, #004a7c, #003d66);
            transform: translateY(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.15);
        }
        #action-btn {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4d443d, #3a342f);
            border: 5px solid rgba(43,43,43,0.9);
            color: #f5f2ec;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 3px 0 rgba(255,255,255,0.25);
            transition: all 0.1s;
            position: relative;
            justify-self: end;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        #action-btn::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 20%;
            right: 20%;
            height: 30%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
        }
        #action-btn:active {
            background: linear-gradient(145deg, #3a342f, #2b2520);
            transform: scale(0.93);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.15);
        }
        .empty { background: none; border: none; }
        @media (max-width: 600px) {
            #controls-grid {
                gap: 25px;
            }
            #dpad-container {
                grid-template: repeat(3, 65px) / repeat(3, 65px);
                gap: 8px;
            }
            .control-btn {
                font-size: 26px;
            }
            #action-btn {
                width: 130px;
                height: 130px;
                font-size: 19px;
            }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            #controls-section {
                padding: 12px;
            }
            #dpad-container {
                grid-template: repeat(3, 55px) / repeat(3, 55px);
                gap: 6px;
            }
            .control-btn {
                font-size: 22px;
            }
            #action-btn {
                width: 110px;
                height: 110px;
                font-size: 17px;
            }
            #hud {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="game-frame">
        <div id="hud">
            <span>LEVEL <span id="level">1</span></span>
            <span>SCORE <span id="score">0</span></span>
            <span><span id="timer">60</span>s</span>
            <span id="lives"></span>
        </div>
        <div id="game-container">
            <canvas id="game"></canvas>
        </div>
        <div id="controls-section">
            <div id="controls-grid">
                <div id="dpad-container">
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="up">▲</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="left">◄</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="right">►</button>
                    <div class="empty"></div>
                    <button class="control-btn" data-dir="down">▼</button>
                    <div class="empty"></div>
                </div>
                <button id="action-btn">ACTION</button>
            </div>
        </div>
    </div>
<script>

// ============================================================================
// CANVAS SETUP & RESPONSIVE HANDLING
// ============================================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game dimensions - internal rendering resolution
const GAME_WIDTH = 700;
const GAME_HEIGHT = 500;

// Dynamic canvas sizing to fill the screen
function resizeCanvas() {
    const container = document.getElementById('game-container');
    const rect = container.getBoundingClientRect();

    // Set canvas display size to fill container
    canvas.width = rect.width;
    canvas.height = rect.height;

    // Calculate scale to fill screen while maintaining aspect ratio
    const scaleX = canvas.width / GAME_WIDTH;
    const scaleY = canvas.height / GAME_HEIGHT;
    const scale = Math.min(scaleX, scaleY);

    // Calculate offset to center the game
    const offsetX = (canvas.width - GAME_WIDTH * scale) / 2;
    const offsetY = (canvas.height - GAME_HEIGHT * scale) / 2;

    // Store scale and offset for input handling
    canvas.gameScale = scale;
    canvas.gameOffsetX = offsetX;
    canvas.gameOffsetY = offsetY;
}

// Initial resize and add event listener
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => {
    setTimeout(resizeCanvas, 100);
});

// Enable image smoothing for better graphics
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

// Haptic feedback function for mobile
function hapticFeedback() {
    if (navigator.vibrate) {
        navigator.vibrate(10);
    }
}

// ============================================================================
// GAME CONSTANTS & STATE
// ============================================================================

const COLORS = [
    {name:'RED', hex:'#e74c3c'},
    {name:'GREEN', hex:'#27ae60'},
    {name:'BLUE', hex:'#005f99'},
    {name:'YELLOW', hex:'#f39c12'}
];

let state = 'menu';
let level = 1;
let score = 0;
let timer = 60;
let lives = 3;
let frame = 0;
let cardTimer = 0;
let menuChoice = 0;

let player = {
    x: 350,
    y: 380,
    holding: null,
    facing: 'forward',
    lastMove: 0
};

let computer = {x: 180, y: 350};
let printer3d = {x: 50, y: 360};

let ui = {
    show: false,
    selectedColor: 0,
    confirming: false,
    gunUI: false,
    gunChoice: 0
};

let npcs = [];
let cracks = [];
let keys = {};
let explosions = [];
let bullets = [];
let muzzleFlashes = [];

let boss = {
    active: false,
    x: 750,
    y: 380,
    needsColor: null,
    walking: false,
    spawnTime: 0,
    angry: false,
    facing: 'left',
    bossKills: 0
};

let ghostGun = {
    hasGun: false,
    ammo: 0,
    printing: false,
    printProgress: 0
};

let fadeAlpha = 0;
let fadeIn = false;
let fadeOut = false;
let resetting = false;

// ============================================================================
// GAME FUNCTIONS
// ============================================================================

function updateLives() {
    let h = '';
    for(let i = 0; i < lives; i++) {
        h += '<span class="heart">♥</span>';
    }
    for(let i = lives; i < 3; i++) {
        h += '<span class="heart" style="opacity:0.3">♥</span>';
    }
    document.getElementById('lives').innerHTML = h;
}

function initLevel(lv) {
    level = lv;
    npcs = [];
    cracks = [];
    explosions = [];
    bullets = [];
    muzzleFlashes = [];
    player.holding = null;
    player.facing = 'forward';
    player.x = 350;
    ui = {show: false, selectedColor: 0, confirming: false, gunUI: false, gunChoice: 0};

    boss.active = false;
    boss.x = 750;
    boss.needsColor = null;
    boss.walking = false;
    boss.spawnTime = 0;
    boss.angry = false;
    boss.facing = 'left';

    resetting = false;
    fadeAlpha = 0;
    fadeIn = false;
    fadeOut = false;

    if(level === 1) {
        npcs.push({x:280, y:340, color:COLORS[0], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:390, y:340, color:COLORS[1], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:500, y:340, color:COLORS[2], state:'happy', needsDoc:false, fixAnim:0});
    } else {
        npcs.push({x:260, y:340, color:COLORS[0], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:360, y:340, color:COLORS[1], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:460, y:340, color:COLORS[2], state:'happy', needsDoc:false, fixAnim:0});
        npcs.push({x:560, y:340, color:COLORS[3], state:'happy', needsDoc:false, fixAnim:0});
    }

    if(level === 3) {
        setTimeout(() => spawnBoss(), 5000);
    }
    if(level === 4) {
        setTimeout(() => spawnBoss(), 3000);
    }
}

function startGame() {
    state = 'levelCard';
    level = 1;
    score = 0;
    timer = 60;
    lives = 3;
    cardTimer = 0;
    boss.bossKills = 0;
    ghostGun = {hasGun: false, ammo: 0, printing: false, printProgress: 0};
    initLevel(1);
    updateLives();
}

function spawnCracks() {
    if(state !== 'playing' || resetting) return;

    const delay = level === 1 ? 5000 : level === 4 ? 3000 : 4000;

    setTimeout(() => {
        if(state === 'playing' && !resetting) {
            const available = npcs.filter(n => n.state === 'happy');
            if(available.length > 0) {
                const npc = available[Math.floor(Math.random() * available.length)];
                cracks.push({npc: npc, time: Date.now(), max: 12000});
                npc.state = 'stressed';
                npc.needsDoc = true;
            }
        }
        spawnCracks();
    }, delay);
}

function spawnBoss() {
    if((level !== 3 && level !== 4) || state !== 'playing' || resetting) return;
    if(!boss.active) {
        boss.active = true;
        boss.x = 750;
        boss.needsColor = COLORS[Math.floor(Math.random() * 4)].name;
        boss.walking = true;
        boss.spawnTime = 0;
        boss.angry = false;
        boss.facing = 'left';

        const nextSpawn = level === 4 ? 12000 : 18000;
        setTimeout(() => spawnBoss(), nextSpawn);
    }
}

function createExplosion(x, y) {
    explosions.push({x, y, radius: 0, maxRadius: 100, alpha: 1, particles: []});
    for(let i = 0; i < 20; i++) {
        explosions[explosions.length - 1].particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8 - 2,
            life: 1
        });
    }
}

function createMuzzleFlash(x, y, facing) {
    muzzleFlashes.push({x, y, facing, life: 10});
}

function checkPromotion() {
    if(boss.bossKills >= 3) {
        state = 'promotion';
        menuChoice = 0;
    }
}

// ============================================================================
// DRAWING FUNCTIONS
// ============================================================================

function drawMulletPro(x, y, facing) {
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    if(facing === 'left') {
        // Hair
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 5*s, y - 16*s, 12*s, 4*s);
        ctx.fillRect(x - 6*s, y - 12*s, 14*s, 10*s);

        // Face
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        // Eyes and mouth
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 3*s, y - 5*s, 3*s, s);

        // Body
        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x + 5*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 9*s, y, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y, 2*s, 7*s);

        // Legs
        ctx.fillStyle = '#a4c2db';
        const legL = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        // Shoes
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + legL, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legL, 4*s, 2*s);

    } else if(facing === 'right') {
        // Hair
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 7*s, y - 16*s, 12*s, 4*s);
        ctx.fillRect(x - 8*s, y - 12*s, 14*s, 10*s);

        // Face
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        // Eyes and mouth
        ctx.fillStyle = '#000';
        ctx.fillRect(x, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x, y - 5*s, 3*s, s);

        // Body
        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 9*s, y, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y, 2*s, 7*s);

        // Legs
        ctx.fillStyle = '#a4c2db';
        const legR = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        // Shoes
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + legR, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legR, 4*s, 2*s);

    } else {
        // Hair
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x - 7*s, y - 16*s, 14*s, 4*s);
        ctx.fillRect(x - 8*s, y - 12*s, 16*s, 10*s);

        // Face
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        // Eyes and mouth
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 3*s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x + s, y - 9*s, 2*s, 2*s);
        ctx.fillRect(x - 2*s, y - 5*s, 4*s, s);

        // Body
        ctx.fillStyle = '#800020';
        ctx.fillRect(x - 7*s, y - 2*s, 14*s, 10*s);
        ctx.fillStyle = '#600018';
        ctx.fillRect(x - 7*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 3*s, y - 2*s, 6*s, 4*s);

        // Arms
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 9*s, y, 2*s, 7*s);
        ctx.fillRect(x + 7*s, y, 2*s, 7*s);

        // Legs
        ctx.fillStyle = '#a4c2db';
        const leg = Math.sin(frame * 0.15) * 2;
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        // Shoes
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - 5*s, y + 16*s + leg, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - leg, 4*s, 2*s);
    }
}

function drawBoss(x, y, facing) {
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    const skinColor = boss.angry ? '#cc0000' : '#f5c89a';

    if(facing === 'left') {
        // Head
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        // Face
        ctx.fillStyle = '#000';
        if(boss.angry) {
            ctx.fillRect(x - 2*s, y - 10*s, 3*s, s);
            ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x - 2*s, y - 6*s, 2*s, s);
        } else {
            ctx.fillRect(x - 2*s, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x - 3*s, y - 6*s, 3*s, s);
        }

        // Shirt
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 6*s, y - 2*s, 12*s, 10*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x + 4*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 10*s);

        // Arms
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 8*s, y, 2*s, 6*s);
        ctx.fillRect(x + 6*s, y, 2*s, 6*s);

        // Pants
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        // Shoes
        ctx.fillStyle = '#1a1a1a';
        const legL = boss.walking ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 16*s + legL, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legL, 4*s, 2*s);

    } else if(facing === 'right') {
        // Head
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 5*s, y - 12*s, 10*s, 10*s);

        // Face
        ctx.fillStyle = '#000';
        if(boss.angry) {
            ctx.fillRect(x - s, y - 10*s, 3*s, s);
            ctx.fillRect(x, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x, y - 6*s, 2*s, s);
        } else {
            ctx.fillRect(x, y - 9*s, 2*s, 2*s);
            ctx.fillRect(x, y - 6*s, 3*s, s);
        }

        // Shirt
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 6*s, y - 2*s, 12*s, 10*s);
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x - 6*s, y - 2*s, 2*s, 10*s);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x - 2*s, y - 2*s, 4*s, 10*s);

        // Arms
        ctx.fillStyle = skinColor;
        ctx.fillRect(x - 8*s, y, 2*s, 6*s);
        ctx.fillRect(x + 6*s, y, 2*s, 6*s);

        // Pants
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(x - 5*s, y + 8*s, 4*s, 8*s);
        ctx.fillRect(x + s, y + 8*s, 4*s, 8*s);

        // Shoes
        ctx.fillStyle = '#1a1a1a';
        const legR = boss.walking ? Math.sin(frame * 0.2) * 3 : 0;
        ctx.fillRect(x - 5*s, y + 16*s + legR, 4*s, 2*s);
        ctx.fillRect(x + s, y + 16*s - legR, 4*s, 2*s);
    }

    // Thought bubble with needed color
    if(boss.needsColor) {
        const col = COLORS.find(c => c.name === boss.needsColor);
        const bubbleX = facing === 'right' ? x + 10 : x - 70;

        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(bubbleX, y - 55, 60, 30, 8);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bubbleX + (facing === 'right' ? 5 : 55), y - 25);
        ctx.lineTo(bubbleX + (facing === 'right' ? 0 : 60), y - 18);
        ctx.lineTo(bubbleX + (facing === 'right' ? 15 : 45), y - 25);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(col.name, bubbleX + 30, y - 35);
    }
}

function drawNPC(npc) {
    const x = npc.x;
    const y = npc.y;
    const s = 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 32, 10, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hat
    ctx.fillStyle = npc.color.hex;
    ctx.fillRect(x - 6*s, y - 16*s, 12*s, 4*s);

    // Head
    ctx.fillStyle = '#f5c89a';
    ctx.fillRect(x - 4*s, y - 13*s, 8*s, 8*s);

    // Face
    ctx.fillStyle = '#000';
    if(npc.state === 'stressed') {
        ctx.fillRect(x - 3*s, y - 10*s, 2*s, 3*s);
        ctx.fillRect(x + s, y - 10*s, 2*s, 3*s);
        ctx.fillRect(x - s, y - 7*s, 2*s, s);
        ctx.fillStyle = '#f5c89a';
        ctx.fillRect(x - 8*s, y - 9*s, 3*s, 4*s);
    } else {
        ctx.fillRect(x - 3*s, y - 10*s, 2*s, 2*s);
        ctx.fillRect(x + s, y - 10*s, 2*s, 2*s);
        ctx.fillRect(x - 2*s, y - 7*s, 4*s, s);
    }

    // Body and limbs
    ctx.fillStyle = npc.color.hex;
    ctx.fillRect(x - 6*s, y - 5*s, 12*s, 11*s);
    ctx.fillRect(x - 8*s, y - 3*s, 2*s, 7*s);
    ctx.fillRect(x + 6*s, y - 3*s, 2*s, 7*s);
    ctx.fillRect(x - 5*s, y + 6*s, 4*s, 7*s);
    ctx.fillRect(x + s, y + 6*s, 4*s, 7*s);

    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 5*s, y + 13*s, 4*s, 3*s);
    ctx.fillRect(x + s, y + 13*s, 4*s, 3*s);

    // Alert indicator
    if(npc.needsDoc) {
        ctx.fillStyle = '#f39c12';
        ctx.font = 'bold 28px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('!', x + 20, y - 24);
    }

    // Wrench animation
    if(npc.state === 'fixing') {
        ctx.save();
        ctx.translate(x, 220);
        ctx.rotate(npc.fixAnim);
        ctx.fillStyle = '#95a5a6';
        ctx.fillRect(-10*s, -2*s, 20*s, 4*s);
        ctx.fillStyle = '#7f8c8d';
        ctx.fillRect(-9*s, -s, 18*s, 2*s);
        ctx.restore();
    }
}

function drawComputer(x, y) {
    // Base
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x - 30, y, 60, 35);

    // Monitor back
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 25, y - 30, 50, 30);

    // Screen bezel
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x - 22, y - 27, 44, 24);

    // Screen content
    if(ui.show || player.holding) {
        const displayColor = player.holding ?
            COLORS.find(c => c.name === player.holding).hex :
            COLORS[ui.selectedColor].hex;
        ctx.fillStyle = displayColor;
    } else {
        ctx.fillStyle = '#004a7c';
    }
    ctx.fillRect(x - 20, y - 25, 40, 20);

    // Screen glow
    if(ui.show || player.holding) {
        ctx.shadowColor = ui.show ?
            COLORS[ui.selectedColor].hex :
            COLORS.find(c => c.name === player.holding).hex;
        ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x - 20, y - 25, 40, 20);
        ctx.shadowBlur = 0;
    }

    // Screen highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(x - 20, y - 25, 40, 5);

    // Stand
    ctx.fillStyle = '#444';
    ctx.fillRect(x - 5, y, 10, 3);

    // Label
    ctx.fillStyle = '#2b2b2b';
    ctx.font = 'bold 8px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PRINT', x, y + 30);
}

function draw3DPrinter(x, y) {
    // Outer case
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(x - 25, y - 35, 50, 50);

    // Inner case
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x - 20, y - 30, 40, 40);

    // Window
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 18, y - 28, 36, 36);

    // Glass
    ctx.fillStyle = 'rgba(100,150,200,0.3)';
    ctx.fillRect(x - 16, y - 26, 32, 28);

    ctx.strokeStyle = '#555';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - 16, y - 26, 32, 28);

    // Printing progress
    if(ghostGun.printing) {
        const progress = ghostGun.printProgress;
        const gunH = 15 * progress;
        ctx.fillStyle = 'rgba(160,160,160,' + progress + ')';
        ctx.fillRect(x - 6, y + 2 - gunH, 12, gunH);
        ctx.fillRect(x + 6, y - gunH / 2, 5, gunH * 0.4);
    }

    // LED
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(x - 20, y + 5, 4, 4);

    // Label
    ctx.fillStyle = '#2b2b2b';
    ctx.font = 'bold 7px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('3D PRINT', x, y + 18);
}

function drawAmmoCounter(x, y, ammo) {
    // Background panel
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    const panelWidth = 60;
    const panelHeight = 20;
    ctx.fillRect(x - panelWidth/2, y - 65, panelWidth, panelHeight);

    // Border
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - panelWidth/2, y - 65, panelWidth, panelHeight);

    // Ammo count
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(ammo, x - panelWidth/2 + 5, y - 50);

    ctx.fillStyle = '#ccc';
    ctx.font = 'bold 12px Arial';
    ctx.fillText('×', x - panelWidth/2 + 22, y - 50);

    // Bullet icon
    ctx.fillStyle = '#d4af37';
    ctx.fillRect(x - panelWidth/2 + 32, y - 60, 4, 10);
    ctx.fillStyle = '#b8941e';
    ctx.beginPath();
    ctx.moveTo(x - panelWidth/2 + 32, y - 60);
    ctx.lineTo(x - panelWidth/2 + 34, y - 63);
    ctx.lineTo(x - panelWidth/2 + 36, y - 60);
    ctx.fill();
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(x - panelWidth/2 + 32, y - 50, 4, 3);
}

function drawGhostGun(x, y, facing) {
    const offsetX = facing === 'left' ? -35 : facing === 'right' ? 35 : 0;
    const gunX = x + offsetX;
    const gunY = y + 5;

    if(facing === 'left') {
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 18, gunY - 3, 18, 6);
        ctx.fillRect(gunX - 6, gunY - 2, 6, 4);
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX - 18, gunY - 5, 5, 2);
    } else if(facing === 'right') {
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX, gunY - 3, 18, 6);
        ctx.fillRect(gunX, gunY - 2, 6, 4);
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX + 13, gunY - 5, 5, 2);
    } else {
        ctx.fillStyle = '#999';
        ctx.fillRect(gunX - 3, gunY - 3, 6, 18);
        ctx.fillRect(gunX - 2, gunY + 8, 4, 6);
        ctx.fillStyle = '#777';
        ctx.fillRect(gunX - 5, gunY - 3, 2, 5);
    }
}

// ============================================================================
// MAIN SCENE RENDERING
// ============================================================================

function drawScene() {
    // Scale canvas to GAME_WIDTH x GAME_HEIGHT coordinate system
    ctx.save();
    ctx.scale(canvas.width / GAME_WIDTH, canvas.height / GAME_HEIGHT);

    if(state === 'menu') {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        const textGrad = ctx.createLinearGradient(200, 100, 500, 200);
        textGrad.addColorStop(0, '#ff6b35');
        textGrad.addColorStop(0.5, '#f7931e');
        textGrad.addColorStop(1, '#ffd700');

        ctx.font = 'bold 72px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.strokeText('MULLET PRO', 350, 150);
        ctx.fillStyle = textGrad;
        ctx.fillText('MULLET PRO', 350, 150);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = '22px Arial';
        ctx.fillText('DELIVER THE DOCUMENTS', 350, 200);

        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('STOP THE CATASTROPHE!', 350, 230);

        drawMulletPro(350, 340, 'forward');

        if(Math.floor(frame / 30) % 2 === 0) {
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('PRESS ANY BUTTON TO START', 350, 430);
        }

        ctx.restore();
        return;
    }

    if(state === 'levelCard') {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        const lvlGrad = ctx.createLinearGradient(200, 150, 500, 250);
        lvlGrad.addColorStop(0, '#ff6b35');
        lvlGrad.addColorStop(1, '#ffd700');

        ctx.font = 'bold 80px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.strokeText('LEVEL ' + level, 350, 200);
        ctx.fillStyle = lvlGrad;
        ctx.fillText('LEVEL ' + level, 350, 200);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 32px Arial';
        const msgs = ['', 'TRAINING DAY', 'PRESSURE RISING!', 'MAXIMUM CHAOS!', 'GHOST GUN UNLOCKED!'];
        ctx.fillText(msgs[level], 350, 270);

        if(cardTimer > 60) {
            if(Math.floor(frame / 30) % 2 === 0) {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 32px Arial';
                ctx.fillText('GET READY!', 350, 370);
            }
        }

        ctx.restore();
        return;
    }

    if(state === 'promotion') {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        const promoGrad = ctx.createLinearGradient(200, 100, 500, 200);
        promoGrad.addColorStop(0, '#ffd700');
        promoGrad.addColorStop(1, '#ff6b35');

        ctx.font = 'bold 56px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.strokeText('CONGRATS!', 350, 150);
        ctx.fillStyle = promoGrad;
        ctx.fillText('CONGRATS!', 350, 150);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = 'bold 36px Arial';
        ctx.fillText('YOU ARE THE NEW', 350, 220);

        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 48px Arial';
        ctx.fillText('PIPE BOSS', 350, 280);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = '32px Arial';
        ctx.fillText('FINAL SCORE: ' + score, 350, 340);

        ctx.font = '24px Arial';
        ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
        ctx.fillText('▶ Return to Mullet.pro', 350, 400);
        ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
        ctx.fillText('▶ Keep documenting!', 350, 450);

        ctx.restore();
        return;
    }

    if(state === 'over' || state === 'win') {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.fillStyle = state === 'win' ? '#27ae60' : '#e74c3c';
        ctx.font = 'bold 56px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(state === 'win' ? "YOU'RE HIRED!" : "YOU'RE FIRED!", 350, 180);

        ctx.fillStyle = '#f5f2ec';
        ctx.font = '32px Arial';
        ctx.fillText('FINAL SCORE: ' + score, 350, 240);

        ctx.font = '24px Arial';
        ctx.fillStyle = menuChoice === 0 ? '#ffd700' : '#999';
        ctx.fillText('▶ Return to Mullet.pro', 350, 320);
        ctx.fillStyle = menuChoice === 1 ? '#ffd700' : '#999';
        ctx.fillText('▶ Keep documenting!', 350, 370);

        ctx.restore();
        return;
    }

    // Playing state - draw game room
    ctx.fillStyle = '#e8e6dc';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Floor
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 400, GAME_WIDTH, 100);

    // Floor tiles
    for(let i = 0; i < 20; i++) {
        for(let j = 0; j < 3; j++) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(i * 35, 400 + j * 33, 35, 33);
        }
    }

    // Ceiling lights
    ctx.fillStyle = '#f5f5dc';
    ctx.globalAlpha = 0.3;
    ctx.fillRect(100, 20, 80, 10);
    ctx.fillRect(300, 20, 80, 10);
    ctx.fillRect(500, 20, 80, 10);
    ctx.globalAlpha = 1;

    // PIPETECH sign
    ctx.fillStyle = '#7a7a7a';
    ctx.fillRect(20, 30, 220, 110);
    ctx.fillStyle = '#6a6a6a';
    ctx.fillRect(25, 35, 210, 100);
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(28, 38, 204, 94);

    // Sign bolts
    for(let bx = 0; bx < 2; bx++) {
        for(let by = 0; by < 2; by++) {
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.arc(35 + bx * 190, 45 + by * 80, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8a8a8a';
            ctx.beginPath();
            ctx.arc(34 + bx * 190, 44 + by * 80, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.fillStyle = '#f5f2ec';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PIPETECH', 130, 75);

    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(50, 82, 160, 1);

    ctx.fillStyle = '#d0d0d0';
    ctx.font = '10px Arial';
    ctx.fillText('GLOBAL LEADER IN PIPE DREAMS', 130, 97);

    // Company color bars
    for(let i = 0; i < 4; i++) {
        ctx.fillStyle = COLORS[i].hex;
        ctx.fillRect(50, 105 + i * 5, 160, 3);
    }

    // Realistic floor
    ctx.fillStyle = '#c4bfad';
    ctx.fillRect(0, 410, GAME_WIDTH, 90);

    // Computer
    drawComputer(computer.x, computer.y);

    // 3D Printer (level 4 only)
    if(level === 4) {
        draw3DPrinter(printer3d.x, printer3d.y);
    }

    // Pipes and NPCs
    for(let npc of npcs) {
        const pipeY = 240;

        // Vertical pipe
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.beginPath();
        ctx.moveTo(npc.x, 60);
        ctx.lineTo(npc.x, pipeY);
        ctx.stroke();

        // Pipe highlight
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(npc.x - 4, 60);
        ctx.lineTo(npc.x - 4, pipeY);
        ctx.stroke();

        // Horizontal pipe
        ctx.strokeStyle = npc.color.hex;
        ctx.lineWidth = 14;
        ctx.beginPath();
        ctx.moveTo(npc.x, pipeY);
        ctx.quadraticCurveTo(npc.x, pipeY + 25, npc.x + 25, pipeY + 25);
        ctx.lineTo(GAME_WIDTH, pipeY + 25);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(npc.x + 21, pipeY + 25);
        ctx.lineTo(GAME_WIDTH, pipeY + 25);
        ctx.stroke();

        // Crack effect
        const crack = cracks.find(c => c.npc === npc);
        if(crack && !resetting) {
            const pct = (Date.now() - crack.time) / crack.max;
            ctx.fillStyle = npc.color.hex;
            ctx.globalAlpha = 0.4 + pct * 0.6;
            const sz = 18 + pct * 28;
            for(let i = 0; i < 3; i++) {
                ctx.fillRect(npc.x - sz / 2 + (i - 1) * 5, pipeY - 40 + i * 8, sz, 8);
            }
            ctx.globalAlpha = 1;
        }

        drawNPC(npc);
    }

    // Explosions
    for(let exp of explosions) {
        ctx.fillStyle = `rgba(255,100,0,${exp.alpha})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255,200,0,${exp.alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();

        for(let p of exp.particles) {
            ctx.fillStyle = `rgba(100,100,100,${p.life})`;
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        }
    }

    // Muzzle flashes
    for(let mf of muzzleFlashes) {
        const flashX = mf.facing === 'left' ? mf.x - 30 : mf.x + 30;
        ctx.fillStyle = `rgba(255,200,0,${mf.life / 10})`;
        ctx.beginPath();
        ctx.arc(flashX, mf.y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255,255,100,${mf.life / 10})`;
        ctx.beginPath();
        ctx.arc(flashX, mf.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }

    // Bullets
    for(let bullet of bullets) {
        ctx.fillStyle = '#ffff00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // Boss
    if(boss.active) {
        drawBoss(boss.x, boss.y, boss.facing);
    }

    // Player
    drawMulletPro(player.x, player.y, player.facing);

    // Held document
    if(player.holding) {
        const col = COLORS.find(c => c.name === player.holding);
        ctx.fillStyle = col.hex;
        ctx.fillRect(player.x - 20, player.y - 65, 40, 28);
        ctx.fillStyle = '#2b2b2b';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(col.name, player.x, player.y - 45);
    }

    // Ghost gun
    if(ghostGun.hasGun && ghostGun.ammo > 0) {
        drawGhostGun(player.x, player.y, player.facing);
        drawAmmoCounter(player.x, player.y, ghostGun.ammo);
    }

    // UI overlay for computer
    if(ui.show) {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 340, GAME_WIDTH, 160);

        if(!ui.confirming) {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('SELECT COLOR:', 30, 375);

            for(let i = 0; i < 4; i++) {
                const selected = i === ui.selectedColor;
                ctx.strokeStyle = selected ? '#f5f2ec' : '#666';
                ctx.lineWidth = selected ? 4 : 2;
                ctx.fillStyle = COLORS[i].hex;
                ctx.fillRect(30 + i * 160, 390, 140, 70);
                ctx.strokeRect(30 + i * 160, 390, 140, 70);
                ctx.fillStyle = '#2b2b2b';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(COLORS[i].name, 100 + i * 160, 430);
            }
        } else {
            const col = COLORS[ui.selectedColor];
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PRINT ' + col.name + ' DOC?', 350, 385);
            ctx.fillStyle = col.hex;
            ctx.fillRect(270, 410, 160, 60);
            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('CONFIRM', 350, 445);
        }
    }

    // UI overlay for 3D printer
    if(ui.gunUI) {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 340, GAME_WIDTH, 160);

        if(!ui.confirming) {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('SELECT ITEM:', 30, 375);

            const selected = ui.gunChoice === 0;
            ctx.strokeStyle = selected ? '#f5f2ec' : '#666';
            ctx.lineWidth = selected ? 4 : 2;
            ctx.fillStyle = '#888';
            ctx.fillRect(30, 390, 140, 70);
            ctx.strokeRect(30, 390, 140, 70);

            // Draw ghost gun icon
            const gunCenterX = 100;
            const gunCenterY = 420;

            ctx.save();
            ctx.translate(gunCenterX, gunCenterY);
            ctx.rotate(-0.3);

            ctx.fillStyle = '#999';
            ctx.fillRect(-10, -3, 18, 6);
            ctx.fillRect(8, -2, 6, 4);
            ctx.fillStyle = '#777';
            ctx.fillRect(-10, -5, 5, 2);
            ctx.fillStyle = '#666';
            ctx.fillRect(2, 2, 4, 6);

            ctx.restore();

            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GHOST GUN', 100, 455);
        } else {
            ctx.fillStyle = '#f5f2ec';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PRINT GHOST GUN?', 350, 385);
            ctx.fillStyle = '#888';
            ctx.fillRect(270, 410, 160, 60);
            ctx.fillStyle = '#2b2b2b';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('CONFIRM', 350, 445);
        }
    }

    // Fade effect
    if(fadeAlpha > 0) {
        ctx.fillStyle = `rgba(232,230,220,${fadeAlpha})`;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }

    ctx.restore();
}

// ============================================================================
// GAME UPDATE LOGIC
// ============================================================================

function update() {
    if(state === 'menu') {
        if(keys[' '] || keys['action'] || keys['ArrowUp'] || keys['ArrowDown'] ||
           keys['ArrowLeft'] || keys['ArrowRight'] || keys['up'] || keys['down'] ||
           keys['left'] || keys['right']) {
            startGame();
            keys = {};
        }
        return;
    }

    if(state === 'levelCard') {
        cardTimer++;
        if(cardTimer > 120) {
            state = 'playing';
            spawnCracks();
        }
        return;
    }

    if(state === 'promotion' || state === 'over' || state === 'win') {
        if((keys['ArrowUp'] || keys['up']) && !keys.upProcessed) {
            menuChoice = 0;
            keys.upProcessed = true;
        }
        if((keys['ArrowDown'] || keys['down']) && !keys.downProcessed) {
            menuChoice = 1;
            keys.downProcessed = true;
        }
        if(!keys['ArrowUp'] && !keys['up']) keys.upProcessed = false;
        if(!keys['ArrowDown'] && !keys['down']) keys.downProcessed = false;

        if(keys[' '] || keys['action']) {
            keys[' '] = false;
            keys['action'] = false;
            if(menuChoice === 0) {
                window.location.href = '/';
            } else {
                state = 'menu';
            }
        }
        return;
    }

    if(state !== 'playing') return;

    // Fade transition
    if(resetting) {
        if(fadeOut) {
            fadeAlpha += 0.08;
            if(fadeAlpha >= 1) {
                fadeOut = false;
                fadeIn = true;
                initLevel(level);
            }
        }
        if(fadeIn) {
            fadeAlpha -= 0.08;
            if(fadeAlpha <= 0) {
                fadeAlpha = 0;
                fadeIn = false;
                resetting = false;
            }
        }
        return;
    }

    // Player movement
    if(!ui.show && !ui.gunUI) {
        const prevX = player.x;
        if(keys['ArrowLeft'] || keys['left']) {
            player.x = Math.max(60, player.x - 5);
            if(player.x !== prevX) {
                player.facing = 'left';
                player.lastMove = Date.now();
            }
        }
        if(keys['ArrowRight'] || keys['right']) {
            player.x = Math.min(640, player.x + 5);
            if(player.x !== prevX) {
                player.facing = 'right';
                player.lastMove = Date.now();
            }
        }
        if(!keys['ArrowLeft'] && !keys['left'] && !keys['ArrowRight'] && !keys['right']) {
            if(Date.now() - player.lastMove > 200) {
                player.facing = 'forward';
            }
        }
    }

    // Boss movement
    if(boss.active && boss.walking) {
        if(boss.angry) {
            boss.x += 5;
            boss.facing = 'right';
            if(boss.x > 750) {
                boss.active = false;
                boss.needsColor = null;
                boss.angry = false;
            }
        } else if(boss.needsColor === null) {
            boss.x += 3;
            boss.facing = 'right';
            if(boss.x > 750) {
                boss.active = false;
            }
        } else {
            boss.x -= 2;
            boss.facing = 'left';
            if(boss.x <= 200) {
                boss.walking = false;
                boss.spawnTime = Date.now();
            }
        }
    }

    // Boss timeout
    if(boss.active && !boss.walking && !boss.angry && boss.needsColor) {
        if(Date.now() - boss.spawnTime > 6000) {
            boss.angry = true;
            boss.walking = true;
            boss.needsColor = null;
            lives--;
            score = Math.floor(score / 2);
            updateLives();
            if(lives <= 0) {
                state = 'over';
                menuChoice = 0;
            }
        }
    }

    // 3D printing
    if(ghostGun.printing) {
        ghostGun.printProgress += 0.02;
        if(ghostGun.printProgress >= 1) {
            ghostGun.printing = false;
            ghostGun.printProgress = 0;
            ghostGun.hasGun = true;
            ghostGun.ammo = 1;
        }
    }

    // Explosions
    for(let i = explosions.length - 1; i >= 0; i--) {
        let exp = explosions[i];
        exp.radius += 3;
        exp.alpha -= 0.03;
        for(let p of exp.particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.3;
            p.life -= 0.02;
        }
        if(exp.alpha <= 0) {
            explosions.splice(i, 1);
        }
    }

    // Muzzle flashes
    for(let i = muzzleFlashes.length - 1; i >= 0; i--) {
        muzzleFlashes[i].life--;
        if(muzzleFlashes[i].life <= 0) {
            muzzleFlashes.splice(i, 1);
        }
    }

    // Bullets
    for(let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].x += bullets[i].vx;
        if(bullets[i].x > 750 || bullets[i].x < 0) {
            bullets.splice(i, 1);
            continue;
        }
        if(boss.active && Math.abs(bullets[i].x - boss.x) < 50 && Math.abs(bullets[i].y - boss.y) < 50) {
            boss.active = false;
            boss.needsColor = null;
            boss.walking = false;
            boss.angry = false;
            boss.bossKills++;
            score += 500 * level;
            bullets.splice(i, 1);
            createExplosion(boss.x, boss.y);
            lives = Math.min(3, lives + 1);
            updateLives();
            checkPromotion();
        }
    }

    // Action button logic
    if(keys[' '] || keys['action']) {
        keys[' '] = false;
        keys['action'] = false;

        const atComputer = Math.abs(player.x - computer.x) < 60;
        const at3DPrinter = level === 4 && Math.abs(player.x - printer3d.x) < 60;

        // Fire ghost gun
        if(ghostGun.hasGun && ghostGun.ammo > 0 && !ui.show && !ui.gunUI) {
            const direction = player.facing === 'left' ? -1 : player.facing === 'right' ? 1 : 0;
            if(direction !== 0) {
                bullets.push({x: player.x, y: player.y - 25, vx: direction * 12});
                createMuzzleFlash(player.x, player.y - 25, player.facing);
                ghostGun.ammo = 0;
                ghostGun.hasGun = false;
            }
            return;
        }

        // Open 3D printer UI
        if(at3DPrinter && !player.holding && !ui.show && !ui.gunUI && !ghostGun.hasGun && !ghostGun.printing) {
            ui.gunUI = true;
            return;
        }

        // Open computer UI
        if(atComputer && !player.holding && !ui.show && !ui.gunUI && !ghostGun.hasGun) {
            ui.show = true;
            return;
        }

        // Computer UI navigation
        if(ui.show && !ui.confirming) {
            ui.confirming = true;
            return;
        }

        if(ui.show && ui.confirming) {
            player.holding = COLORS[ui.selectedColor].name;
            ui.show = false;
            ui.confirming = false;
            ui.selectedColor = 0;
            return;
        }

        // 3D printer UI navigation
        if(ui.gunUI && !ui.confirming) {
            ui.confirming = true;
            return;
        }

        if(ui.gunUI && ui.confirming) {
            ui.gunUI = false;
            ui.confirming = false;
            ghostGun.printing = true;
            ghostGun.printProgress = 0;
            return;
        }

        // Deliver document
        if(player.holding) {
            // To boss
            if(boss.active && !boss.angry && Math.abs(player.x - boss.x) < 50 && boss.needsColor === player.holding) {
                score += 300 * level;
                boss.needsColor = null;
                boss.walking = true;
                boss.angry = false;
                player.holding = null;
                return;
            }

            // To NPC
            for(let npc of npcs) {
                if(Math.abs(player.x - npc.x) < 45 && npc.needsDoc && npc.color.name === player.holding) {
                    npc.needsDoc = false;
                    npc.state = 'fixing';
                    npc.fixAnim = 0;
                    player.holding = null;
                    score += 150 * level;

                    const fixInterval = setInterval(() => {
                        npc.fixAnim += 0.3;
                    }, 50);

                    setTimeout(() => {
                        clearInterval(fixInterval);
                        cracks = cracks.filter(c => c.npc !== npc);
                        npc.state = 'happy';
                    }, 2000);
                    break;
                }
            }
        }
    }

    // UI color selection
    if(ui.show && !ui.confirming) {
        if((keys['ArrowLeft'] || keys['left']) && !keys.leftProcessed) {
            ui.selectedColor = Math.max(0, ui.selectedColor - 1);
            keys.leftProcessed = true;
        }
        if((keys['ArrowRight'] || keys['right']) && !keys.rightProcessed) {
            ui.selectedColor = Math.min(3, ui.selectedColor + 1);
            keys.rightProcessed = true;
        }
        if(!keys['ArrowLeft'] && !keys['left']) keys.leftProcessed = false;
        if(!keys['ArrowRight'] && !keys['right']) keys.rightProcessed = false;
    }

    // Check for pipe breaks
    for(let i = cracks.length - 1; i >= 0; i--) {
        let crack = cracks[i];
        if(Date.now() - crack.time > crack.max) {
            createExplosion(crack.npc.x, 240);
            cracks.splice(i, 1);
            lives--;
            updateLives();
            resetting = true;
            fadeOut = true;
            fadeAlpha = 0;
            if(lives <= 0) {
                state = 'over';
                menuChoice = 0;
            }
            return;
        }
    }
}

function winGame() {
    state = 'win';
    menuChoice = 0;
}

function nextLevel() {
    if(level < 4) {
        level++;
        timer = 60;
        state = 'levelCard';
        cardTimer = 0;
        initLevel(level);
    } else {
        winGame();
    }
}

// ============================================================================
// GAME LOOP
// ============================================================================

let lastTime = Date.now();
let counter = 0;

function gameLoop() {
    if(state !== 'playing' && state !== 'levelCard' && state !== 'over' &&
       state !== 'win' && state !== 'menu' && state !== 'promotion') return;

    frame++;
    const now = Date.now();
    counter += now - lastTime;
    lastTime = now;

    if(state === 'playing' && !resetting && counter >= 1000) {
        timer--;
        counter = 0;
        document.getElementById('timer').textContent = timer;
        if(timer <= 0) nextLevel();
    }

    update();
    drawScene();
    document.getElementById('level').textContent = level;
    document.getElementById('score').textContent = score;
    requestAnimationFrame(gameLoop);
}

drawScene();
gameLoop();

// ============================================================================
// INPUT HANDLING
// ============================================================================

document.addEventListener('keydown', e => {
    keys[e.key] = true;
});

document.addEventListener('keyup', e => {
    keys[e.key] = false;
});

document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('touchstart', e => {
        e.preventDefault();
        keys[btn.dataset.dir] = true;
        hapticFeedback();
    }, {passive: false});

    btn.addEventListener('touchend', e => {
        e.preventDefault();
        keys[btn.dataset.dir] = false;
    }, {passive: false});

    btn.addEventListener('mousedown', e => {
        e.preventDefault();
        keys[btn.dataset.dir] = true;
    });

    btn.addEventListener('mouseup', e => {
        e.preventDefault();
        keys[btn.dataset.dir] = false;
    });
});

document.getElementById('action-btn').addEventListener('touchstart', e => {
    e.preventDefault();
    keys['action'] = true;
    hapticFeedback();
}, {passive: false});

document.getElementById('action-btn').addEventListener('touchend', e => {
    e.preventDefault();
    keys['action'] = false;
}, {passive: false});

document.getElementById('action-btn').addEventListener('mousedown', e => {
    e.preventDefault();
    keys['action'] = true;
});

document.getElementById('action-btn').addEventListener('mouseup', e => {
    e.preventDefault();
    keys['action'] = false;
});

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PipeTech - Industrial Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #hud {
            position: fixed;
            top: 15px;
            left: 15px;
            right: 15px;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(20, 20, 30, 0.6);
            border-radius: 25px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .hud-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 16px;
        }
        .heart { color: #ff4757; font-size: 18px; }
        .coin { color: #ffa502; font-size: 18px; }
        #touchHint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(20, 20, 30, 0.7);
            color: #fff;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div class="hud-item"><span class="heart">♥</span><span id="lives">3</span></div>
            <div class="hud-item">LV <span id="levelDisplay">1</span></div>
            <div class="hud-item"><span class="coin">●</span><span id="money">0</span></div>
        </div>
        <div id="touchHint">Swipe to move • Tap objects to interact</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Full screen canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let state = 'title';
        let frame = 0;
        let level = 1;
        let lives = 3;
        let money = 0;

        // Camera
        const camera = {
            x: 0,
            y: 0,
            targetX: 0,
            smoothing: 0.1
        };

        // Player with realistic 3D properties
        const player = {
            x: 200,
            y: 0,
            width: 50,
            height: 85,
            vx: 0,
            vy: 0,
            speed: 6,
            jumpPower: 16,
            grounded: false,
            facing: 1, // 1 = right, -1 = left
            animFrame: 0,
            jumping: false
        };

        // Touch/Swipe controls
        let touchStart = { x: 0, y: 0, time: 0 };
        let touchEnd = { x: 0, y: 0, time: 0 };
        let isSwipeMoving = false;
        let swipeDirection = 0;

        // Interactive objects
        let interactiveObjects = [];

        // Platforms
        let platforms = [];

        // Coins
        let coins = [];

        // Enemies
        let enemies = [];

        // Background elements for parallax
        let bgLayers = [];

        // Particles
        let particles = [];

        // Initialize Level 1
        function initLevel1() {
            const groundY = canvas.height - 120;

            platforms = [
                { x: 0, y: groundY, width: 400, height: 120, type: 'ground' },
                { x: 500, y: groundY, width: 300, height: 120, type: 'ground' },
                { x: 900, y: groundY, width: 400, height: 120, type: 'ground' },
                { x: 1400, y: groundY, width: 500, height: 120, type: 'ground' },
                { x: 2000, y: groundY, width: 600, height: 120, type: 'ground' },

                { x: 350, y: groundY - 180, width: 200, height: 25, type: 'metal' },
                { x: 650, y: groundY - 260, width: 180, height: 25, type: 'metal' },
                { x: 950, y: groundY - 200, width: 220, height: 25, type: 'metal' },
                { x: 1300, y: groundY - 300, width: 200, height: 25, type: 'metal' },
                { x: 1650, y: groundY - 220, width: 180, height: 25, type: 'metal' },
                { x: 1950, y: groundY - 350, width: 250, height: 25, type: 'metal' }
            ];

            coins = [
                { x: 450, y: groundY - 230, collected: false, wobble: 0 },
                { x: 720, y: groundY - 320, collected: false, wobble: 0.5 },
                { x: 1050, y: groundY - 260, collected: false, wobble: 1 },
                { x: 1400, y: groundY - 360, collected: false, wobble: 1.5 },
                { x: 1750, y: groundY - 280, collected: false, wobble: 2 },
                { x: 2080, y: groundY - 410, collected: false, wobble: 2.5 }
            ];

            enemies = [
                { x: 600, y: groundY - 100, width: 45, height: 75, vx: 1.5, dir: 1, type: 'worker', color: '#c0392b' },
                { x: 1100, y: groundY - 100, width: 45, height: 75, vx: 1.8, dir: -1, type: 'worker', color: '#27ae60' },
                { x: 1700, y: groundY - 100, width: 45, height: 75, vx: 1.3, dir: 1, type: 'worker', color: '#2980b9' }
            ];

            interactiveObjects = [
                { x: 700, y: groundY - 140, width: 40, height: 60, type: 'lever', active: false, triggered: false },
                { x: 1200, y: groundY - 340, width: 50, height: 70, type: 'terminal', active: false, triggered: false },
                { x: 2100, y: groundY - 160, width: 60, height: 80, type: 'door', active: false, triggered: false }
            ];

            // Background layers for parallax depth
            bgLayers = [
                { x: 0, y: 0, parallax: 0.2, elements: createDistantPipes() },
                { x: 0, y: 0, parallax: 0.4, elements: createMiddlePipes() },
                { x: 0, y: 0, parallax: 0.7, elements: createNearPipes() }
            ];

            player.x = 200;
            player.y = groundY - 150;
            player.vx = 0;
            player.vy = 0;
            camera.x = 0;
            camera.targetX = 0;
        }

        // Create background pipe elements
        function createDistantPipes() {
            const pipes = [];
            for (let i = 0; i < 8; i++) {
                pipes.push({
                    x: i * 400 + Math.random() * 100,
                    y: 100 + Math.random() * 200,
                    width: 300 + Math.random() * 200,
                    height: 20 + Math.random() * 15,
                    color: ['#8e44ad', '#2c3e50', '#34495e'][Math.floor(Math.random() * 3)],
                    angle: (Math.random() - 0.5) * 10
                });
            }
            return pipes;
        }

        function createMiddlePipes() {
            const pipes = [];
            for (let i = 0; i < 6; i++) {
                pipes.push({
                    x: i * 500 + Math.random() * 150,
                    y: 80 + Math.random() * 150,
                    width: 250 + Math.random() * 150,
                    height: 25 + Math.random() * 10,
                    color: ['#c0392b', '#27ae60', '#2980b9'][Math.floor(Math.random() * 3)],
                    angle: (Math.random() - 0.5) * 8
                });
            }
            return pipes;
        }

        function createNearPipes() {
            const pipes = [];
            for (let i = 0; i < 5; i++) {
                pipes.push({
                    x: i * 600 + Math.random() * 200,
                    y: 50 + Math.random() * 100,
                    width: 200 + Math.random() * 100,
                    height: 30 + Math.random() * 10,
                    color: ['#e74c3c', '#f39c12', '#3498db'][Math.floor(Math.random() * 3)],
                    angle: (Math.random() - 0.5) * 6
                });
            }
            return pipes;
        }

        // Draw realistic 3D environment
        function drawBackground() {
            // Atmospheric gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Atmospheric particles (dust, steam)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            for (let i = 0; i < 50; i++) {
                const x = (Math.sin(frame * 0.001 + i) * 200 + i * 30) % canvas.width;
                const y = (Math.cos(frame * 0.002 + i) * 100 + i * 20) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw parallax background layers
            bgLayers.forEach(layer => {
                const offsetX = camera.x * layer.parallax;

                layer.elements.forEach(pipe => {
                    ctx.save();
                    const screenX = pipe.x - offsetX;
                    const screenY = pipe.y;

                    ctx.translate(screenX + pipe.width / 2, screenY + pipe.height / 2);
                    ctx.rotate((pipe.angle * Math.PI) / 180);

                    // 3D pipe with depth and lighting
                    const pipeGradient = ctx.createLinearGradient(0, -pipe.height / 2, 0, pipe.height / 2);
                    pipeGradient.addColorStop(0, lightenColor(pipe.color, 30));
                    pipeGradient.addColorStop(0.3, pipe.color);
                    pipeGradient.addColorStop(0.7, darkenColor(pipe.color, 20));
                    pipeGradient.addColorStop(1, darkenColor(pipe.color, 40));

                    ctx.fillStyle = pipeGradient;
                    ctx.fillRect(-pipe.width / 2, -pipe.height / 2, pipe.width, pipe.height);

                    // Specular highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.fillRect(-pipe.width / 2, -pipe.height / 2 + 3, pipe.width, pipe.height * 0.25);

                    // Pipe segments
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < pipe.width; i += 50) {
                        ctx.beginPath();
                        ctx.moveTo(-pipe.width / 2 + i, -pipe.height / 2);
                        ctx.lineTo(-pipe.width / 2 + i, pipe.height / 2);
                        ctx.stroke();
                    }

                    ctx.restore();
                });
            });

            // Floor lighting effects
            const lightGradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height - 100, 0,
                canvas.width / 2, canvas.height - 100, canvas.width / 2
            );
            lightGradient.addColorStop(0, 'rgba(46, 134, 193, 0.1)');
            lightGradient.addColorStop(1, 'rgba(46, 134, 193, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(0, canvas.height - 200, canvas.width, 200);
        }

        // Draw title screen
        function drawTitleScreen() {
            drawBackground();

            // Main title with 3D effect
            const titleY = canvas.height * 0.3;

            // Shadow layers for depth
            for (let i = 8; i > 0; i--) {
                ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * (9 - i)})`;
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PIPETECH', canvas.width / 2 + i, titleY + i);
            }

            // Main title
            const titleGradient = ctx.createLinearGradient(0, titleY - 50, 0, titleY + 50);
            titleGradient.addColorStop(0, '#3498db');
            titleGradient.addColorStop(0.5, '#2980b9');
            titleGradient.addColorStop(1, '#1abc9c');
            ctx.fillStyle = titleGradient;
            ctx.font = 'bold 80px Arial';
            ctx.fillText('PIPETECH', canvas.width / 2, titleY);

            // Subtitle
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '24px Arial';
            ctx.fillText('Industrial Platform Adventure', canvas.width / 2, titleY + 60);

            // Animated prompt
            const alpha = Math.sin(frame * 0.08) * 0.4 + 0.6;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('TAP TO START', canvas.width / 2, canvas.height * 0.7);
            ctx.globalAlpha = 1;

            // Instructions
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '16px Arial';
            ctx.fillText('Swipe to move • Tap objects to interact', canvas.width / 2, canvas.height * 0.8);
        }

        // Draw platforms with realistic 3D rendering
        function drawPlatforms() {
            platforms.forEach(platform => {
                const screenX = platform.x - camera.x;

                if (platform.type === 'ground') {
                    // Concrete ground with realistic texture
                    const groundGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    groundGradient.addColorStop(0, '#34495e');
                    groundGradient.addColorStop(0.2, '#2c3e50');
                    groundGradient.addColorStop(1, '#1a252f');

                    ctx.fillStyle = groundGradient;
                    ctx.fillRect(screenX, platform.y, platform.width, platform.height);

                    // Top edge highlight
                    ctx.fillStyle = '#4a6278';
                    ctx.fillRect(screenX, platform.y, platform.width, 4);

                    // Concrete texture details
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    for (let i = 0; i < platform.width; i += 20) {
                        for (let j = 0; j < platform.height; j += 20) {
                            if (Math.random() > 0.7) {
                                ctx.fillRect(screenX + i + Math.random() * 10, platform.y + j + Math.random() * 10,
                                           2 + Math.random() * 3, 2 + Math.random() * 3);
                            }
                        }
                    }

                    // Panel lines
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < platform.width; i += 100) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + i, platform.y);
                        ctx.lineTo(screenX + i, platform.y + platform.height);
                        ctx.stroke();
                    }
                } else if (platform.type === 'metal') {
                    // Metal platform with 3D depth
                    const metalGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    metalGradient.addColorStop(0, '#7f8c8d');
                    metalGradient.addColorStop(0.3, '#95a5a6');
                    metalGradient.addColorStop(0.7, '#7f8c8d');
                    metalGradient.addColorStop(1, '#5d6d6e');

                    ctx.fillStyle = metalGradient;
                    ctx.fillRect(screenX, platform.y, platform.width, platform.height);

                    // Specular highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(screenX, platform.y + 2, platform.width, platform.height * 0.3);

                    // Rivets
                    ctx.fillStyle = '#34495e';
                    for (let i = 10; i < platform.width - 10; i += 30) {
                        ctx.beginPath();
                        ctx.arc(screenX + i, platform.y + platform.height / 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Shadow underneath
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(screenX, platform.y + platform.height, platform.width, 8);
                }
            });
        }

        // Draw realistic 3D player
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y;

            ctx.save();

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX + player.width / 2, screenY + player.height + 5,
                       player.width * 0.4, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Flip sprite based on direction
            if (player.facing === -1) {
                ctx.translate(screenX + player.width / 2, screenY + player.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(screenX + player.width / 2), -(screenY + player.height / 2));
            }

            // Legs (dark pants with 3D shading)
            const legGradient = ctx.createLinearGradient(0, screenY + player.height - 30, 0, screenY + player.height);
            legGradient.addColorStop(0, '#2c3e50');
            legGradient.addColorStop(1, '#1a252f');

            ctx.fillStyle = legGradient;
            ctx.fillRect(screenX + 12, screenY + player.height - 30, 10, 30);
            ctx.fillRect(screenX + 28, screenY + player.height - 30, 10, 30);

            // Body (blue jacket with realistic shading)
            const bodyGradient = ctx.createLinearGradient(0, screenY + 25, 0, screenY + 60);
            bodyGradient.addColorStop(0, '#5dade2');
            bodyGradient.addColorStop(0.3, '#3498db');
            bodyGradient.addColorStop(0.7, '#2e86c1');
            bodyGradient.addColorStop(1, '#1a5276');

            ctx.fillStyle = bodyGradient;
            ctx.fillRect(screenX + 8, screenY + 25, player.width - 16, 35);

            // Jacket details
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(screenX + 10, screenY + 28, (player.width - 16) * 0.4, 30);

            // Arms with 3D shading
            const armGradient = ctx.createLinearGradient(screenX, screenY + 30, screenX + 10, screenY + 30);
            armGradient.addColorStop(0, '#2e86c1');
            armGradient.addColorStop(1, '#1a5276');

            ctx.fillStyle = armGradient;
            ctx.fillRect(screenX + 4, screenY + 30, 8, 25);
            ctx.fillRect(screenX + player.width - 12, screenY + 30, 8, 25);

            // Hands
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(screenX + 4, screenY + 52, 8, 10);
            ctx.fillRect(screenX + player.width - 12, screenY + 52, 8, 10);

            // Head with realistic skin tone and shading
            const headGradient = ctx.createRadialGradient(
                screenX + player.width / 2 - 3, screenY + 13, 2,
                screenX + player.width / 2, screenY + 15, 15
            );
            headGradient.addColorStop(0, '#e8b896');
            headGradient.addColorStop(0.7, '#d4a574');
            headGradient.addColorStop(1, '#b8865f');

            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(screenX + player.width / 2, screenY + 15, 14, 0, Math.PI * 2);
            ctx.fill();

            // Hair with depth
            ctx.fillStyle = '#2c1810';
            ctx.fillRect(screenX + player.width / 2 - 12, screenY + 2, 24, 12);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(screenX + player.width / 2 - 12, screenY + 8, 24, 6);

            // Face details
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.fillRect(screenX + player.width / 2 - 6, screenY + 14, 5, 3);
            ctx.fillRect(screenX + player.width / 2 + 2, screenY + 14, 5, 3);

            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(screenX + player.width / 2 - 4, screenY + 14, 2, 3);
            ctx.fillRect(screenX + player.width / 2 + 4, screenY + 14, 2, 3);

            // Nose shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(screenX + player.width / 2, screenY + 18, 2, 4);

            ctx.restore();
        }

        // Draw enemies with realistic 3D appearance
        function drawEnemies() {
            enemies.forEach(enemy => {
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y;

                ctx.save();

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(screenX + enemy.width / 2, screenY + enemy.height + 5,
                           enemy.width * 0.4, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Flip based on direction
                if (enemy.dir === -1) {
                    ctx.translate(screenX + enemy.width / 2, screenY + enemy.height / 2);
                    ctx.scale(-1, 1);
                    ctx.translate(-(screenX + enemy.width / 2), -(screenY + enemy.height / 2));
                }

                // Body (colored jumpsuit)
                const bodyGradient = ctx.createLinearGradient(0, screenY + 20, 0, screenY + 60);
                bodyGradient.addColorStop(0, lightenColor(enemy.color, 20));
                bodyGradient.addColorStop(0.5, enemy.color);
                bodyGradient.addColorStop(1, darkenColor(enemy.color, 30));

                ctx.fillStyle = bodyGradient;
                ctx.fillRect(screenX + 8, screenY + 20, enemy.width - 16, 40);

                // Legs
                ctx.fillRect(screenX + 12, screenY + 60, 9, 20);
                ctx.fillRect(screenX + 24, screenY + 60, 9, 20);

                // Arms
                ctx.fillRect(screenX + 4, screenY + 25, 7, 22);
                ctx.fillRect(screenX + enemy.width - 11, screenY + 25, 7, 22);

                // Head
                const headGradient = ctx.createRadialGradient(
                    screenX + enemy.width / 2 - 2, screenY + 10, 2,
                    screenX + enemy.width / 2, screenY + 12, 12
                );
                headGradient.addColorStop(0, '#e8b896');
                headGradient.addColorStop(0.7, '#d4a574');
                headGradient.addColorStop(1, '#b8865f');

                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(screenX + enemy.width / 2, screenY + 12, 11, 0, Math.PI * 2);
                ctx.fill();

                // Hard hat
                const hatGradient = ctx.createLinearGradient(0, screenY, 0, screenY + 10);
                hatGradient.addColorStop(0, lightenColor(enemy.color, 40));
                hatGradient.addColorStop(1, darkenColor(enemy.color, 10));

                ctx.fillStyle = hatGradient;
                ctx.beginPath();
                ctx.arc(screenX + enemy.width / 2, screenY + 6, 12, Math.PI, 2 * Math.PI);
                ctx.fill();
                ctx.fillRect(screenX + enemy.width / 2 - 15, screenY + 6, 30, 4);

                // Hat highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX + enemy.width / 2, screenY + 6, 12, Math.PI + 0.5, 2 * Math.PI - 0.5);
                ctx.fill();

                ctx.restore();
            });
        }

        // Draw coins with 3D effect
        function drawCoins() {
            coins.forEach(coin => {
                if (!coin.collected) {
                    const screenX = coin.x - camera.x;
                    const wobble = Math.sin(frame * 0.08 + coin.wobble) * 5;
                    const rotation = Math.sin(frame * 0.05 + coin.wobble) * 0.3;

                    ctx.save();
                    ctx.translate(screenX, coin.y + wobble);
                    ctx.rotate(rotation);

                    // Coin shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(0, 20, 12, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Coin body with metallic gradient
                    const coinGradient = ctx.createRadialGradient(-3, -3, 2, 0, 0, 16);
                    coinGradient.addColorStop(0, '#ffd700');
                    coinGradient.addColorStop(0.4, '#ffed4e');
                    coinGradient.addColorStop(0.7, '#ffa500');
                    coinGradient.addColorStop(1, '#cc8400');

                    ctx.fillStyle = coinGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();

                    // Coin rim
                    ctx.strokeStyle = '#cc8400';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner circle
                    ctx.strokeStyle = '#ffed4e';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 11, 0, Math.PI * 2);
                    ctx.stroke();

                    // Highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(-4, -4, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            });
        }

        // Draw interactive objects
        function drawInteractiveObjects() {
            interactiveObjects.forEach(obj => {
                const screenX = obj.x - camera.x;
                const screenY = obj.y;

                // Highlight if near player
                const dist = Math.abs(player.x - obj.x);
                const isNear = dist < 80 && Math.abs(player.y - obj.y) < 100;

                if (obj.type === 'lever') {
                    // Lever base
                    ctx.fillStyle = '#34495e';
                    ctx.fillRect(screenX + 10, screenY + 40, 20, 20);

                    // Lever arm
                    ctx.save();
                    ctx.translate(screenX + 20, screenY + 40);
                    ctx.rotate(obj.active ? -0.5 : 0.5);

                    const leverGradient = ctx.createLinearGradient(0, 0, 0, -35);
                    leverGradient.addColorStop(0, '#7f8c8d');
                    leverGradient.addColorStop(1, '#95a5a6');

                    ctx.fillStyle = leverGradient;
                    ctx.fillRect(-4, -35, 8, 35);

                    // Lever handle
                    ctx.fillStyle = obj.active ? '#27ae60' : '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(0, -35, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();

                    if (isNear) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TAP', screenX + 20, screenY - 10);
                    }
                } else if (obj.type === 'terminal') {
                    // Terminal body
                    const termGradient = ctx.createLinearGradient(0, screenY, 0, screenY + obj.height);
                    termGradient.addColorStop(0, '#34495e');
                    termGradient.addColorStop(1, '#2c3e50');

                    ctx.fillStyle = termGradient;
                    ctx.fillRect(screenX, screenY, obj.width, obj.height);

                    // Screen
                    ctx.fillStyle = obj.active ? '#27ae60' : '#1a1a1a';
                    ctx.fillRect(screenX + 5, screenY + 5, obj.width - 10, obj.height - 25);

                    // Screen text
                    if (obj.active) {
                        ctx.fillStyle = '#2ecc71';
                        ctx.font = 'bold 10px monospace';
                        ctx.textAlign = 'left';
                        ctx.fillText('ACTIVE', screenX + 8, screenY + 20);
                        ctx.fillText('>>OK', screenX + 8, screenY + 32);
                    }

                    // Buttons
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(screenX + 8 + i * 12, screenY + obj.height - 15, 8, 8);
                    }

                    if (isNear) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TAP', screenX + obj.width / 2, screenY - 10);
                    }
                } else if (obj.type === 'door') {
                    // Door frame
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(screenX, screenY, obj.width, obj.height);

                    // Door panel
                    const doorColor = obj.active ? '#27ae60' : '#c0392b';
                    const doorGradient = ctx.createLinearGradient(screenX, screenY, screenX + obj.width, screenY);
                    doorGradient.addColorStop(0, darkenColor(doorColor, 20));
                    doorGradient.addColorStop(0.5, doorColor);
                    doorGradient.addColorStop(1, darkenColor(doorColor, 20));

                    ctx.fillStyle = doorGradient;
                    ctx.fillRect(screenX + 5, screenY + 5, obj.width - 10, obj.height - 10);

                    // Door details
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX + 10, screenY + 10, obj.width - 20, obj.height - 20);

                    // Status light
                    ctx.fillStyle = obj.active ? '#2ecc71' : '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(screenX + obj.width / 2, screenY + 15, 4, 0, Math.PI * 2);
                    ctx.fill();

                    if (isNear) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        const text = obj.active ? 'OPEN' : 'LOCKED';
                        ctx.fillText(text, screenX + obj.width / 2, screenY - 10);
                    }
                }
            });
        }

        // Draw game over screen
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('Score: ' + money, canvas.width / 2, canvas.height / 2 + 20);

            const alpha = Math.sin(frame * 0.08) * 0.4 + 0.6;
            ctx.globalAlpha = alpha;
            ctx.font = 'bold 24px Arial';
            ctx.fillText('TAP TO RESTART', canvas.width / 2, canvas.height / 2 + 80);
            ctx.globalAlpha = 1;
        }

        // Color helpers
        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Update player physics
        function updatePlayer() {
            // Gravity
            player.vy += 0.7;

            // Movement from swipe
            if (isSwipeMoving) {
                player.vx = player.speed * swipeDirection;
                player.facing = swipeDirection;
            } else {
                player.vx *= 0.85; // Friction
            }

            // Apply velocity
            player.x += player.vx;
            player.y += player.vy;

            // Reset grounded
            player.grounded = false;

            // Platform collision
            platforms.forEach(platform => {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + 20 + player.vy) {

                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.grounded = true;
                    player.jumping = false;
                }
            });

            // Fall off screen
            if (player.y > canvas.height + 100) {
                lives--;
                if (lives <= 0) {
                    state = 'gameover';
                } else {
                    initLevel1();
                }
            }

            // Update camera
            camera.targetX = player.x - canvas.width / 3;
            camera.targetX = Math.max(0, camera.targetX);
            camera.x += (camera.targetX - camera.x) * camera.smoothing;
        }

        // Update enemies
        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.x += enemy.vx * enemy.dir;

                // Turn around at edges
                const onPlatform = platforms.some(p =>
                    enemy.x + enemy.width > p.x &&
                    enemy.x < p.x + p.width
                );

                if (!onPlatform || enemy.x < 0 || enemy.x > 2600) {
                    enemy.dir *= -1;
                }

                // Player collision
                if (player.x + player.width > enemy.x &&
                    player.x < enemy.x + enemy.width &&
                    player.y + player.height > enemy.y &&
                    player.y < enemy.y + enemy.height) {

                    lives--;
                    if (lives <= 0) {
                        state = 'gameover';
                    } else {
                        initLevel1();
                    }
                }
            });
        }

        // Update coins
        function updateCoins() {
            coins.forEach(coin => {
                if (!coin.collected) {
                    const dist = Math.sqrt(
                        Math.pow(player.x + player.width / 2 - coin.x, 2) +
                        Math.pow(player.y + player.height / 2 - coin.y, 2)
                    );

                    if (dist < 30) {
                        coin.collected = true;
                        money += 10;
                        createCoinParticles(coin.x, coin.y);
                    }
                }
            });
        }

        // Create particle effect
        function createCoinParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 30,
                    color: '#ffd700'
                });
            }
        }

        // Update and draw particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;

                const screenX = p.x - camera.x;

                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.fillRect(screenX, p.y, 4, 4);
                ctx.globalAlpha = 1;

                return p.life > 0;
            });
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (state === 'title') {
                drawTitleScreen();
            } else if (state === 'playing') {
                drawBackground();
                drawPlatforms();
                drawInteractiveObjects();
                drawCoins();
                drawEnemies();
                drawPlayer();
                updateParticles();

                updatePlayer();
                updateEnemies();
                updateCoins();

                // Update HUD
                document.getElementById('lives').textContent = lives;
                document.getElementById('levelDisplay').textContent = level;
                document.getElementById('money').textContent = money;
            } else if (state === 'gameover') {
                drawGameOver();
            }

            frame++;
            requestAnimationFrame(gameLoop);
        }

        // Touch/Swipe controls
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        function handleTouchStart(e) {
            e.preventDefault();

            const touch = e.touches[0];
            touchStart = {
                x: touch.clientX,
                y: touch.clientY,
                time: Date.now()
            };

            if (state === 'title') {
                state = 'playing';
                initLevel1();
                document.getElementById('hud').style.display = 'flex';
                document.getElementById('touchHint').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('touchHint').style.display = 'none';
                }, 3000);
            } else if (state === 'gameover') {
                state = 'playing';
                lives = 3;
                money = 0;
                level = 1;
                initLevel1();
            } else if (state === 'playing') {
                // Check for object interaction
                checkObjectInteraction(touch.clientX, touch.clientY);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();

            if (state !== 'playing') return;

            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStart.x;
            const deltaY = touch.clientY - touchStart.y;

            // Swipe for horizontal movement
            if (Math.abs(deltaX) > 30) {
                isSwipeMoving = true;
                swipeDirection = deltaX > 0 ? 1 : -1;
            }

            // Swipe up for jump
            if (deltaY < -50 && player.grounded && !player.jumping) {
                player.vy = -player.jumpPower;
                player.jumping = true;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();

            isSwipeMoving = false;
            swipeDirection = 0;
        }

        // Check object interaction
        function checkObjectInteraction(touchX, touchY) {
            interactiveObjects.forEach(obj => {
                const screenX = obj.x - camera.x;
                const dist = Math.abs(player.x - obj.x);

                if (dist < 80 && Math.abs(player.y - obj.y) < 100) {
                    // Check if touch is on object
                    if (touchX > screenX && touchX < screenX + obj.width &&
                        touchY > obj.y && touchY < obj.y + obj.height) {
                        obj.active = !obj.active;
                        obj.triggered = true;
                    }
                }
            });
        }

        // Keyboard controls (for desktop testing)
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (state === 'title') {
                state = 'playing';
                initLevel1();
                document.getElementById('hud').style.display = 'flex';
            } else if (state === 'gameover') {
                state = 'playing';
                lives = 3;
                money = 0;
                level = 1;
                initLevel1();
            }

            // Jump
            if ((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && player.grounded) {
                player.vy = -player.jumpPower;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Keyboard movement
        setInterval(() => {
            if (state === 'playing') {
                if (keys['ArrowLeft'] || keys['a']) {
                    player.vx = -player.speed;
                    player.facing = -1;
                } else if (keys['ArrowRight'] || keys['d']) {
                    player.vx = player.speed;
                    player.facing = 1;
                }
            }
        }, 16);

        // Start game
        gameLoop();
    </script>
</body>
</html>
